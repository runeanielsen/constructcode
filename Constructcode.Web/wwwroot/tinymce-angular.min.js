/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('advlist', function(editor) {
	var olMenuItems, ulMenuItems;

	var hasPlugin = function (editor, plugin) {
		var plugins = editor.settings.plugins ? editor.settings.plugins : '';
		return tinymce.util.Tools.inArray(plugins.split(/[ ,]/), plugin) !== -1;
	};

	function isChildOfBody(elm) {
		return editor.$.contains(editor.getBody(), elm);
	}

	function isListNode(node) {
		return node && (/^(OL|UL|DL)$/).test(node.nodeName) && isChildOfBody(node);
	}

	function buildMenuItems(listName, styleValues) {
		var items = [];
		if (styleValues) {
			tinymce.each(styleValues.split(/[ ,]/), function(styleValue) {
				items.push({
					text: styleValue.replace(/\-/g, ' ').replace(/\b\w/g, function(chr) {
						return chr.toUpperCase();
					}),
					data: styleValue == 'default' ? '' : styleValue
				});
			});
		}
		return items;
	}

	olMenuItems = buildMenuItems('OL', editor.getParam(
		"advlist_number_styles",
		"default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman"
	));

	ulMenuItems = buildMenuItems('UL', editor.getParam("advlist_bullet_styles", "default,circle,disc,square"));

	function applyListFormat(listName, styleValue) {
		editor.undoManager.transact(function() {
			var list, dom = editor.dom, sel = editor.selection;

			// Check for existing list element
			list = dom.getParent(sel.getNode(), 'ol,ul');

			// Switch/add list type if needed
			if (!list || list.nodeName != listName || styleValue === false) {
				var detail = {
					'list-style-type': styleValue ? styleValue : ''
				};

				editor.execCommand(listName == 'UL' ? 'InsertUnorderedList' : 'InsertOrderedList', false, detail);
			}

			list = dom.getParent(sel.getNode(), 'ol,ul');
			if (list) {
				tinymce.util.Tools.each(dom.select('ol,ul', list).concat([list]), function (list) {
					if (list.nodeName !== listName && styleValue !== false) {
						list = dom.rename(list, listName);
					}

					dom.setStyle(list, 'listStyleType', styleValue ? styleValue : null);
					list.removeAttribute('data-mce-style');
				});
			}

			editor.focus();
		});
	}

	function updateSelection(e) {
		var listStyleType = editor.dom.getStyle(editor.dom.getParent(editor.selection.getNode(), 'ol,ul'), 'listStyleType') || '';

		e.control.items().each(function(ctrl) {
			ctrl.active(ctrl.settings.data === listStyleType);
		});
	}

	var listState = function (listName) {
		return function () {
			var self = this;

			editor.on('NodeChange', function (e) {
				var lists = tinymce.util.Tools.grep(e.parents, isListNode);
				self.active(lists.length > 0 && lists[0].nodeName === listName);
			});
		};
	};

	if (hasPlugin(editor, "lists")) {
		editor.addCommand('ApplyUnorderedListStyle', function (ui, value) {
			applyListFormat('UL', value['list-style-type']);
		});

		editor.addCommand('ApplyOrderedListStyle', function (ui, value) {
			applyListFormat('OL', value['list-style-type']);
		});

		editor.addButton('numlist', {
			type: (olMenuItems.length > 0) ? 'splitbutton' : 'button',
			tooltip: 'Numbered list',
			menu: olMenuItems,
			onPostRender: listState('OL'),
			onshow: updateSelection,
			onselect: function(e) {
				applyListFormat('OL', e.control.settings.data);
			},
			onclick: function() {
				applyListFormat('OL', false);
			}
		});

		editor.addButton('bullist', {
			type: (ulMenuItems.length > 0) ? 'splitbutton' : 'button',
			tooltip: 'Bullet list',
			onPostRender: listState('UL'),
			menu: ulMenuItems,
			onshow: updateSelection,
			onselect: function(e) {
				applyListFormat('UL', e.control.settings.data);
			},
			onclick: function() {
				applyListFormat('UL', false);
			}
		});
	}
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('anchor', function(editor) {
	var isAnchorNode = function (node) {
		return !node.attr('href') && (node.attr('id') || node.attr('name')) && !node.firstChild;
	};

	var setContentEditable = function (state) {
		return function (nodes) {
			for (var i = 0; i < nodes.length; i++) {
				if (isAnchorNode(nodes[i])) {
					nodes[i].attr('contenteditable', state);
				}
			}
		};
	};

	var isValidId = function (id) {
		// Follows HTML4 rules: https://www.w3.org/TR/html401/types.html#type-id
		return /^[A-Za-z][A-Za-z0-9\-:._]*$/.test(id);
	};

	var showDialog = function () {
		var selectedNode = editor.selection.getNode();
		var isAnchor = selectedNode.tagName == 'A' && editor.dom.getAttrib(selectedNode, 'href') === '';
		var value = '';

		if (isAnchor) {
			value = selectedNode.id || selectedNode.name || '';
		}

		editor.windowManager.open({
			title: 'Anchor',
			body: {type: 'textbox', name: 'id', size: 40, label: 'Id', value: value},
			onsubmit: function(e) {
				var id = e.data.id;

				if (!isValidId(id)) {
					e.preventDefault();
					editor.windowManager.alert(
						'Id should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores.'
					);
					return;
				}

				if (isAnchor) {
					selectedNode.removeAttribute('name');
					selectedNode.id = id;
				} else {
					editor.selection.collapse(true);
					editor.execCommand('mceInsertContent', false, editor.dom.createHTML('a', {
						id: id
					}));
				}
			}
		});
	};

	if (tinymce.Env.ceFalse) {
		editor.on('PreInit', function () {
			editor.parser.addNodeFilter('a', setContentEditable('false'));
			editor.serializer.addNodeFilter('a', setContentEditable(null));
		});
	}

	editor.addCommand('mceAnchor', showDialog);

	editor.addButton('anchor', {
		icon: 'anchor',
		tooltip: 'Anchor',
		onclick: showDialog,
		stateSelector: 'a:not([href])'
	});

	editor.addMenuItem('anchor', {
		icon: 'anchor',
		text: 'Anchor',
		context: 'insert',
		onclick: showDialog
	});
});
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('autolink', function(editor) {
	var AutoUrlDetectState;
	var AutoLinkPattern = /^(https?:\/\/|ssh:\/\/|ftp:\/\/|file:\/|www\.|(?:mailto:)?[A-Z0-9._%+\-]+@)(.+)$/i;

	if (editor.settings.autolink_pattern) {
		AutoLinkPattern = editor.settings.autolink_pattern;
	}

	editor.on("keydown", function(e) {
		if (e.keyCode == 13) {
			return handleEnter(editor);
		}
	});

	// Internet Explorer has built-in automatic linking for most cases
	if (tinymce.Env.ie) {
		editor.on("focus", function() {
			if (!AutoUrlDetectState) {
				AutoUrlDetectState = true;

				try {
					editor.execCommand('AutoUrlDetect', false, true);
				} catch (ex) {
					// Ignore
				}
			}
		});

		return;
	}

	editor.on("keypress", function(e) {
		if (e.keyCode == 41) {
			return handleEclipse(editor);
		}
	});

	editor.on("keyup", function(e) {
		if (e.keyCode == 32) {
			return handleSpacebar(editor);
		}
	});

	function handleEclipse(editor) {
		parseCurrentLine(editor, -1, '(', true);
	}

	function handleSpacebar(editor) {
		parseCurrentLine(editor, 0, '', true);
	}

	function handleEnter(editor) {
		parseCurrentLine(editor, -1, '', false);
	}

	function parseCurrentLine(editor, end_offset, delimiter) {
		var rng, end, start, endContainer, bookmark, text, matches, prev, len, rngText;

		function scopeIndex(container, index) {
			if (index < 0) {
				index = 0;
			}

			if (container.nodeType == 3) {
				var len = container.data.length;

				if (index > len) {
					index = len;
				}
			}

			return index;
		}

		function setStart(container, offset) {
			if (container.nodeType != 1 || container.hasChildNodes()) {
				rng.setStart(container, scopeIndex(container, offset));
			} else {
				rng.setStartBefore(container);
			}
		}

		function setEnd(container, offset) {
			if (container.nodeType != 1 || container.hasChildNodes()) {
				rng.setEnd(container, scopeIndex(container, offset));
			} else {
				rng.setEndAfter(container);
			}
		}

		// Never create a link when we are inside a link
		if (editor.selection.getNode().tagName == 'A') {
			return;
		}

		// We need at least five characters to form a URL,
		// hence, at minimum, five characters from the beginning of the line.
		rng = editor.selection.getRng(true).cloneRange();
		if (rng.startOffset < 5) {
			// During testing, the caret is placed between two text nodes.
			// The previous text node contains the URL.
			prev = rng.endContainer.previousSibling;
			if (!prev) {
				if (!rng.endContainer.firstChild || !rng.endContainer.firstChild.nextSibling) {
					return;
				}

				prev = rng.endContainer.firstChild.nextSibling;
			}

			len = prev.length;
			setStart(prev, len);
			setEnd(prev, len);

			if (rng.endOffset < 5) {
				return;
			}

			end = rng.endOffset;
			endContainer = prev;
		} else {
			endContainer = rng.endContainer;

			// Get a text node
			if (endContainer.nodeType != 3 && endContainer.firstChild) {
				while (endContainer.nodeType != 3 && endContainer.firstChild) {
					endContainer = endContainer.firstChild;
				}

				// Move range to text node
				if (endContainer.nodeType == 3) {
					setStart(endContainer, 0);
					setEnd(endContainer, endContainer.nodeValue.length);
				}
			}

			if (rng.endOffset == 1) {
				end = 2;
			} else {
				end = rng.endOffset - 1 - end_offset;
			}
		}

		start = end;

		do {
			// Move the selection one character backwards.
			setStart(endContainer, end >= 2 ? end - 2 : 0);
			setEnd(endContainer, end >= 1 ? end - 1 : 0);
			end -= 1;
			rngText = rng.toString();

			// Loop until one of the following is found: a blank space, &nbsp;, delimiter, (end-2) >= 0
		} while (rngText != ' ' && rngText !== '' && rngText.charCodeAt(0) != 160 && (end - 2) >= 0 && rngText != delimiter);

		if (rng.toString() == delimiter || rng.toString().charCodeAt(0) == 160) {
			setStart(endContainer, end);
			setEnd(endContainer, start);
			end += 1;
		} else if (rng.startOffset === 0) {
			setStart(endContainer, 0);
			setEnd(endContainer, start);
		} else {
			setStart(endContainer, end);
			setEnd(endContainer, start);
		}

		// Exclude last . from word like "www.site.com."
		text = rng.toString();
		if (text.charAt(text.length - 1) == '.') {
			setEnd(endContainer, start - 1);
		}

		text = rng.toString();
		matches = text.match(AutoLinkPattern);

		if (matches) {
			if (matches[1] == 'www.') {
				matches[1] = 'http://www.';
			} else if (/@$/.test(matches[1]) && !/^mailto:/.test(matches[1])) {
				matches[1] = 'mailto:' + matches[1];
			}

			bookmark = editor.selection.getBookmark();

			editor.selection.setRng(rng);
			editor.execCommand('createlink', false, matches[1] + matches[2]);

			if (editor.settings.default_link_target) {
				editor.dom.setAttrib(editor.selection.getNode(), 'target', editor.settings.default_link_target);
			}

			editor.selection.moveToBookmark(bookmark);
			editor.nodeChanged();
		}
	}
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */
/*eslint no-nested-ternary:0 */

/**
 * Auto Resize
 *
 * This plugin automatically resizes the content area to fit its content height.
 * It will retain a minimum height, which is the height of the content area when
 * it's initialized.
 */
tinymce.PluginManager.add('autoresize', function(editor) {
	var settings = editor.settings, oldSize = 0;

	function isFullscreen() {
		return editor.plugins.fullscreen && editor.plugins.fullscreen.isFullscreen();
	}

	if (editor.settings.inline) {
		return;
	}

	/**
	 * This method gets executed each time the editor needs to resize.
	 */
	function resize(e) {
		var deltaSize, doc, body, docElm, DOM = tinymce.DOM, resizeHeight, myHeight,
			marginTop, marginBottom, paddingTop, paddingBottom, borderTop, borderBottom;

		doc = editor.getDoc();
		if (!doc) {
			return;
		}

		body = doc.body;
		docElm = doc.documentElement;
		resizeHeight = settings.autoresize_min_height;

		if (!body || (e && e.type === "setcontent" && e.initial) || isFullscreen()) {
			if (body && docElm) {
				body.style.overflowY = "auto";
				docElm.style.overflowY = "auto"; // Old IE
			}

			return;
		}

		// Calculate outer height of the body element using CSS styles
		marginTop = editor.dom.getStyle(body, 'margin-top', true);
		marginBottom = editor.dom.getStyle(body, 'margin-bottom', true);
		paddingTop = editor.dom.getStyle(body, 'padding-top', true);
		paddingBottom = editor.dom.getStyle(body, 'padding-bottom', true);
		borderTop = editor.dom.getStyle(body, 'border-top-width', true);
		borderBottom = editor.dom.getStyle(body, 'border-bottom-width', true);
		myHeight = body.offsetHeight + parseInt(marginTop, 10) + parseInt(marginBottom, 10) +
			parseInt(paddingTop, 10) + parseInt(paddingBottom, 10) +
			parseInt(borderTop, 10) + parseInt(borderBottom, 10);

		// Make sure we have a valid height
		if (isNaN(myHeight) || myHeight <= 0) {
			// Get height differently depending on the browser used
			myHeight = tinymce.Env.ie ? body.scrollHeight : (tinymce.Env.webkit && body.clientHeight === 0 ? 0 : body.offsetHeight);
		}

		// Don't make it smaller than the minimum height
		if (myHeight > settings.autoresize_min_height) {
			resizeHeight = myHeight;
		}

		// If a maximum height has been defined don't exceed this height
		if (settings.autoresize_max_height && myHeight > settings.autoresize_max_height) {
			resizeHeight = settings.autoresize_max_height;
			body.style.overflowY = "auto";
			docElm.style.overflowY = "auto"; // Old IE
		} else {
			body.style.overflowY = "hidden";
			docElm.style.overflowY = "hidden"; // Old IE
			body.scrollTop = 0;
		}

		// Resize content element
		if (resizeHeight !== oldSize) {
			deltaSize = resizeHeight - oldSize;
			DOM.setStyle(editor.iframeElement, 'height', resizeHeight + 'px');
			oldSize = resizeHeight;

			// WebKit doesn't decrease the size of the body element until the iframe gets resized
			// So we need to continue to resize the iframe down until the size gets fixed
			if (tinymce.isWebKit && deltaSize < 0) {
				resize(e);
			}
		}
	}

	/**
	 * Calls the resize x times in 100ms intervals. We can't wait for load events since
	 * the CSS files might load async.
	 */
	function wait(times, interval, callback) {
		tinymce.util.Delay.setEditorTimeout(editor, function() {
			resize({});

			if (times--) {
				wait(times, interval, callback);
			} else if (callback) {
				callback();
			}
		}, interval);
	}

	// Define minimum height
	settings.autoresize_min_height = parseInt(editor.getParam('autoresize_min_height', editor.getElement().offsetHeight), 10);

	// Define maximum height
	settings.autoresize_max_height = parseInt(editor.getParam('autoresize_max_height', 0), 10);

	// Add padding at the bottom for better UX
	editor.on("init", function() {
		var overflowPadding, bottomMargin;

		overflowPadding = editor.getParam('autoresize_overflow_padding', 1);
		bottomMargin = editor.getParam('autoresize_bottom_margin', 50);

		if (overflowPadding !== false) {
			editor.dom.setStyles(editor.getBody(), {
				paddingLeft: overflowPadding,
				paddingRight: overflowPadding
			});
		}

		if (bottomMargin !== false) {
			editor.dom.setStyles(editor.getBody(), {
				paddingBottom: bottomMargin
			});
		}
	});

	// Add appropriate listeners for resizing content area
	editor.on("nodechange setcontent keyup FullscreenStateChanged", resize);

	if (editor.getParam('autoresize_on_init', true)) {
		editor.on('init', function() {
			// Hit it 20 times in 100 ms intervals
			wait(20, 100, function() {
				// Hit it 5 times in 1 sec intervals
				wait(5, 1000);
			});
		});
	}

	// Register the command so that it can be invoked by using tinyMCE.activeEditor.execCommand('mceExample');
	editor.addCommand('mceAutoResize', resize);
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

// Internal unload handler will be called before the page is unloaded
// Needs to be outside the plugin since it would otherwise keep
// a reference to editor in closue scope
/*eslint no-func-assign:0 */
tinymce._beforeUnloadHandler = function() {
	var msg;

	tinymce.each(tinymce.editors, function(editor) {
		// Store a draft for each editor instance
		if (editor.plugins.autosave) {
			editor.plugins.autosave.storeDraft();
		}

		// Setup a return message if the editor is dirty
		if (!msg && editor.isDirty() && editor.getParam("autosave_ask_before_unload", true)) {
			msg = editor.translate("You have unsaved changes are you sure you want to navigate away?");
		}
	});

	return msg;
};

tinymce.PluginManager.add('autosave', function(editor) {
	var settings = editor.settings, LocalStorage = tinymce.util.LocalStorage, prefix, started;

	prefix = settings.autosave_prefix || 'tinymce-autosave-{path}{query}-{id}-';
	prefix = prefix.replace(/\{path\}/g, document.location.pathname);
	prefix = prefix.replace(/\{query\}/g, document.location.search);
	prefix = prefix.replace(/\{id\}/g, editor.id);

	function parseTime(time, defaultTime) {
		var multipels = {
			s: 1000,
			m: 60000
		};

		time = /^(\d+)([ms]?)$/.exec('' + (time || defaultTime));

		return (time[2] ? multipels[time[2]] : 1) * parseInt(time, 10);
	}

	function hasDraft() {
		var time = parseInt(LocalStorage.getItem(prefix + "time"), 10) || 0;

		if (new Date().getTime() - time > settings.autosave_retention) {
			removeDraft(false);
			return false;
		}

		return true;
	}

	function removeDraft(fire) {
		LocalStorage.removeItem(prefix + "draft");
		LocalStorage.removeItem(prefix + "time");

		if (fire !== false) {
			editor.fire('RemoveDraft');
		}
	}

	function storeDraft() {
		if (!isEmpty() && editor.isDirty()) {
			LocalStorage.setItem(prefix + "draft", editor.getContent({format: 'raw', no_events: true}));
			LocalStorage.setItem(prefix + "time", new Date().getTime());
			editor.fire('StoreDraft');
		}
	}

	function restoreDraft() {
		if (hasDraft()) {
			editor.setContent(LocalStorage.getItem(prefix + "draft"), {format: 'raw'});
			editor.fire('RestoreDraft');
		}
	}

	function startStoreDraft() {
		if (!started) {
			setInterval(function() {
				if (!editor.removed) {
					storeDraft();
				}
			}, settings.autosave_interval);

			started = true;
		}
	}

	settings.autosave_interval = parseTime(settings.autosave_interval, '30s');
	settings.autosave_retention = parseTime(settings.autosave_retention, '20m');

	function postRender() {
		var self = this;

		self.disabled(!hasDraft());

		editor.on('StoreDraft RestoreDraft RemoveDraft', function() {
			self.disabled(!hasDraft());
		});

		startStoreDraft();
	}

	function restoreLastDraft() {
		editor.undoManager.beforeChange();
		restoreDraft();
		removeDraft();
		editor.undoManager.add();
	}

	editor.addButton('restoredraft', {
		title: 'Restore last draft',
		onclick: restoreLastDraft,
		onPostRender: postRender
	});

	editor.addMenuItem('restoredraft', {
		text: 'Restore last draft',
		onclick: restoreLastDraft,
		onPostRender: postRender,
		context: 'file'
	});

	function isEmpty(html) {
		var forcedRootBlockName = editor.settings.forced_root_block;

		html = tinymce.trim(typeof html == "undefined" ? editor.getBody().innerHTML : html);

		return html === '' || new RegExp(
			'^<' + forcedRootBlockName + '[^>]*>((\u00a0|&nbsp;|[ \t]|<br[^>]*>)+?|)<\/' + forcedRootBlockName + '>|<br>$', 'i'
		).test(html);
	}

	if (editor.settings.autosave_restore_when_empty !== false) {
		editor.on('init', function() {
			if (hasDraft() && isEmpty()) {
				restoreDraft();
			}
		});

		editor.on('saveContent', function() {
			removeDraft();
		});
	}

	window.onbeforeunload = tinymce._beforeUnloadHandler;

	this.hasDraft = hasDraft;
	this.storeDraft = storeDraft;
	this.restoreDraft = restoreDraft;
	this.removeDraft = removeDraft;
	this.isEmpty = isEmpty;
});
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

(function() {
	tinymce.create('tinymce.plugins.BBCodePlugin', {
		init: function(ed) {
			var self = this, dialect = ed.getParam('bbcode_dialect', 'punbb').toLowerCase();

			ed.on('beforeSetContent', function(e) {
				e.content = self['_' + dialect + '_bbcode2html'](e.content);
			});

			ed.on('postProcess', function(e) {
				if (e.set) {
					e.content = self['_' + dialect + '_bbcode2html'](e.content);
				}

				if (e.get) {
					e.content = self['_' + dialect + '_html2bbcode'](e.content);
				}
			});
		},

		getInfo: function() {
			return {
				longname: 'BBCode Plugin',
				author: 'Ephox Corp',
				authorurl: 'http://www.tinymce.com',
				infourl: 'http://www.tinymce.com/wiki.php/Plugin:bbcode'
			};
		},

		// Private methods

		// HTML -> BBCode in PunBB dialect
		_punbb_html2bbcode: function(s) {
			s = tinymce.trim(s);

			function rep(re, str) {
				s = s.replace(re, str);
			}

			// example: <strong> to [b]
			rep(/<a.*?href=\"(.*?)\".*?>(.*?)<\/a>/gi, "[url=$1]$2[/url]");
			rep(/<font.*?color=\"(.*?)\".*?class=\"codeStyle\".*?>(.*?)<\/font>/gi, "[code][color=$1]$2[/color][/code]");
			rep(/<font.*?color=\"(.*?)\".*?class=\"quoteStyle\".*?>(.*?)<\/font>/gi, "[quote][color=$1]$2[/color][/quote]");
			rep(/<font.*?class=\"codeStyle\".*?color=\"(.*?)\".*?>(.*?)<\/font>/gi, "[code][color=$1]$2[/color][/code]");
			rep(/<font.*?class=\"quoteStyle\".*?color=\"(.*?)\".*?>(.*?)<\/font>/gi, "[quote][color=$1]$2[/color][/quote]");
			rep(/<span style=\"color: ?(.*?);\">(.*?)<\/span>/gi, "[color=$1]$2[/color]");
			rep(/<font.*?color=\"(.*?)\".*?>(.*?)<\/font>/gi, "[color=$1]$2[/color]");
			rep(/<span style=\"font-size:(.*?);\">(.*?)<\/span>/gi, "[size=$1]$2[/size]");
			rep(/<font>(.*?)<\/font>/gi, "$1");
			rep(/<img.*?src=\"(.*?)\".*?\/>/gi, "[img]$1[/img]");
			rep(/<span class=\"codeStyle\">(.*?)<\/span>/gi, "[code]$1[/code]");
			rep(/<span class=\"quoteStyle\">(.*?)<\/span>/gi, "[quote]$1[/quote]");
			rep(/<strong class=\"codeStyle\">(.*?)<\/strong>/gi, "[code][b]$1[/b][/code]");
			rep(/<strong class=\"quoteStyle\">(.*?)<\/strong>/gi, "[quote][b]$1[/b][/quote]");
			rep(/<em class=\"codeStyle\">(.*?)<\/em>/gi, "[code][i]$1[/i][/code]");
			rep(/<em class=\"quoteStyle\">(.*?)<\/em>/gi, "[quote][i]$1[/i][/quote]");
			rep(/<u class=\"codeStyle\">(.*?)<\/u>/gi, "[code][u]$1[/u][/code]");
			rep(/<u class=\"quoteStyle\">(.*?)<\/u>/gi, "[quote][u]$1[/u][/quote]");
			rep(/<\/(strong|b)>/gi, "[/b]");
			rep(/<(strong|b)>/gi, "[b]");
			rep(/<\/(em|i)>/gi, "[/i]");
			rep(/<(em|i)>/gi, "[i]");
			rep(/<\/u>/gi, "[/u]");
			rep(/<span style=\"text-decoration: ?underline;\">(.*?)<\/span>/gi, "[u]$1[/u]");
			rep(/<u>/gi, "[u]");
			rep(/<blockquote[^>]*>/gi, "[quote]");
			rep(/<\/blockquote>/gi, "[/quote]");
			rep(/<br \/>/gi, "\n");
			rep(/<br\/>/gi, "\n");
			rep(/<br>/gi, "\n");
			rep(/<p>/gi, "");
			rep(/<\/p>/gi, "\n");
			rep(/&nbsp;|\u00a0/gi, " ");
			rep(/&quot;/gi, "\"");
			rep(/&lt;/gi, "<");
			rep(/&gt;/gi, ">");
			rep(/&amp;/gi, "&");

			return s;
		},

		// BBCode -> HTML from PunBB dialect
		_punbb_bbcode2html: function(s) {
			s = tinymce.trim(s);

			function rep(re, str) {
				s = s.replace(re, str);
			}

			// example: [b] to <strong>
			rep(/\n/gi, "<br />");
			rep(/\[b\]/gi, "<strong>");
			rep(/\[\/b\]/gi, "</strong>");
			rep(/\[i\]/gi, "<em>");
			rep(/\[\/i\]/gi, "</em>");
			rep(/\[u\]/gi, "<u>");
			rep(/\[\/u\]/gi, "</u>");
			rep(/\[url=([^\]]+)\](.*?)\[\/url\]/gi, "<a href=\"$1\">$2</a>");
			rep(/\[url\](.*?)\[\/url\]/gi, "<a href=\"$1\">$1</a>");
			rep(/\[img\](.*?)\[\/img\]/gi, "<img src=\"$1\" />");
			rep(/\[color=(.*?)\](.*?)\[\/color\]/gi, "<font color=\"$1\">$2</font>");
			rep(/\[code\](.*?)\[\/code\]/gi, "<span class=\"codeStyle\">$1</span>&nbsp;");
			rep(/\[quote.*?\](.*?)\[\/quote\]/gi, "<span class=\"quoteStyle\">$1</span>&nbsp;");

			return s;
		}
	});

	// Register plugin
	tinymce.PluginManager.add('bbcode', tinymce.plugins.BBCodePlugin);
})();
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('charmap', function(editor) {
	var isArray = tinymce.util.Tools.isArray;

	function getDefaultCharMap() {
		return [
			['160', 'no-break space'],
			['173', 'soft hyphen'],
			['34', 'quotation mark'],
		// finance
			['162', 'cent sign'],
			['8364', 'euro sign'],
			['163', 'pound sign'],
			['165', 'yen sign'],
		// signs
			['169', 'copyright sign'],
			['174', 'registered sign'],
			['8482', 'trade mark sign'],
			['8240', 'per mille sign'],
			['181', 'micro sign'],
			['183', 'middle dot'],
			['8226', 'bullet'],
			['8230', 'three dot leader'],
			['8242', 'minutes / feet'],
			['8243', 'seconds / inches'],
			['167', 'section sign'],
			['182', 'paragraph sign'],
			['223', 'sharp s / ess-zed'],
		// quotations
			['8249', 'single left-pointing angle quotation mark'],
			['8250', 'single right-pointing angle quotation mark'],
			['171', 'left pointing guillemet'],
			['187', 'right pointing guillemet'],
			['8216', 'left single quotation mark'],
			['8217', 'right single quotation mark'],
			['8220', 'left double quotation mark'],
			['8221', 'right double quotation mark'],
			['8218', 'single low-9 quotation mark'],
			['8222', 'double low-9 quotation mark'],
			['60', 'less-than sign'],
			['62', 'greater-than sign'],
			['8804', 'less-than or equal to'],
			['8805', 'greater-than or equal to'],
			['8211', 'en dash'],
			['8212', 'em dash'],
			['175', 'macron'],
			['8254', 'overline'],
			['164', 'currency sign'],
			['166', 'broken bar'],
			['168', 'diaeresis'],
			['161', 'inverted exclamation mark'],
			['191', 'turned question mark'],
			['710', 'circumflex accent'],
			['732', 'small tilde'],
			['176', 'degree sign'],
			['8722', 'minus sign'],
			['177', 'plus-minus sign'],
			['247', 'division sign'],
			['8260', 'fraction slash'],
			['215', 'multiplication sign'],
			['185', 'superscript one'],
			['178', 'superscript two'],
			['179', 'superscript three'],
			['188', 'fraction one quarter'],
			['189', 'fraction one half'],
			['190', 'fraction three quarters'],
		// math / logical
			['402', 'function / florin'],
			['8747', 'integral'],
			['8721', 'n-ary sumation'],
			['8734', 'infinity'],
			['8730', 'square root'],
			['8764', 'similar to'],
			['8773', 'approximately equal to'],
			['8776', 'almost equal to'],
			['8800', 'not equal to'],
			['8801', 'identical to'],
			['8712', 'element of'],
			['8713', 'not an element of'],
			['8715', 'contains as member'],
			['8719', 'n-ary product'],
			['8743', 'logical and'],
			['8744', 'logical or'],
			['172', 'not sign'],
			['8745', 'intersection'],
			['8746', 'union'],
			['8706', 'partial differential'],
			['8704', 'for all'],
			['8707', 'there exists'],
			['8709', 'diameter'],
			['8711', 'backward difference'],
			['8727', 'asterisk operator'],
			['8733', 'proportional to'],
			['8736', 'angle'],
		// undefined
			['180', 'acute accent'],
			['184', 'cedilla'],
			['170', 'feminine ordinal indicator'],
			['186', 'masculine ordinal indicator'],
			['8224', 'dagger'],
			['8225', 'double dagger'],
		// alphabetical special chars
			['192', 'A - grave'],
			['193', 'A - acute'],
			['194', 'A - circumflex'],
			['195', 'A - tilde'],
			['196', 'A - diaeresis'],
			['197', 'A - ring above'],
			['256', 'A - macron'],
			['198', 'ligature AE'],
			['199', 'C - cedilla'],
			['200', 'E - grave'],
			['201', 'E - acute'],
			['202', 'E - circumflex'],
			['203', 'E - diaeresis'],
			['274', 'E - macron'],
			['204', 'I - grave'],
			['205', 'I - acute'],
			['206', 'I - circumflex'],
			['207', 'I - diaeresis'],
			['298', 'I - macron'],
			['208', 'ETH'],
			['209', 'N - tilde'],
			['210', 'O - grave'],
			['211', 'O - acute'],
			['212', 'O - circumflex'],
			['213', 'O - tilde'],
			['214', 'O - diaeresis'],
			['216', 'O - slash'],
			['332', 'O - macron'],
			['338', 'ligature OE'],
			['352', 'S - caron'],
			['217', 'U - grave'],
			['218', 'U - acute'],
			['219', 'U - circumflex'],
			['220', 'U - diaeresis'],
			['362', 'U - macron'],
			['221', 'Y - acute'],
			['376', 'Y - diaeresis'],
			['562', 'Y - macron'],
			['222', 'THORN'],
			['224', 'a - grave'],
			['225', 'a - acute'],
			['226', 'a - circumflex'],
			['227', 'a - tilde'],
			['228', 'a - diaeresis'],
			['229', 'a - ring above'],
			['257', 'a - macron'],
			['230', 'ligature ae'],
			['231', 'c - cedilla'],
			['232', 'e - grave'],
			['233', 'e - acute'],
			['234', 'e - circumflex'],
			['235', 'e - diaeresis'],
			['275', 'e - macron'],
			['236', 'i - grave'],
			['237', 'i - acute'],
			['238', 'i - circumflex'],
			['239', 'i - diaeresis'],
			['299', 'i - macron'],
			['240', 'eth'],
			['241', 'n - tilde'],
			['242', 'o - grave'],
			['243', 'o - acute'],
			['244', 'o - circumflex'],
			['245', 'o - tilde'],
			['246', 'o - diaeresis'],
			['248', 'o slash'],
			['333', 'o macron'],
			['339', 'ligature oe'],
			['353', 's - caron'],
			['249', 'u - grave'],
			['250', 'u - acute'],
			['251', 'u - circumflex'],
			['252', 'u - diaeresis'],
			['363', 'u - macron'],
			['253', 'y - acute'],
			['254', 'thorn'],
			['255', 'y - diaeresis'],
			['563', 'y - macron'],
			['913', 'Alpha'],
			['914', 'Beta'],
			['915', 'Gamma'],
			['916', 'Delta'],
			['917', 'Epsilon'],
			['918', 'Zeta'],
			['919', 'Eta'],
			['920', 'Theta'],
			['921', 'Iota'],
			['922', 'Kappa'],
			['923', 'Lambda'],
			['924', 'Mu'],
			['925', 'Nu'],
			['926', 'Xi'],
			['927', 'Omicron'],
			['928', 'Pi'],
			['929', 'Rho'],
			['931', 'Sigma'],
			['932', 'Tau'],
			['933', 'Upsilon'],
			['934', 'Phi'],
			['935', 'Chi'],
			['936', 'Psi'],
			['937', 'Omega'],
			['945', 'alpha'],
			['946', 'beta'],
			['947', 'gamma'],
			['948', 'delta'],
			['949', 'epsilon'],
			['950', 'zeta'],
			['951', 'eta'],
			['952', 'theta'],
			['953', 'iota'],
			['954', 'kappa'],
			['955', 'lambda'],
			['956', 'mu'],
			['957', 'nu'],
			['958', 'xi'],
			['959', 'omicron'],
			['960', 'pi'],
			['961', 'rho'],
			['962', 'final sigma'],
			['963', 'sigma'],
			['964', 'tau'],
			['965', 'upsilon'],
			['966', 'phi'],
			['967', 'chi'],
			['968', 'psi'],
			['969', 'omega'],
		// symbols
			['8501', 'alef symbol'],
			['982', 'pi symbol'],
			['8476', 'real part symbol'],
			['978', 'upsilon - hook symbol'],
			['8472', 'Weierstrass p'],
			['8465', 'imaginary part'],
		// arrows
			['8592', 'leftwards arrow'],
			['8593', 'upwards arrow'],
			['8594', 'rightwards arrow'],
			['8595', 'downwards arrow'],
			['8596', 'left right arrow'],
			['8629', 'carriage return'],
			['8656', 'leftwards double arrow'],
			['8657', 'upwards double arrow'],
			['8658', 'rightwards double arrow'],
			['8659', 'downwards double arrow'],
			['8660', 'left right double arrow'],
			['8756', 'therefore'],
			['8834', 'subset of'],
			['8835', 'superset of'],
			['8836', 'not a subset of'],
			['8838', 'subset of or equal to'],
			['8839', 'superset of or equal to'],
			['8853', 'circled plus'],
			['8855', 'circled times'],
			['8869', 'perpendicular'],
			['8901', 'dot operator'],
			['8968', 'left ceiling'],
			['8969', 'right ceiling'],
			['8970', 'left floor'],
			['8971', 'right floor'],
			['9001', 'left-pointing angle bracket'],
			['9002', 'right-pointing angle bracket'],
			['9674', 'lozenge'],
			['9824', 'black spade suit'],
			['9827', 'black club suit'],
			['9829', 'black heart suit'],
			['9830', 'black diamond suit'],
			['8194', 'en space'],
			['8195', 'em space'],
			['8201', 'thin space'],
			['8204', 'zero width non-joiner'],
			['8205', 'zero width joiner'],
			['8206', 'left-to-right mark'],
			['8207', 'right-to-left mark']
		];
	}

	function charmapFilter(charmap) {
		return tinymce.util.Tools.grep(charmap, function(item) {
			return isArray(item) && item.length == 2;
		});
	}

	function getCharsFromSetting(settingValue) {
		if (isArray(settingValue)) {
			return [].concat(charmapFilter(settingValue));
		}

		if (typeof settingValue == "function") {
			return settingValue();
		}

		return [];
	}

	function extendCharMap(charmap) {
		var settings = editor.settings;

		if (settings.charmap) {
			charmap = getCharsFromSetting(settings.charmap);
		}

		if (settings.charmap_append) {
			return [].concat(charmap).concat(getCharsFromSetting(settings.charmap_append));
		}

		return charmap;
	}

	function getCharMap() {
		return extendCharMap(getDefaultCharMap());
	}

	function insertChar(chr) {
		editor.fire('insertCustomChar', {chr: chr}).chr;
		editor.execCommand('mceInsertContent', false, chr);
	}

	function showDialog() {
		var gridHtml, x, y, win;

		function getParentTd(elm) {
			while (elm) {
				if (elm.nodeName == 'TD') {
					return elm;
				}

				elm = elm.parentNode;
			}
		}

		gridHtml = '<table role="presentation" cellspacing="0" class="mce-charmap"><tbody>';

		var charmap = getCharMap();
		var width = Math.min(charmap.length, 25);
		var height = Math.ceil(charmap.length / width);
		for (y = 0; y < height; y++) {
			gridHtml += '<tr>';

			for (x = 0; x < width; x++) {
				var index = y * width + x;
				if (index < charmap.length) {
					var chr = charmap[index];
					var chrText = chr ? String.fromCharCode(parseInt(chr[0], 10)) : '&nbsp;';

					gridHtml += (
						'<td title="' + chr[1] + '"><div tabindex="-1" title="' + chr[1] + '" role="button" data-chr="' + chrText + '">' +
							chrText +
						'</div></td>'
					);
				} else {
					gridHtml += '<td />';
				}
			}

			gridHtml += '</tr>';
		}

		gridHtml += '</tbody></table>';

		var charMapPanel = {
			type: 'container',
			html: gridHtml,
			onclick: function(e) {
				var target = e.target;

				if (/^(TD|DIV)$/.test(target.nodeName)) {
					if (getParentTd(target).firstChild) {
						insertChar(target.getAttribute('data-chr'));

						if (!e.ctrlKey) {
							win.close();
						}
					}
				}
			},
			onmouseover: function(e) {
				var td = getParentTd(e.target);

				if (td && td.firstChild) {
					win.find('#preview').text(td.firstChild.firstChild.data);
					win.find('#previewTitle').text(td.title);
				} else {
					win.find('#preview').text(' ');
					win.find('#previewTitle').text(' ');
				}
			}
		};

		win = editor.windowManager.open({
			title: "Special character",
			spacing: 10,
			padding: 10,
			items: [
				charMapPanel,
				{
					type: 'container',
					layout: 'flex',
					direction: 'column',
					align: 'center',
					spacing: 5,
					minWidth: 160,
					minHeight: 160,
					items: [
						{
							type: 'label',
							name: 'preview',
							text: ' ',
							style: 'font-size: 40px; text-align: center',
							border: 1,
							minWidth: 140,
							minHeight: 80
						},
						{
							type: 'label',
							name: 'previewTitle',
							text: ' ',
							style: 'text-align: center',
							border: 1,
							minWidth: 140,
							minHeight: 80
						}
					]
				}
			],
			buttons: [
				{text: "Close", onclick: function() {
					win.close();
				}}
			]
		});
	}

	editor.addCommand('mceShowCharmap', showDialog);

	editor.addButton('charmap', {
		icon: 'charmap',
		tooltip: 'Special character',
		cmd: 'mceShowCharmap'
	});

	editor.addMenuItem('charmap', {
		icon: 'charmap',
		text: 'Special character',
		cmd: 'mceShowCharmap',
		context: 'insert'
	});

	return {
		getCharMap: getCharMap,
		insertChar: insertChar
	};
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('code', function(editor) {
	function showDialog() {
		var win = editor.windowManager.open({
			title: "Source code",
			body: {
				type: 'textbox',
				name: 'code',
				multiline: true,
				minWidth: editor.getParam("code_dialog_width", 600),
				minHeight: editor.getParam("code_dialog_height", Math.min(tinymce.DOM.getViewPort().h - 200, 500)),
				spellcheck: false,
				style: 'direction: ltr; text-align: left'
			},
			onSubmit: function(e) {
				// We get a lovely "Wrong document" error in IE 11 if we
				// don't move the focus to the editor before creating an undo
				// transation since it tries to make a bookmark for the current selection
				editor.focus();

				editor.undoManager.transact(function() {
					editor.setContent(e.data.code);
				});

				editor.selection.setCursorLocation();
				editor.nodeChanged();
			}
		});

		// Gecko has a major performance issue with textarea
		// contents so we need to set it when all reflows are done
		win.find('#code').value(editor.getContent({source_view: true}));
	}

	editor.addCommand("mceCodeEditor", showDialog);

	editor.addButton('code', {
		icon: 'code',
		tooltip: 'Source code',
		onclick: showDialog
	});

	editor.addMenuItem('code', {
		icon: 'code',
		text: 'Source code',
		context: 'tools',
		onclick: showDialog
	});
});
/**
 * Compiled inline version. (Library mode)
 */

/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */
/*globals $code */

(function(exports, undefined) {
	"use strict";

	var modules = {};

	function require(ids, callback) {
		var module, defs = [];

		for (var i = 0; i < ids.length; ++i) {
			module = modules[ids[i]] || resolve(ids[i]);
			if (!module) {
				throw 'module definition dependecy not found: ' + ids[i];
			}

			defs.push(module);
		}

		callback.apply(null, defs);
	}

	function define(id, dependencies, definition) {
		if (typeof id !== 'string') {
			throw 'invalid module definition, module id must be defined and be a string';
		}

		if (dependencies === undefined) {
			throw 'invalid module definition, dependencies must be specified';
		}

		if (definition === undefined) {
			throw 'invalid module definition, definition function must be specified';
		}

		require(dependencies, function() {
			modules[id] = definition.apply(null, arguments);
		});
	}

	function defined(id) {
		return !!modules[id];
	}

	function resolve(id) {
		var target = exports;
		var fragments = id.split(/[.\/]/);

		for (var fi = 0; fi < fragments.length; ++fi) {
			if (!target[fragments[fi]]) {
				return;
			}

			target = target[fragments[fi]];
		}

		return target;
	}

	function expose(ids) {
		var i, target, id, fragments, privateModules;

		for (i = 0; i < ids.length; i++) {
			target = exports;
			id = ids[i];
			fragments = id.split(/[.\/]/);

			for (var fi = 0; fi < fragments.length - 1; ++fi) {
				if (target[fragments[fi]] === undefined) {
					target[fragments[fi]] = {};
				}

				target = target[fragments[fi]];
			}

			target[fragments[fragments.length - 1]] = modules[id];
		}

		// Expose private modules for unit tests
		if (exports.AMDLC_TESTS) {
			privateModules = exports.privateModules || {};

			for (id in modules) {
				privateModules[id] = modules[id];
			}

			for (i = 0; i < ids.length; i++) {
				delete privateModules[ids[i]];
			}

			exports.privateModules = privateModules;
		}
	}

// Included from: js/tinymce/plugins/codesample/classes/Prism.js

/**
 * Prism.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 *
 * Import of prism. Disabled DOMContentLoaded event listener.
 */

define("tinymce/codesampleplugin/Prism", [], function() {
var window = {};
// ------------------ Start wrap

/* http://prismjs.com/download.html?themes=prism-dark&languages=markup+css+clike+javascript+c+csharp+cpp+java+php+python+ruby */
var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

// Private helper vars
var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;

var _ = _self.Prism = {
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (_.util.type(tokens) === 'Array') {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case 'Object':
					var clone = {};

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}

					return clone;

				case 'Array':
					// Check for existence for IE8
					return o.map && o.map(function(v) { return _.util.clone(v); });
			}

			return o;
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Insert a token before another token in a language literal
		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
		 * we cannot just provide an object, we need anobject and a key.
		 * @param inside The key (or language id) of the parent
		 * @param before The key to insert before. If not provided, the function appends instead.
		 * @param insert Object with the key/value pairs to insert
		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];

			if (arguments.length == 2) {
				insert = arguments[1];

				for (var newToken in insert) {
					if (insert.hasOwnProperty(newToken)) {
						grammar[newToken] = insert[newToken];
					}
				}

				return grammar;
			}

			var ret = {};

			for (var token in grammar) {

				if (grammar.hasOwnProperty(token)) {

					if (token == before) {

						for (var newToken in insert) {

							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					ret[token] = grammar[token];
				}
			}

			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === root[inside] && key != inside) {
					this[key] = ret;
				}
			});

			return root[inside] = ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function(o, callback, type) {
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					if (_.util.type(o[i]) === 'Object') {
						_.languages.DFS(o[i], callback);
					}
					else if (_.util.type(o[i]) === 'Array') {
						_.languages.DFS(o[i], callback, i);
					}
				}
			}
		}
	},
	plugins: {},

	highlightAll: function(async, callback) {
		var elements = document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code');

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;

		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,''])[1];
			grammar = _.languages[language];
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		if (!code || !grammar) {
			_.hooks.run('complete', env);
			return;
		}

		_.hooks.run('before-highlight', env);

		if (async && _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				env.highlightedCode = evt.data;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				callback && callback.call(env.element);
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			callback && callback.call(element);

			_.hooks.run('after-highlight', env);
			_.hooks.run('complete', env);
		}
	},

	highlight: function (text, grammar, language) {
		var tokens = _.tokenize(text, grammar);
		return Token.stringify(_.util.encode(tokens), language);
	},

	tokenize: function(text, grammar, language) {
		var Token = _.Token;

		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					lookbehindLength = 0,
					alias = pattern.alias;

				pattern = pattern.pattern || pattern;

				for (var i=0; i<strarr.length; i++) { // Donâ€™t cache length as it changes during the loop

					var str = strarr[i];

					if (strarr.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						break tokenloop;
					}

					if (str instanceof Token) {
						continue;
					}

					pattern.lastIndex = 0;

					var match = pattern.exec(str);

					if (match) {
						if(lookbehind) {
							lookbehindLength = match[1].length;
						}

						var from = match.index - 1 + lookbehindLength,
							match = match[0].slice(lookbehindLength),
							len = match.length,
							to = from + len,
							before = str.slice(0, from + 1),
							after = str.slice(to + 1);

						var args = [i, 1];

						if (before) {
							args.push(before);
						}

						var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias);

						args.push(wrapped);

						if (after) {
							args.push(after);
						}

						Array.prototype.splice.apply(strarr, args);
					}
				}
			}
		}

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content, alias) {
	this.type = type;
	this.content = content;
	this.alias = alias;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
		return o;
	}

	if (_.util.type(o) === 'Array') {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join('');
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language,
		parent: parent
	};

	if (env.type == 'comment') {
		env.attributes['spellcheck'] = 'true';
	}

	if (o.alias) {
		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = '';

	for (var name in env.attributes) {
		attributes += (attributes ? ' ' : '') + name + '="' + (env.attributes[name] || '') + '"';
	}

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '" ' + attributes + '>' + env.content + '</' + env.tag + '>';

};

if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _self.Prism;
	}
 	// In worker
	_self.addEventListener('message', function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code,
		    immediateClose = message.immediateClose;

		_self.postMessage(_.highlight(code, _.languages[lang], lang));
		if (immediateClose) {
			_self.close();
		}
	}, false);

	return _self.Prism;
}
/*
// Get current script and highlight
var script = document.getElementsByTagName('script');

script = script[script.length - 1];

if (script) {
	_.filename = script.src;

	if (document.addEventListener && !script.hasAttribute('data-manual')) {
		document.addEventListener('DOMContentLoaded', _.highlightAll);
	}
}

return _self.Prism;
*/
})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}
;
Prism.languages.markup = {
	'comment': /<!--[\w\W]*?-->/,
	'prolog': /<\?[\w\W]+?\?>/,
	'doctype': /<!DOCTYPE[\w\W]+?>/,
	'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
	'tag': {
		pattern: /<\/?[^\s>\/=.]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
				inside: {
					'punctuation': /[=>"']/
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function(env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;

Prism.languages.css = {
	'comment': /\/\*[\w\W]*?\*\//,
	'atrule': {
		pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
		inside: {
			'rule': /@[\w-]+/
			// See rest below
		}
	},
	'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
	'string': /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
	'property': /(\b|\B)[\w-]+(?=\s*:)/i,
	'important': /\B!important\b/i,
	'function': /[-a-z0-9]+(?=\()/i,
	'punctuation': /[(){};:]/
};

Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'style': {
			pattern: /<style[\w\W]*?>[\w\W]*?<\/style>/i,
			inside: {
				'tag': {
					pattern: /<style[\w\W]*?>|<\/style>/i,
					inside: Prism.languages.markup.tag.inside
				},
				rest: Prism.languages.css
			},
			alias: 'language-css'
		}
	});

	Prism.languages.insertBefore('inside', 'attr-value', {
		'style-attr': {
			pattern: /\s*style=("|').*?\1/i,
			inside: {
				'attr-name': {
					pattern: /^\s*style/i,
					inside: Prism.languages.markup.tag.inside
				},
				'punctuation': /^\s*=\s*['"]|['"]\s*$/,
				'attr-value': {
					pattern: /.+/i,
					inside: Prism.languages.css
				}
			},
			alias: 'language-css'
		}
	}, Prism.languages.markup.tag);
};
Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
			lookbehind: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true
		}
	],
	'string': /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(true|false)\b/,
	'function': /[a-z0-9_]+(?=\()/i,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};

Prism.languages.javascript = Prism.languages.extend('clike', {
	'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/,
	'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i
});

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true
	}
});

Prism.languages.insertBefore('javascript', 'class-name', {
	'template-string': {
		pattern: /`(?:\\`|\\?[^`])*`/,
		inside: {
			'interpolation': {
				pattern: /\$\{[^}]+\}/,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'script': {
			pattern: /<script[\w\W]*?>[\w\W]*?<\/script>/i,
			inside: {
				'tag': {
					pattern: /<script[\w\W]*?>|<\/script>/i,
					inside: Prism.languages.markup.tag.inside
				},
				rest: Prism.languages.javascript
			},
			alias: 'language-javascript'
		}
	});
}

Prism.languages.js = Prism.languages.javascript;
Prism.languages.c = Prism.languages.extend('clike', {
	'keyword': /\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,
	'operator': /\-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*\/]/,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)[ful]*\b/i
});

Prism.languages.insertBefore('c', 'string', {
	'macro': {
		// allow for multiline macro definitions
		// spaces after the # character compile fine with gcc
		pattern: /(^\s*)#\s*[a-z]+([^\r\n\\]|\\.|\\(?:\r\n?|\n))*/im,
		lookbehind: true,
		alias: 'property',
		inside: {
			// highlight the path of the include statement as a string
			'string': {
				pattern: /(#\s*include\s*)(<.+?>|("|')(\\?.)+?\3)/,
				lookbehind: true
			}
		}
	}
});

delete Prism.languages.c['class-name'];
delete Prism.languages.c['boolean'];

Prism.languages.csharp = Prism.languages.extend('clike', {
	'keyword': /\b(abstract|as|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|virtual|void|volatile|while|add|alias|ascending|async|await|descending|dynamic|from|get|global|group|into|join|let|orderby|partial|remove|select|set|value|var|where|yield)\b/,
	'string': [
		/@("|')(\1\1|\\\1|\\?(?!\1)[\s\S])*\1/,
		/("|')(\\?.)*?\1/
	],
	'number': /\b-?(0x[\da-f]+|\d*\.?\d+)\b/i
});

Prism.languages.insertBefore('csharp', 'keyword', {
	'preprocessor': {
		pattern: /(^\s*)#.*/m,
		lookbehind: true
	}
});

Prism.languages.cpp = Prism.languages.extend('c', {
	'keyword': /\b(alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,
	'boolean': /\b(true|false)\b/,
	'operator': /[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\->|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|?\||\?|\*|\/|\b(and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/
});

Prism.languages.insertBefore('cpp', 'keyword', {
	'class-name': {
		pattern: /(class\s+)[a-z0-9_]+/i,
		lookbehind: true
	}
});
Prism.languages.java = Prism.languages.extend('clike', {
	'keyword': /\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,
	'number': /\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+(?:e[+-]?\d+)?[df]?\b/i,
	'operator': {
		pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,
		lookbehind: true
	}
});
/**
 * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/
 * Modified by Miles Johnson: http://milesj.me
 *
 * Supports the following:
 * 		- Extends clike syntax
 * 		- Support for PHP 5.3+ (namespaces, traits, generators, etc)
 * 		- Smarter constant and function matching
 *
 * Adds the following new token classes:
 * 		constant, delimiter, variable, function, package
 */

Prism.languages.php = Prism.languages.extend('clike', {
	'keyword': /\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\b/i,
	'constant': /\b[A-Z0-9_]{2,}\b/,
	'comment': {
		pattern: /(^|[^\\])(?:\/\*[\w\W]*?\*\/|\/\/.*)/,
		lookbehind: true
	}
});

// Shell-like comments are matched after strings, because they are less
// common than strings containing hashes...
Prism.languages.insertBefore('php', 'class-name', {
	'shell-comment': {
		pattern: /(^|[^\\])#.*/,
		lookbehind: true,
		alias: 'comment'
	}
});

Prism.languages.insertBefore('php', 'keyword', {
	'delimiter': /\?>|<\?(?:php)?/i,
	'variable': /\$\w+\b/i,
	'package': {
		pattern: /(\\|namespace\s+|use\s+)[\w\\]+/,
		lookbehind: true,
		inside: {
			punctuation: /\\/
		}
	}
});

// Must be defined after the function pattern
Prism.languages.insertBefore('php', 'operator', {
	'property': {
		pattern: /(->)[\w]+/,
		lookbehind: true
	}
});

// Add HTML support of the markup language exists
if (Prism.languages.markup) {

	// Tokenize all inline PHP blocks that are wrapped in <?php ?>
	// This allows for easy PHP + markup highlighting
	Prism.hooks.add('before-highlight', function(env) {
		if (env.language !== 'php') {
			return;
		}

		env.tokenStack = [];

		env.backupCode = env.code;
		env.code = env.code.replace(/(?:<\?php|<\?)[\w\W]*?(?:\?>)/ig, function(match) {
			env.tokenStack.push(match);

			return '{{{PHP' + env.tokenStack.length + '}}}';
		});
	});

	// Restore env.code for other plugins (e.g. line-numbers)
	Prism.hooks.add('before-insert', function(env) {
		if (env.language === 'php') {
			env.code = env.backupCode;
			delete env.backupCode;
		}
	});

	// Re-insert the tokens after highlighting
	Prism.hooks.add('after-highlight', function(env) {
		if (env.language !== 'php') {
			return;
		}

		for (var i = 0, t; t = env.tokenStack[i]; i++) {
			// The replace prevents $$, $&, $`, $', $n, $nn from being interpreted as special patterns
			env.highlightedCode = env.highlightedCode.replace('{{{PHP' + (i + 1) + '}}}', Prism.highlight(t, env.grammar, 'php').replace(/\$/g, '$$$$'));
		}

		env.element.innerHTML = env.highlightedCode;
	});

	// Wrap tokens in classes that are missing them
	Prism.hooks.add('wrap', function(env) {
		if (env.language === 'php' && env.type === 'markup') {
			env.content = env.content.replace(/(\{\{\{PHP[0-9]+\}\}\})/g, "<span class=\"token php\">$1</span>");
		}
	});

	// Add the rules before all others
	Prism.languages.insertBefore('php', 'comment', {
		'markup': {
			pattern: /<[^?]\/?(.*?)>/,
			inside: Prism.languages.markup
		},
		'php': /\{\{\{PHP[0-9]+\}\}\}/
	});
}
;
Prism.languages.python= {
	'comment': {
		pattern: /(^|[^\\])#.*/,
		lookbehind: true
	},
	'string': /"""[\s\S]+?"""|'''[\s\S]+?'''|("|')(?:\\?.)*?\1/,
	'function' : {
		pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\()/g,
		lookbehind: true
	},
	'class-name': {
		pattern: /(\bclass\s+)[a-z0-9_]+/i,
		lookbehind: true
	},
	'keyword' : /\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/,
	'boolean' : /\b(?:True|False)\b/,
	'number' : /\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,
	'operator' : /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,
	'punctuation' : /[{}[\];(),.:]/
};

/**
 * Original by Samuel Flores
 *
 * Adds the following new token classes:
 * 		constant, builtin, variable, symbol, regex
 */
(function(Prism) {
	Prism.languages.ruby = Prism.languages.extend('clike', {
		'comment': /#(?!\{[^\r\n]*?\}).*/,
		'keyword': /\b(alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\b/
	});

	var interpolation = {
		pattern: /#\{[^}]+\}/,
		inside: {
			'delimiter': {
				pattern: /^#\{|\}$/,
				alias: 'tag'
			},
			rest: Prism.util.clone(Prism.languages.ruby)
		}
	};

	Prism.languages.insertBefore('ruby', 'keyword', {
		'regex': [
			{
				pattern: /%r([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1[gim]{0,3}/,
				inside: {
					'interpolation': interpolation
				}
			},
			{
				pattern: /%r\((?:[^()\\]|\\[\s\S])*\)[gim]{0,3}/,
				inside: {
					'interpolation': interpolation
				}
			},
			{
				// Here we need to specifically allow interpolation
				pattern: /%r\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}[gim]{0,3}/,
				inside: {
					'interpolation': interpolation
				}
			},
			{
				pattern: /%r\[(?:[^\[\]\\]|\\[\s\S])*\][gim]{0,3}/,
				inside: {
					'interpolation': interpolation
				}
			},
			{
				pattern: /%r<(?:[^<>\\]|\\[\s\S])*>[gim]{0,3}/,
				inside: {
					'interpolation': interpolation
				}
			},
			{
				pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/,
				lookbehind: true
			}
		],
		'variable': /[@$]+[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/,
		'symbol': /:[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/
	});

	Prism.languages.insertBefore('ruby', 'number', {
		'builtin': /\b(Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|File|Fixnum|Fload|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/,
		'constant': /\b[A-Z][a-zA-Z_0-9]*(?:[?!]|\b)/
	});

	Prism.languages.ruby.string = [
		{
			pattern: /%[qQiIwWxs]?([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1/,
			inside: {
				'interpolation': interpolation
			}
		},
		{
			pattern: /%[qQiIwWxs]?\((?:[^()\\]|\\[\s\S])*\)/,
			inside: {
				'interpolation': interpolation
			}
		},
		{
			// Here we need to specifically allow interpolation
			pattern: /%[qQiIwWxs]?\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/,
			inside: {
				'interpolation': interpolation
			}
		},
		{
			pattern: /%[qQiIwWxs]?\[(?:[^\[\]\\]|\\[\s\S])*\]/,
			inside: {
				'interpolation': interpolation
			}
		},
		{
			pattern: /%[qQiIwWxs]?<(?:[^<>\\]|\\[\s\S])*>/,
			inside: {
				'interpolation': interpolation
			}
		},
		{
			pattern: /("|')(#\{[^}]+\}|\\(?:\r?\n|\r)|\\?.)*?\1/,
			inside: {
				'interpolation': interpolation
			}
		}
	];
}(Prism));

// ------------------ End wrap
return Prism;
});

// Included from: js/tinymce/plugins/codesample/classes/Utils.js

/**
 * Utils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Various utility functions.
 *
 * @class tinymce.codesample.Utils
 * @private
 */
define("tinymce/codesampleplugin/Utils", [
], function() {
	function isCodeSample(elm) {
		return elm && elm.nodeName == 'PRE' && elm.className.indexOf('language-') !== -1;
	}

	function trimArg(predicateFn) {
		return function(arg1, arg2) {
			return predicateFn(arg2);
		};
	}

	return {
		isCodeSample: isCodeSample,
		trimArg: trimArg
	};
});

// Included from: js/tinymce/plugins/codesample/classes/Dialog.js

/**
 * Dialog.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Contains all dialog logic.
 *
 * @class tinymce.codesample.Dialog
 * @private
 */
define("tinymce/codesampleplugin/Dialog", [
	"tinymce/dom/DOMUtils",
	"tinymce/codesampleplugin/Utils",
	"tinymce/codesampleplugin/Prism"
], function(DOMUtils, Utils, Prism) {
	var DOM = DOMUtils.DOM;

	function getLanguages(editor) {
		var defaultLanguages = [
			{text: 'HTML/XML', value: 'markup'},
			{text: 'JavaScript', value: 'javascript'},
			{text: 'CSS', value: 'css'},
			{text: 'PHP', value: 'php'},
			{text: 'Ruby', value: 'ruby'},
			{text: 'Python', value: 'python'},
			{text: 'Java', value: 'java'},
			{text: 'C', value: 'c'},
			{text: 'C#', value: 'csharp'},
			{text: 'C++', value: 'cpp'}
		];

		var customLanguages = editor.settings.codesample_languages;
		return customLanguages ? customLanguages : defaultLanguages;
	}

	function insertCodeSample(editor, language, code) {
		editor.undoManager.transact(function() {
			var node = getSelectedCodeSample(editor);

			code = DOM.encode(code);

			if (node) {
				editor.dom.setAttrib(node, 'class', 'language-' + language);
				node.innerHTML = code;
				Prism.highlightElement(node);
				editor.selection.select(node);
			} else {
				editor.insertContent('<pre id="__new" class="language-' + language + '">' + code + '</pre>');
				editor.selection.select(editor.$('#__new').removeAttr('id')[0]);
			}
		});
	}

	function getSelectedCodeSample(editor) {
		var node = editor.selection.getNode();

		if (Utils.isCodeSample(node)) {
			return node;
		}

		return null;
	}

	function getCurrentCode(editor) {
		var node = getSelectedCodeSample(editor);

		if (node) {
			return node.textContent;
		}

		return '';
	}

	function getCurrentLanguage(editor) {
		var matches, node = getSelectedCodeSample(editor);

		if (node) {
			matches = node.className.match(/language-(\w+)/);
			return matches ? matches[1] : '';
		}

		return '';
	}

	return {
		open: function(editor) {
			editor.windowManager.open({
				title: "Insert/Edit code sample",
				minWidth: Math.min(DOM.getViewPort().w, editor.getParam('codesample_dialog_width', 800)),
				minHeight: Math.min(DOM.getViewPort().h, editor.getParam('codesample_dialog_height', 650)),
				layout: 'flex',
				direction: 'column',
				align: 'stretch',
				body: [
					{
						type: 'listbox',
						name: 'language',
						label: 'Language',
						maxWidth: 200,
						value: getCurrentLanguage(editor),
						values: getLanguages(editor)
					},

					{
						type: 'textbox',
						name: 'code',
						multiline: true,
						spellcheck: false,
						ariaLabel: 'Code view',
						flex: 1,
						style: 'direction: ltr; text-align: left',
						classes: 'monospace',
						value: getCurrentCode(editor),
						autofocus: true
					}
				],
				onSubmit: function(e) {
					insertCodeSample(editor, e.data.language, e.data.code);
				}
			});
		}
	};
});

// Included from: js/tinymce/plugins/codesample/classes/Plugin.js

/**
 * Plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Main plugin logic.
 *
 * @class tinymce.codesample.Plugin
 * @private
 */
define("tinymce/codesampleplugin/Plugin", [
	"tinymce/Env",
	"tinymce/PluginManager",
	"tinymce/codesampleplugin/Prism",
	"tinymce/codesampleplugin/Dialog",
	"tinymce/codesampleplugin/Utils"
], function(Env, PluginManager, Prism, Dialog, Utils) {
	var addedInlineCss, trimArg = Utils.trimArg;

	PluginManager.add('codesample', function(editor, pluginUrl) {
		var $ = editor.$, addedCss;

		if (!Env.ceFalse) {
			return;
		}

		// Todo: use a proper css loader here
		function loadCss() {
			var linkElm, contentCss = editor.settings.codesample_content_css;

			if (editor.inline && addedInlineCss) {
				return;
			}

			if (!editor.inline && addedCss) {
				return;
			}

			if (editor.inline) {
				addedInlineCss = true;
			} else {
				addedCss = true;
			}

			if (contentCss !== false) {
				linkElm = editor.dom.create('link', {
					rel: 'stylesheet',
					href: contentCss ? contentCss : pluginUrl + '/css/prism.css'
				});

				editor.getDoc().getElementsByTagName('head')[0].appendChild(linkElm);
			}
		}

		editor.on('PreProcess', function(e) {
			$('pre[contenteditable=false]', e.node).
				filter(trimArg(Utils.isCodeSample)).
				each(function(idx, elm) {
					var $elm = $(elm), code = elm.textContent;

					$elm.attr('class', $.trim($elm.attr('class')));
					$elm.removeAttr('contentEditable');

					$elm.empty().append($('<code></code>').each(function() {
						// Needs to be textContent since innerText produces BR:s
						this.textContent = code;
					}));
				});
		});

		editor.on('SetContent', function() {
			var unprocessedCodeSamples = $('pre').filter(trimArg(Utils.isCodeSample)).filter(function(idx, elm) {
				return elm.contentEditable !== "false";
			});

			if (unprocessedCodeSamples.length) {
				editor.undoManager.transact(function() {
					unprocessedCodeSamples.each(function(idx, elm) {
						$(elm).find('br').each(function(idx, elm) {
							elm.parentNode.replaceChild(editor.getDoc().createTextNode('\n'), elm);
						});

						elm.contentEditable = false;
						elm.innerHTML = editor.dom.encode(elm.textContent);
						Prism.highlightElement(elm);
						elm.className = $.trim(elm.className);
					});
				});
			}
		});

		editor.addCommand('codesample', function() {
			var node = editor.selection.getNode();
			if (editor.selection.isCollapsed() || Utils.isCodeSample(node)) {
				Dialog.open(editor);
			} else {
				editor.formatter.toggle('code');
			}
		});

		editor.addButton('codesample', {
			cmd: 'codesample',
			title: 'Insert/Edit code sample'
		});

		editor.on('init', loadCss);
	});
});

expose(["tinymce/codesampleplugin/Prism","tinymce/codesampleplugin/Utils","tinymce/codesampleplugin/Dialog","tinymce/codesampleplugin/Plugin"]);
})(window);
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('contextmenu', function(editor) {
	var menu, visibleState, contextmenuNeverUseNative = editor.settings.contextmenu_never_use_native;

	var isNativeOverrideKeyEvent = function (e) {
		return e.ctrlKey && !contextmenuNeverUseNative;
	};

	var isMacWebKit = function () {
		return tinymce.Env.mac && tinymce.Env.webkit;
	};

	var isContextMenuVisible = function () {
		return visibleState === true;
	};

	/**
	 * This takes care of a os x native issue where it expands the selection
	 * to the word at the caret position to do "lookups". Since we are overriding
	 * the context menu we also need to override this expanding so the behavior becomes
	 * normalized. Firefox on os x doesn't expand to the word when using the context menu.
	 */
	editor.on('mousedown', function (e) {
		if (isMacWebKit() && e.button === 2 && !isNativeOverrideKeyEvent(e)) {
			if (editor.selection.isCollapsed()) {
				editor.once('contextmenu', function (e) {
					editor.selection.placeCaretAt(e.clientX, e.clientY);
				});
			}
		}
	});

	editor.on('contextmenu', function(e) {
		var contextmenu;

		if (isNativeOverrideKeyEvent(e)) {
			return;
		}

		e.preventDefault();
		contextmenu = editor.settings.contextmenu || 'link openlink image inserttable | cell row column deletetable';

		// Render menu
		if (!menu) {
			var items = [];

			tinymce.each(contextmenu.split(/[ ,]/), function(name) {
				var item = editor.menuItems[name];

				if (name == '|') {
					item = {text: name};
				}

				if (item) {
					item.shortcut = ''; // Hide shortcuts
					items.push(item);
				}
			});

			for (var i = 0; i < items.length; i++) {
				if (items[i].text == '|') {
					if (i === 0 || i == items.length - 1) {
						items.splice(i, 1);
					}
				}
			}

			menu = new tinymce.ui.Menu({
				items: items,
				context: 'contextmenu',
				classes: 'contextmenu'
			}).renderTo();

			menu.on('hide', function (e) {
				if (e.control === this) {
					visibleState = false;
				}
			});

			editor.on('remove', function() {
				menu.remove();
				menu = null;
			});

		} else {
			menu.show();
		}

		// Position menu
		var pos = {x: e.pageX, y: e.pageY};

		if (!editor.inline) {
			pos = tinymce.DOM.getPos(editor.getContentAreaContainer());
			pos.x += e.clientX;
			pos.y += e.clientY;
		}

		menu.moveTo(pos.x, pos.y);
		visibleState = true;
	});

	return {
		isContextMenuVisible: isContextMenuVisible
	};
});
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('colorpicker', function(editor) {
	function colorPickerCallback(callback, value) {
		function setColor(value) {
			var color = new tinymce.util.Color(value), rgb = color.toRgb();

			win.fromJSON({
				r: rgb.r,
				g: rgb.g,
				b: rgb.b,
				hex: color.toHex().substr(1)
			});

			showPreview(color.toHex());
		}

		function showPreview(hexColor) {
			win.find('#preview')[0].getEl().style.background = hexColor;
		}

		var win = editor.windowManager.open({
			title: 'Color',
			items: {
				type: 'container',
				layout: 'flex',
				direction: 'row',
				align: 'stretch',
				padding: 5,
				spacing: 10,
				items: [
					{
						type: 'colorpicker',
						value: value,
						onchange: function() {
							var rgb = this.rgb();

							if (win) {
								win.find('#r').value(rgb.r);
								win.find('#g').value(rgb.g);
								win.find('#b').value(rgb.b);
								win.find('#hex').value(this.value().substr(1));
								showPreview(this.value());
							}
						}
					},
					{
						type: 'form',
						padding: 0,
						labelGap: 5,
						defaults: {
							type: 'textbox',
							size: 7,
							value: '0',
							flex: 1,
							spellcheck: false,
							onchange: function() {
								var colorPickerCtrl = win.find('colorpicker')[0];
								var name, value;

								name = this.name();
								value = this.value();

								if (name == "hex") {
									value = '#' + value;
									setColor(value);
									colorPickerCtrl.value(value);
									return;
								}

								value = {
									r: win.find('#r').value(),
									g: win.find('#g').value(),
									b: win.find('#b').value()
								};

								colorPickerCtrl.value(value);
								setColor(value);
							}
						},
						items: [
							{name: 'r', label: 'R', autofocus: 1},
							{name: 'g', label: 'G'},
							{name: 'b', label: 'B'},
							{name: 'hex', label: '#', value: '000000'},
							{name: 'preview', type: 'container', border: 1}
						]
					}
				]
			},
			onSubmit: function() {
				callback('#' + this.toJSON().hex);
			}
		});

		setColor(value);
	}

	if (!editor.settings.color_picker_callback) {
		editor.settings.color_picker_callback = colorPickerCallback;
	}
});
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('directionality', function(editor) {
	function setDir(dir) {
		var dom = editor.dom, curDir, blocks = editor.selection.getSelectedBlocks();

		if (blocks.length) {
			curDir = dom.getAttrib(blocks[0], "dir");

			tinymce.each(blocks, function(block) {
				// Add dir to block if the parent block doesn't already have that dir
				if (!dom.getParent(block.parentNode, "*[dir='" + dir + "']", dom.getRoot())) {
					if (curDir != dir) {
						dom.setAttrib(block, "dir", dir);
					} else {
						dom.setAttrib(block, "dir", null);
					}
				}
			});

			editor.nodeChanged();
		}
	}

	function generateSelector(dir) {
		var selector = [];

		tinymce.each('h1 h2 h3 h4 h5 h6 div p'.split(' '), function(name) {
			selector.push(name + '[dir=' + dir + ']');
		});

		return selector.join(',');
	}

	editor.addCommand('mceDirectionLTR', function() {
		setDir("ltr");
	});

	editor.addCommand('mceDirectionRTL', function() {
		setDir("rtl");
	});

	editor.addButton('ltr', {
		title: 'Left to right',
		cmd: 'mceDirectionLTR',
		stateSelector: generateSelector('ltr')
	});

	editor.addButton('rtl', {
		title: 'Right to left',
		cmd: 'mceDirectionRTL',
		stateSelector: generateSelector('rtl')
	});
});
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('emoticons', function(editor, url) {
	var emoticons = [
		["cool", "cry", "embarassed", "foot-in-mouth"],
		["frown", "innocent", "kiss", "laughing"],
		["money-mouth", "sealed", "smile", "surprised"],
		["tongue-out", "undecided", "wink", "yell"]
	];

	function getHtml() {
		var emoticonsHtml;

		emoticonsHtml = '<table role="list" class="mce-grid">';

		tinymce.each(emoticons, function(row) {
			emoticonsHtml += '<tr>';

			tinymce.each(row, function(icon) {
				var emoticonUrl = url + '/img/smiley-' + icon + '.gif';

				emoticonsHtml += '<td><a href="#" data-mce-url="' + emoticonUrl + '" data-mce-alt="' + icon + '" tabindex="-1" ' +
					'role="option" aria-label="' + icon + '"><img src="' +
					emoticonUrl + '" style="width: 18px; height: 18px" role="presentation" /></a></td>';
			});

			emoticonsHtml += '</tr>';
		});

		emoticonsHtml += '</table>';

		return emoticonsHtml;
	}

	editor.addButton('emoticons', {
		type: 'panelbutton',
		panel: {
			role: 'application',
			autohide: true,
			html: getHtml,
			onclick: function(e) {
				var linkElm = editor.dom.getParent(e.target, 'a');

				if (linkElm) {
					editor.insertContent(
						'<img src="' + linkElm.getAttribute('data-mce-url') + '" alt="' + linkElm.getAttribute('data-mce-alt') + '" />'
					);

					this.hide();
				}
			}
		},
		tooltip: 'Emoticons'
	});
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('fullpage', function(editor) {
	var each = tinymce.each, Node = tinymce.html.Node;
	var head, foot;

	function showDialog() {
		var data = htmlToData();

		editor.windowManager.open({
			title: 'Document properties',
			data: data,
			defaults: {type: 'textbox', size: 40},
			body: [
				{name: 'title', label: 'Title'},
				{name: 'keywords', label: 'Keywords'},
				{name: 'description', label: 'Description'},
				{name: 'robots', label: 'Robots'},
				{name: 'author', label: 'Author'},
				{name: 'docencoding', label: 'Encoding'}
			],
			onSubmit: function(e) {
				dataToHtml(tinymce.extend(data, e.data));
			}
		});
	}

	function htmlToData() {
		var headerFragment = parseHeader(), data = {}, elm, matches;

		function getAttr(elm, name) {
			var value = elm.attr(name);

			return value || '';
		}

		// Default some values
		data.fontface = editor.getParam("fullpage_default_fontface", "");
		data.fontsize = editor.getParam("fullpage_default_fontsize", "");

		// Parse XML PI
		elm = headerFragment.firstChild;
		if (elm.type == 7) {
			data.xml_pi = true;
			matches = /encoding="([^"]+)"/.exec(elm.value);
			if (matches) {
				data.docencoding = matches[1];
			}
		}

		// Parse doctype
		elm = headerFragment.getAll('#doctype')[0];
		if (elm) {
			data.doctype = '<!DOCTYPE' + elm.value + ">";
		}

		// Parse title element
		elm = headerFragment.getAll('title')[0];
		if (elm && elm.firstChild) {
			data.title = elm.firstChild.value;
		}

		// Parse meta elements
		each(headerFragment.getAll('meta'), function(meta) {
			var name = meta.attr('name'), httpEquiv = meta.attr('http-equiv'), matches;

			if (name) {
				data[name.toLowerCase()] = meta.attr('content');
			} else if (httpEquiv == "Content-Type") {
				matches = /charset\s*=\s*(.*)\s*/gi.exec(meta.attr('content'));

				if (matches) {
					data.docencoding = matches[1];
				}
			}
		});

		// Parse html attribs
		elm = headerFragment.getAll('html')[0];
		if (elm) {
			data.langcode = getAttr(elm, 'lang') || getAttr(elm, 'xml:lang');
		}

		// Parse stylesheets
		data.stylesheets = [];
		tinymce.each(headerFragment.getAll('link'), function(link) {
			if (link.attr('rel') == 'stylesheet') {
				data.stylesheets.push(link.attr('href'));
			}
		});

		// Parse body parts
		elm = headerFragment.getAll('body')[0];
		if (elm) {
			data.langdir = getAttr(elm, 'dir');
			data.style = getAttr(elm, 'style');
			data.visited_color = getAttr(elm, 'vlink');
			data.link_color = getAttr(elm, 'link');
			data.active_color = getAttr(elm, 'alink');
		}

		return data;
	}

	function dataToHtml(data) {
		var headerFragment, headElement, html, elm, value, dom = editor.dom;

		function setAttr(elm, name, value) {
			elm.attr(name, value ? value : undefined);
		}

		function addHeadNode(node) {
			if (headElement.firstChild) {
				headElement.insert(node, headElement.firstChild);
			} else {
				headElement.append(node);
			}
		}

		headerFragment = parseHeader();
		headElement = headerFragment.getAll('head')[0];
		if (!headElement) {
			elm = headerFragment.getAll('html')[0];
			headElement = new Node('head', 1);

			if (elm.firstChild) {
				elm.insert(headElement, elm.firstChild, true);
			} else {
				elm.append(headElement);
			}
		}

		// Add/update/remove XML-PI
		elm = headerFragment.firstChild;
		if (data.xml_pi) {
			value = 'version="1.0"';

			if (data.docencoding) {
				value += ' encoding="' + data.docencoding + '"';
			}

			if (elm.type != 7) {
				elm = new Node('xml', 7);
				headerFragment.insert(elm, headerFragment.firstChild, true);
			}

			elm.value = value;
		} else if (elm && elm.type == 7) {
			elm.remove();
		}

		// Add/update/remove doctype
		elm = headerFragment.getAll('#doctype')[0];
		if (data.doctype) {
			if (!elm) {
				elm = new Node('#doctype', 10);

				if (data.xml_pi) {
					headerFragment.insert(elm, headerFragment.firstChild);
				} else {
					addHeadNode(elm);
				}
			}

			elm.value = data.doctype.substring(9, data.doctype.length - 1);
		} else if (elm) {
			elm.remove();
		}

		// Add meta encoding
		elm = null;
		each(headerFragment.getAll('meta'), function(meta) {
			if (meta.attr('http-equiv') == 'Content-Type') {
				elm = meta;
			}
		});

		if (data.docencoding) {
			if (!elm) {
				elm = new Node('meta', 1);
				elm.attr('http-equiv', 'Content-Type');
				elm.shortEnded = true;
				addHeadNode(elm);
			}

			elm.attr('content', 'text/html; charset=' + data.docencoding);
		} else if (elm) {
			elm.remove();
		}

		// Add/update/remove title
		elm = headerFragment.getAll('title')[0];
		if (data.title) {
			if (!elm) {
				elm = new Node('title', 1);
				addHeadNode(elm);
			} else {
				elm.empty();
			}

			elm.append(new Node('#text', 3)).value = data.title;
		} else if (elm) {
			elm.remove();
		}

		// Add/update/remove meta
		each('keywords,description,author,copyright,robots'.split(','), function(name) {
			var nodes = headerFragment.getAll('meta'), i, meta, value = data[name];

			for (i = 0; i < nodes.length; i++) {
				meta = nodes[i];

				if (meta.attr('name') == name) {
					if (value) {
						meta.attr('content', value);
					} else {
						meta.remove();
					}

					return;
				}
			}

			if (value) {
				elm = new Node('meta', 1);
				elm.attr('name', name);
				elm.attr('content', value);
				elm.shortEnded = true;

				addHeadNode(elm);
			}
		});

		var currentStyleSheetsMap = {};
		tinymce.each(headerFragment.getAll('link'), function(stylesheet) {
			if (stylesheet.attr('rel') == 'stylesheet') {
				currentStyleSheetsMap[stylesheet.attr('href')] = stylesheet;
			}
		});

		// Add new
		tinymce.each(data.stylesheets, function(stylesheet) {
			if (!currentStyleSheetsMap[stylesheet]) {
				elm = new Node('link', 1);
				elm.attr({
					rel: 'stylesheet',
					text: 'text/css',
					href: stylesheet
				});
				elm.shortEnded = true;
				addHeadNode(elm);
			}

			delete currentStyleSheetsMap[stylesheet];
		});

		// Delete old
		tinymce.each(currentStyleSheetsMap, function(stylesheet) {
			stylesheet.remove();
		});

		// Update body attributes
		elm = headerFragment.getAll('body')[0];
		if (elm) {
			setAttr(elm, 'dir', data.langdir);
			setAttr(elm, 'style', data.style);
			setAttr(elm, 'vlink', data.visited_color);
			setAttr(elm, 'link', data.link_color);
			setAttr(elm, 'alink', data.active_color);

			// Update iframe body as well
			dom.setAttribs(editor.getBody(), {
				style: data.style,
				dir: data.dir,
				vLink: data.visited_color,
				link: data.link_color,
				aLink: data.active_color
			});
		}

		// Set html attributes
		elm = headerFragment.getAll('html')[0];
		if (elm) {
			setAttr(elm, 'lang', data.langcode);
			setAttr(elm, 'xml:lang', data.langcode);
		}

		// No need for a head element
		if (!headElement.firstChild) {
			headElement.remove();
		}

		// Serialize header fragment and crop away body part
		html = new tinymce.html.Serializer({
			validate: false,
			indent: true,
			apply_source_formatting: true,
			indent_before: 'head,html,body,meta,title,script,link,style',
			indent_after: 'head,html,body,meta,title,script,link,style'
		}).serialize(headerFragment);

		head = html.substring(0, html.indexOf('</body>'));
	}

	function parseHeader() {
		// Parse the contents with a DOM parser
		return new tinymce.html.DomParser({
			validate: false,
			root_name: '#document'
		}).parse(head);
	}

	function setContent(evt) {
		var startPos, endPos, content = evt.content, headerFragment, styles = '', dom = editor.dom, elm;

		if (evt.selection) {
			return;
		}

		function low(s) {
			return s.replace(/<\/?[A-Z]+/g, function(a) {
				return a.toLowerCase();
			});
		}

		// Ignore raw updated if we already have a head, this will fix issues with undo/redo keeping the head/foot separate
		if (evt.format == 'raw' && head) {
			return;
		}

		if (evt.source_view && editor.getParam('fullpage_hide_in_source_view')) {
			return;
		}

		// Fixed so new document/setContent('') doesn't remove existing header/footer except when it's in source code view
		if (content.length === 0 && !evt.source_view) {
			content = tinymce.trim(head) + '\n' + tinymce.trim(content) + '\n' + tinymce.trim(foot);
		}

		// Parse out head, body and footer
		content = content.replace(/<(\/?)BODY/gi, '<$1body');
		startPos = content.indexOf('<body');

		if (startPos != -1) {
			startPos = content.indexOf('>', startPos);
			head = low(content.substring(0, startPos + 1));

			endPos = content.indexOf('</body', startPos);
			if (endPos == -1) {
				endPos = content.length;
			}

			evt.content = content.substring(startPos + 1, endPos);
			foot = low(content.substring(endPos));
		} else {
			head = getDefaultHeader();
			foot = '\n</body>\n</html>';
		}

		// Parse header and update iframe
		headerFragment = parseHeader();
		each(headerFragment.getAll('style'), function(node) {
			if (node.firstChild) {
				styles += node.firstChild.value;
			}
		});

		elm = headerFragment.getAll('body')[0];
		if (elm) {
			dom.setAttribs(editor.getBody(), {
				style: elm.attr('style') || '',
				dir: elm.attr('dir') || '',
				vLink: elm.attr('vlink') || '',
				link: elm.attr('link') || '',
				aLink: elm.attr('alink') || ''
			});
		}

		dom.remove('fullpage_styles');

		var headElm = editor.getDoc().getElementsByTagName('head')[0];

		if (styles) {
			dom.add(headElm, 'style', {
				id: 'fullpage_styles'
			}, styles);

			// Needed for IE 6/7
			elm = dom.get('fullpage_styles');
			if (elm.styleSheet) {
				elm.styleSheet.cssText = styles;
			}
		}

		var currentStyleSheetsMap = {};
		tinymce.each(headElm.getElementsByTagName('link'), function(stylesheet) {
			if (stylesheet.rel == 'stylesheet' && stylesheet.getAttribute('data-mce-fullpage')) {
				currentStyleSheetsMap[stylesheet.href] = stylesheet;
			}
		});

		// Add new
		tinymce.each(headerFragment.getAll('link'), function(stylesheet) {
			var href = stylesheet.attr('href');
			if (!href) {
				return true;
			}

			if (!currentStyleSheetsMap[href] && stylesheet.attr('rel') == 'stylesheet') {
				dom.add(headElm, 'link', {
					rel: 'stylesheet',
					text: 'text/css',
					href: href,
					'data-mce-fullpage': '1'
				});
			}

			delete currentStyleSheetsMap[href];
		});

		// Delete old
		tinymce.each(currentStyleSheetsMap, function(stylesheet) {
			stylesheet.parentNode.removeChild(stylesheet);
		});
	}

	function getDefaultHeader() {
		var header = '', value, styles = '';

		if (editor.getParam('fullpage_default_xml_pi')) {
			header += '<?xml version="1.0" encoding="' + editor.getParam('fullpage_default_encoding', 'ISO-8859-1') + '" ?>\n';
		}

		header += editor.getParam('fullpage_default_doctype', '<!DOCTYPE html>');
		header += '\n<html>\n<head>\n';

		if ((value = editor.getParam('fullpage_default_title'))) {
			header += '<title>' + value + '</title>\n';
		}

		if ((value = editor.getParam('fullpage_default_encoding'))) {
			header += '<meta http-equiv="Content-Type" content="text/html; charset=' + value + '" />\n';
		}

		if ((value = editor.getParam('fullpage_default_font_family'))) {
			styles += 'font-family: ' + value + ';';
		}

		if ((value = editor.getParam('fullpage_default_font_size'))) {
			styles += 'font-size: ' + value + ';';
		}

		if ((value = editor.getParam('fullpage_default_text_color'))) {
			styles += 'color: ' + value + ';';
		}

		header += '</head>\n<body' + (styles ? ' style="' + styles + '"' : '') + '>\n';

		return header;
	}

	function getContent(evt) {
		if (!evt.selection && (!evt.source_view || !editor.getParam('fullpage_hide_in_source_view'))) {
			evt.content = tinymce.trim(head) + '\n' + tinymce.trim(evt.content) + '\n' + tinymce.trim(foot);
		}
	}

	editor.addCommand('mceFullPageProperties', showDialog);

	editor.addButton('fullpage', {
		title: 'Document properties',
		cmd: 'mceFullPageProperties'
	});

	editor.addMenuItem('fullpage', {
		text: 'Document properties',
		cmd: 'mceFullPageProperties',
		context: 'file'
	});

	editor.on('BeforeSetContent', setContent);
	editor.on('GetContent', getContent);
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('fullscreen', function(editor) {
	var fullscreenState = false, DOM = tinymce.DOM, iframeWidth, iframeHeight, resizeHandler;
	var containerWidth, containerHeight, scrollPos;

	if (editor.settings.inline) {
		return;
	}

	function getWindowSize() {
		var w, h, win = window, doc = document;
		var body = doc.body;

		// Old IE
		if (body.offsetWidth) {
			w = body.offsetWidth;
			h = body.offsetHeight;
		}

		// Modern browsers
		if (win.innerWidth && win.innerHeight) {
			w = win.innerWidth;
			h = win.innerHeight;
		}

		return {w: w, h: h};
	}

	function getScrollPos() {
		var vp = tinymce.DOM.getViewPort();

		return {
			x: vp.x,
			y: vp.y
		};
	}

	function setScrollPos(pos) {
		scrollTo(pos.x, pos.y);
	}

	function toggleFullscreen() {
		var body = document.body, documentElement = document.documentElement, editorContainerStyle;
		var editorContainer, iframe, iframeStyle;

		function resize() {
			DOM.setStyle(iframe, 'height', getWindowSize().h - (editorContainer.clientHeight - iframe.clientHeight));
		}

		fullscreenState = !fullscreenState;

		editorContainer = editor.getContainer();
		editorContainerStyle = editorContainer.style;
		iframe = editor.getContentAreaContainer().firstChild;
		iframeStyle = iframe.style;

		if (fullscreenState) {
			scrollPos = getScrollPos();
			iframeWidth = iframeStyle.width;
			iframeHeight = iframeStyle.height;
			iframeStyle.width = iframeStyle.height = '100%';
			containerWidth = editorContainerStyle.width;
			containerHeight = editorContainerStyle.height;
			editorContainerStyle.width = editorContainerStyle.height = '';

			DOM.addClass(body, 'mce-fullscreen');
			DOM.addClass(documentElement, 'mce-fullscreen');
			DOM.addClass(editorContainer, 'mce-fullscreen');

			DOM.bind(window, 'resize', resize);
			resize();
			resizeHandler = resize;
		} else {
			iframeStyle.width = iframeWidth;
			iframeStyle.height = iframeHeight;

			if (containerWidth) {
				editorContainerStyle.width = containerWidth;
			}

			if (containerHeight) {
				editorContainerStyle.height = containerHeight;
			}

			DOM.removeClass(body, 'mce-fullscreen');
			DOM.removeClass(documentElement, 'mce-fullscreen');
			DOM.removeClass(editorContainer, 'mce-fullscreen');
			DOM.unbind(window, 'resize', resizeHandler);
			setScrollPos(scrollPos);
		}

		editor.fire('FullscreenStateChanged', {state: fullscreenState});
	}

	editor.on('init', function() {
		editor.addShortcut('Ctrl+Shift+F', '', toggleFullscreen);
	});

	editor.on('remove', function() {
		if (resizeHandler) {
			DOM.unbind(window, 'resize', resizeHandler);
		}
	});

	editor.addCommand('mceFullScreen', toggleFullscreen);

	editor.addMenuItem('fullscreen', {
		text: 'Fullscreen',
		shortcut: 'Ctrl+Shift+F',
		selectable: true,
		onClick: function() {
			toggleFullscreen();
			editor.focus();
		},
		onPostRender: function() {
			var self = this;

			editor.on('FullscreenStateChanged', function(e) {
				self.active(e.state);
			});
		},
		context: 'view'
	});

	editor.addButton('fullscreen', {
		tooltip: 'Fullscreen',
		shortcut: 'Ctrl+Shift+F',
		onClick: toggleFullscreen,
		onPostRender: function() {
			var self = this;

			editor.on('FullscreenStateChanged', function(e) {
				self.active(e.state);
			});
		}
	});

	return {
		isFullscreen: function() {
			return fullscreenState;
		}
	};
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('hr', function(editor) {
	editor.addCommand('InsertHorizontalRule', function() {
		editor.execCommand('mceInsertContent', false, '<hr />');
	});

	editor.addButton('hr', {
		icon: 'hr',
		tooltip: 'Horizontal line',
		cmd: 'InsertHorizontalRule'
	});

	editor.addMenuItem('hr', {
		icon: 'hr',
		text: 'Horizontal line',
		cmd: 'InsertHorizontalRule',
		context: 'insert'
	});
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('image', function(editor) {
	function getImageSize(url, callback) {
		var img = document.createElement('img');

		function done(width, height) {
			if (img.parentNode) {
				img.parentNode.removeChild(img);
			}

			callback({width: width, height: height});
		}

		img.onload = function() {
			done(Math.max(img.width, img.clientWidth), Math.max(img.height, img.clientHeight));
		};

		img.onerror = function() {
			done();
		};

		var style = img.style;
		style.visibility = 'hidden';
		style.position = 'fixed';
		style.bottom = style.left = 0;
		style.width = style.height = 'auto';

		document.body.appendChild(img);
		img.src = url;
	}

	function buildListItems(inputList, itemCallback, startItems) {
		function appendItems(values, output) {
			output = output || [];

			tinymce.each(values, function(item) {
				var menuItem = {text: item.text || item.title};

				if (item.menu) {
					menuItem.menu = appendItems(item.menu);
				} else {
					menuItem.value = item.value;
					itemCallback(menuItem);
				}

				output.push(menuItem);
			});

			return output;
		}

		return appendItems(inputList, startItems || []);
	}

	function createImageList(callback) {
		return function() {
			var imageList = editor.settings.image_list;

			if (typeof imageList == "string") {
				tinymce.util.XHR.send({
					url: imageList,
					success: function(text) {
						callback(tinymce.util.JSON.parse(text));
					}
				});
			} else if (typeof imageList == "function") {
				imageList(callback);
			} else {
				callback(imageList);
			}
		};
	}

	function showDialog(imageList) {
		var win, data = {}, dom = editor.dom, imgElm, figureElm;
		var width, height, imageListCtrl, classListCtrl, imageDimensions = editor.settings.image_dimensions !== false;

		function recalcSize() {
			var widthCtrl, heightCtrl, newWidth, newHeight;

			widthCtrl = win.find('#width')[0];
			heightCtrl = win.find('#height')[0];

			if (!widthCtrl || !heightCtrl) {
				return;
			}

			newWidth = widthCtrl.value();
			newHeight = heightCtrl.value();

			if (win.find('#constrain')[0].checked() && width && height && newWidth && newHeight) {
				if (width != newWidth) {
					newHeight = Math.round((newWidth / width) * newHeight);

					if (!isNaN(newHeight)) {
						heightCtrl.value(newHeight);
					}
				} else {
					newWidth = Math.round((newHeight / height) * newWidth);

					if (!isNaN(newWidth)) {
						widthCtrl.value(newWidth);
					}
				}
			}

			width = newWidth;
			height = newHeight;
		}

		function onSubmitForm() {
			var figureElm, oldImg;

			function waitLoad(imgElm) {
				function selectImage() {
					imgElm.onload = imgElm.onerror = null;

					if (editor.selection) {
						editor.selection.select(imgElm);
						editor.nodeChanged();
					}
				}

				imgElm.onload = function() {
					if (!data.width && !data.height && imageDimensions) {
						dom.setAttribs(imgElm, {
							width: imgElm.clientWidth,
							height: imgElm.clientHeight
						});
					}

					selectImage();
				};

				imgElm.onerror = selectImage;
			}

			updateStyle();
			recalcSize();

			data = tinymce.extend(data, win.toJSON());

			if (!data.alt) {
				data.alt = '';
			}

			if (!data.title) {
				data.title = '';
			}

			if (data.width === '') {
				data.width = null;
			}

			if (data.height === '') {
				data.height = null;
			}

			if (!data.style) {
				data.style = null;
			}

			// Setup new data excluding style properties
			/*eslint dot-notation: 0*/
			data = {
				src: data.src,
				alt: data.alt,
				title: data.title,
				width: data.width,
				height: data.height,
				style: data.style,
				caption: data.caption,
				"class": data["class"]
			};

			editor.undoManager.transact(function() {
				if (!data.src) {
					if (imgElm) {
						dom.remove(imgElm);
						editor.focus();
						editor.nodeChanged();
					}

					return;
				}

				if (data.title === "") {
					data.title = null;
				}

				if (!imgElm) {
					data.id = '__mcenew';
					editor.focus();
					editor.selection.setContent(dom.createHTML('img', data));
					imgElm = dom.get('__mcenew');
					dom.setAttrib(imgElm, 'id', null);
				} else {
					dom.setAttribs(imgElm, data);
				}

				editor.editorUpload.uploadImagesAuto();

				if (data.caption === false) {
					if (dom.is(imgElm.parentNode, 'figure.image')) {
						figureElm = imgElm.parentNode;
						dom.insertAfter(imgElm, figureElm);
						dom.remove(figureElm);
					}
				}

				function isTextBlock(node) {
					return editor.schema.getTextBlockElements()[node.nodeName];
				}

				if (data.caption === true) {
					if (!dom.is(imgElm.parentNode, 'figure.image')) {
						oldImg = imgElm;
						imgElm = imgElm.cloneNode(true);
						figureElm = dom.create('figure', {'class': 'image'});
						figureElm.appendChild(imgElm);
						figureElm.appendChild(dom.create('figcaption', {contentEditable: true}, 'Caption'));
						figureElm.contentEditable = false;

						var textBlock = dom.getParent(oldImg, isTextBlock);
						if (textBlock) {
							dom.split(textBlock, oldImg, figureElm);
						} else {
							dom.replace(figureElm, oldImg);
						}

						editor.selection.select(figureElm);
					}

					return;
				}

				waitLoad(imgElm);
			});
		}

		function removePixelSuffix(value) {
			if (value) {
				value = value.replace(/px$/, '');
			}

			return value;
		}

		function srcChange(e) {
			var srcURL, prependURL, absoluteURLPattern, meta = e.meta || {};

			if (imageListCtrl) {
				imageListCtrl.value(editor.convertURL(this.value(), 'src'));
			}

			tinymce.each(meta, function(value, key) {
				win.find('#' + key).value(value);
			});

			if (!meta.width && !meta.height) {
				srcURL = editor.convertURL(this.value(), 'src');

				// Pattern test the src url and make sure we haven't already prepended the url
				prependURL = editor.settings.image_prepend_url;
				absoluteURLPattern = new RegExp('^(?:[a-z]+:)?//', 'i');
				if (prependURL && !absoluteURLPattern.test(srcURL) && srcURL.substring(0, prependURL.length) !== prependURL) {
					srcURL = prependURL + srcURL;
				}

				this.value(srcURL);

				getImageSize(editor.documentBaseURI.toAbsolute(this.value()), function(data) {
					if (data.width && data.height && imageDimensions) {
						width = data.width;
						height = data.height;

						win.find('#width').value(width);
						win.find('#height').value(height);
					}
				});
			}
		}

		function onBeforeCall(e) {
			e.meta = win.toJSON();
		}

		imgElm = editor.selection.getNode();
		figureElm = dom.getParent(imgElm, 'figure.image');
		if (figureElm) {
			imgElm = dom.select('img', figureElm)[0];
		}

		if (imgElm && (imgElm.nodeName != 'IMG' || imgElm.getAttribute('data-mce-object') || imgElm.getAttribute('data-mce-placeholder'))) {
			imgElm = null;
		}

		if (imgElm) {
			width = dom.getAttrib(imgElm, 'width');
			height = dom.getAttrib(imgElm, 'height');

			data = {
				src: dom.getAttrib(imgElm, 'src'),
				alt: dom.getAttrib(imgElm, 'alt'),
				title: dom.getAttrib(imgElm, 'title'),
				"class": dom.getAttrib(imgElm, 'class'),
				width: width,
				height: height,
				caption: !!figureElm
			};
		}

		if (imageList) {
			imageListCtrl = {
				type: 'listbox',
				label: 'Image list',
				values: buildListItems(
					imageList,
					function(item) {
						item.value = editor.convertURL(item.value || item.url, 'src');
					},
					[{text: 'None', value: ''}]
				),
				value: data.src && editor.convertURL(data.src, 'src'),
				onselect: function(e) {
					var altCtrl = win.find('#alt');

					if (!altCtrl.value() || (e.lastControl && altCtrl.value() == e.lastControl.text())) {
						altCtrl.value(e.control.text());
					}

					win.find('#src').value(e.control.value()).fire('change');
				},
				onPostRender: function() {
					/*eslint consistent-this: 0*/
					imageListCtrl = this;
				}
			};
		}

		if (editor.settings.image_class_list) {
			classListCtrl = {
				name: 'class',
				type: 'listbox',
				label: 'Class',
				values: buildListItems(
					editor.settings.image_class_list,
					function(item) {
						if (item.value) {
							item.textStyle = function() {
								return editor.formatter.getCssText({inline: 'img', classes: [item.value]});
							};
						}
					}
				)
			};
		}

		// General settings shared between simple and advanced dialogs
		var generalFormItems = [
			{
				name: 'src',
				type: 'filepicker',
				filetype: 'image',
				label: 'Source',
				autofocus: true,
				onchange: srcChange,
				onbeforecall: onBeforeCall
			},
			imageListCtrl
		];

		if (editor.settings.image_description !== false) {
			generalFormItems.push({name: 'alt', type: 'textbox', label: 'Image description'});
		}

		if (editor.settings.image_title) {
			generalFormItems.push({name: 'title', type: 'textbox', label: 'Image Title'});
		}

		if (imageDimensions) {
			generalFormItems.push({
				type: 'container',
				label: 'Dimensions',
				layout: 'flex',
				direction: 'row',
				align: 'center',
				spacing: 5,
				items: [
					{name: 'width', type: 'textbox', maxLength: 5, size: 3, onchange: recalcSize, ariaLabel: 'Width'},
					{type: 'label', text: 'x'},
					{name: 'height', type: 'textbox', maxLength: 5, size: 3, onchange: recalcSize, ariaLabel: 'Height'},
					{name: 'constrain', type: 'checkbox', checked: true, text: 'Constrain proportions'}
				]
			});
		}

		generalFormItems.push(classListCtrl);

		if (editor.settings.image_caption && tinymce.Env.ceFalse) {
			generalFormItems.push({name: 'caption', type: 'checkbox', label: 'Caption'});
		}

		function mergeMargins(css) {
			if (css.margin) {

				var splitMargin = css.margin.split(" ");

				switch (splitMargin.length) {
					case 1: //margin: toprightbottomleft;
						css['margin-top'] = css['margin-top'] || splitMargin[0];
						css['margin-right'] = css['margin-right'] || splitMargin[0];
						css['margin-bottom'] = css['margin-bottom'] || splitMargin[0];
						css['margin-left'] = css['margin-left'] || splitMargin[0];
						break;
					case 2: //margin: topbottom rightleft;
						css['margin-top'] = css['margin-top'] || splitMargin[0];
						css['margin-right'] = css['margin-right'] || splitMargin[1];
						css['margin-bottom'] = css['margin-bottom'] || splitMargin[0];
						css['margin-left'] = css['margin-left'] || splitMargin[1];
						break;
					case 3: //margin: top rightleft bottom;
						css['margin-top'] = css['margin-top'] || splitMargin[0];
						css['margin-right'] = css['margin-right'] || splitMargin[1];
						css['margin-bottom'] = css['margin-bottom'] || splitMargin[2];
						css['margin-left'] = css['margin-left'] || splitMargin[1];
						break;
					case 4: //margin: top right bottom left;
						css['margin-top'] = css['margin-top'] || splitMargin[0];
						css['margin-right'] = css['margin-right'] || splitMargin[1];
						css['margin-bottom'] = css['margin-bottom'] || splitMargin[2];
						css['margin-left'] = css['margin-left'] || splitMargin[3];
				}
				delete css.margin;
			}
			return css;
		}

		function updateStyle() {
			function addPixelSuffix(value) {
				if (value.length > 0 && /^[0-9]+$/.test(value)) {
					value += 'px';
				}

				return value;
			}

			if (!editor.settings.image_advtab) {
				return;
			}

			var data = win.toJSON(),
				css = dom.parseStyle(data.style);

			css = mergeMargins(css);

			if (data.vspace) {
				css['margin-top'] = css['margin-bottom'] = addPixelSuffix(data.vspace);
			}
			if (data.hspace) {
				css['margin-left'] = css['margin-right'] = addPixelSuffix(data.hspace);
			}
			if (data.border) {
				css['border-width'] = addPixelSuffix(data.border);
			}

			win.find('#style').value(dom.serializeStyle(dom.parseStyle(dom.serializeStyle(css))));
		}

		function updateVSpaceHSpaceBorder() {
			if (!editor.settings.image_advtab) {
				return;
			}

			var data = win.toJSON(),
				css = dom.parseStyle(data.style);

			win.find('#vspace').value("");
			win.find('#hspace').value("");

			css = mergeMargins(css);

			//Move opposite equal margins to vspace/hspace field
			if ((css['margin-top'] && css['margin-bottom']) || (css['margin-right'] && css['margin-left'])) {
				if (css['margin-top'] === css['margin-bottom']) {
					win.find('#vspace').value(removePixelSuffix(css['margin-top']));
				} else {
					win.find('#vspace').value('');
				}
				if (css['margin-right'] === css['margin-left']) {
					win.find('#hspace').value(removePixelSuffix(css['margin-right']));
				} else {
					win.find('#hspace').value('');
				}
			}

			//Move border-width
			if (css['border-width']) {
				win.find('#border').value(removePixelSuffix(css['border-width']));
			}

			win.find('#style').value(dom.serializeStyle(dom.parseStyle(dom.serializeStyle(css))));

		}

		if (editor.settings.image_advtab) {
			// Parse styles from img
			if (imgElm) {
				if (imgElm.style.marginLeft && imgElm.style.marginRight && imgElm.style.marginLeft === imgElm.style.marginRight) {
					data.hspace = removePixelSuffix(imgElm.style.marginLeft);
				}
				if (imgElm.style.marginTop && imgElm.style.marginBottom && imgElm.style.marginTop === imgElm.style.marginBottom) {
					data.vspace = removePixelSuffix(imgElm.style.marginTop);
				}
				if (imgElm.style.borderWidth) {
					data.border = removePixelSuffix(imgElm.style.borderWidth);
				}

				data.style = editor.dom.serializeStyle(editor.dom.parseStyle(editor.dom.getAttrib(imgElm, 'style')));
			}

			// Advanced dialog shows general+advanced tabs
			win = editor.windowManager.open({
				title: 'Insert/edit image',
				data: data,
				bodyType: 'tabpanel',
				body: [
					{
						title: 'General',
						type: 'form',
						items: generalFormItems
					},

					{
						title: 'Advanced',
						type: 'form',
						pack: 'start',
						items: [
							{
								label: 'Style',
								name: 'style',
								type: 'textbox',
								onchange: updateVSpaceHSpaceBorder
							},
							{
								type: 'form',
								layout: 'grid',
								packV: 'start',
								columns: 2,
								padding: 0,
								alignH: ['left', 'right'],
								defaults: {
									type: 'textbox',
									maxWidth: 50,
									onchange: updateStyle
								},
								items: [
									{label: 'Vertical space', name: 'vspace'},
									{label: 'Horizontal space', name: 'hspace'},
									{label: 'Border', name: 'border'}
								]
							}
						]
					}
				],
				onSubmit: onSubmitForm
			});
		} else {
			// Simple default dialog
			win = editor.windowManager.open({
				title: 'Insert/edit image',
				data: data,
				body: generalFormItems,
				onSubmit: onSubmitForm
			});
		}
	}

	editor.on('preInit', function() {
		function hasImageClass(node) {
			var className = node.attr('class');
			return className && /\bimage\b/.test(className);
		}

		function toggleContentEditableState(state) {
			return function(nodes) {
				var i = nodes.length, node;

				function toggleContentEditable(node) {
					node.attr('contenteditable', state ? 'true' : null);
				}

				while (i--) {
					node = nodes[i];

					if (hasImageClass(node)) {
						node.attr('contenteditable', state ? 'false' : null);
						tinymce.each(node.getAll('figcaption'), toggleContentEditable);
					}
				}
			};
		}

		editor.parser.addNodeFilter('figure', toggleContentEditableState(true));
		editor.serializer.addNodeFilter('figure', toggleContentEditableState(false));
	});

	editor.addButton('image', {
		icon: 'image',
		tooltip: 'Insert/edit image',
		onclick: createImageList(showDialog),
		stateSelector: 'img:not([data-mce-object],[data-mce-placeholder]),figure.image'
	});

	editor.addMenuItem('image', {
		icon: 'image',
		text: 'Image',
		onclick: createImageList(showDialog),
		context: 'insert',
		prependToContext: true
	});

	editor.addCommand('mceImage', createImageList(showDialog));
});

(function () {

var defs = {}; // id -> {dependencies, definition, instance (possibly undefined)}

// Used when there is no 'main' module.
// The name is probably (hopefully) unique so minification removes for releases.
var register_3795 = function (id) {
  var module = dem(id);
  var fragments = id.split('.');
  var target = Function('return this;')();
  for (var i = 0; i < fragments.length - 1; ++i) {
    if (target[fragments[i]] === undefined)
      target[fragments[i]] = {};
    target = target[fragments[i]];
  }
  target[fragments[fragments.length - 1]] = module;
};

var instantiate = function (id) {
  var actual = defs[id];
  var dependencies = actual.deps;
  var definition = actual.defn;
  var len = dependencies.length;
  var instances = new Array(len);
  for (var i = 0; i < len; ++i)
    instances[i] = dem(dependencies[i]);
  var defResult = definition.apply(null, instances);
  if (defResult === undefined)
     throw 'module [' + id + '] returned undefined';
  actual.instance = defResult;
};

var def = function (id, dependencies, definition) {
  if (typeof id !== 'string')
    throw 'module id must be a string';
  else if (dependencies === undefined)
    throw 'no dependencies for ' + id;
  else if (definition === undefined)
    throw 'no definition function for ' + id;
  defs[id] = {
    deps: dependencies,
    defn: definition,
    instance: undefined
  };
};

var dem = function (id) {
  var actual = defs[id];
  if (actual === undefined)
    throw 'module [' + id + '] was undefined';
  else if (actual.instance === undefined)
    instantiate(id);
  return actual.instance;
};

var req = function (ids, callback) {
  var len = ids.length;
  var instances = new Array(len);
  for (var i = 0; i < len; ++i)
    instances.push(dem(ids[i]));
  callback.apply(null, callback);
};

var ephox = {};

ephox.bolt = {
  module: {
    api: {
      define: def,
      require: req,
      demand: dem
    }
  }
};

var define = def;
var require = req;
var demand = dem;
// this helps with minificiation when using a lot of global references
var defineGlobal = function (id, ref) {
  define(id, [], function () { return ref; });
};
/*jsc
["tinymce/imagetoolsplugin/Plugin","global!tinymce.PluginManager","global!tinymce.Env","global!tinymce.util.Promise","global!tinymce.util.URI","global!tinymce.util.Tools","global!tinymce.util.Delay","ephox/imagetools/api/ImageTransformations","ephox/imagetools/api/BlobConversions","tinymce/imagetoolsplugin/Dialog","tinymce/imagetoolsplugin/ImageSize","tinymce/imagetoolsplugin/Proxy","ephox/imagetools/transformations/Filters","ephox/imagetools/transformations/ImageTools","ephox/imagetools/util/Conversions","global!tinymce.dom.DOMUtils","global!tinymce.ui.Factory","global!tinymce.ui.Form","global!tinymce.ui.Container","tinymce/imagetoolsplugin/ImagePanel","tinymce/imagetoolsplugin/UndoStack","tinymce/imagetoolsplugin/Utils","ephox/imagetools/util/Canvas","ephox/imagetools/util/ImageSize","ephox/imagetools/util/Promise","ephox/imagetools/util/Mime","ephox/imagetools/transformations/ColorMatrix","ephox/imagetools/transformations/ImageResizerCanvas","global!tinymce.ui.Control","global!tinymce.ui.DragHelper","global!tinymce.geom.Rect","tinymce/imagetoolsplugin/CropRect","global!tinymce.dom.DomQuery","global!tinymce.util.Observable","global!tinymce.util.VK"]
jsc*/
defineGlobal("global!tinymce.PluginManager", tinymce.PluginManager);
defineGlobal("global!tinymce.Env", tinymce.Env);
defineGlobal("global!tinymce.util.Promise", tinymce.util.Promise);
defineGlobal("global!tinymce.util.URI", tinymce.util.URI);
defineGlobal("global!tinymce.util.Tools", tinymce.util.Tools);
defineGlobal("global!tinymce.util.Delay", tinymce.util.Delay);
/**
 * Canvas.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Contains various canvas functions.
 */
define("ephox/imagetools/util/Canvas", [], function() {
  function create(width, height) {
    return resize(document.createElement('canvas'), width, height);
  }

  function get2dContext(canvas) {
    return canvas.getContext("2d");
  }

  function get3dContext(canvas) {
      var gl = null;
      try {
        gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
      }
      catch(e) {}

      if (!gl) { // it seems that sometimes it doesn't throw exception, but still fails to get context
        gl = null;
      }
      return gl;
  }

  function resize(canvas, width, height) {
    canvas.width = width;
    canvas.height = height;

    return canvas;
  }

  return {
    create: create,
    resize: resize,
    get2dContext: get2dContext,
    get3dContext: get3dContext
  };
});
/**
 * ImageSize.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Returns the size of images.
 */
define("ephox/imagetools/util/ImageSize", [], function() {
  function getWidth(image) {
    return image.naturalWidth || image.width;
  }

  function getHeight(image) {
    return image.naturalHeight || image.height;
  }

  return {
    getWidth: getWidth,
    getHeight: getHeight
  };
});
/**
 * Promise.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * Promise polyfill under MIT license: https://github.com/taylorhakes/promise-polyfill
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/* eslint-disable */
/* jshint ignore:start */

/**
 * Modifed to be a feature fill and wrapped as tinymce module.
 */
define("ephox/imagetools/util/Promise", [], function() {
  if (window.Promise) {
    return window.Promise;
  }

  // Use polyfill for setImmediate for performance gains
  var asap = Promise.immediateFn || (typeof setImmediate === 'function' && setImmediate) ||
    function(fn) { setTimeout(fn, 1); };

  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function() {
      fn.apply(thisArg, arguments);
    };
  }

  var isArray = Array.isArray || function(value) { return Object.prototype.toString.call(value) === "[object Array]"; };

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = null;
    this._value = null;
    this._deferreds = [];

    doResolve(fn, bind(resolve, this), bind(reject, this));
  }

  function handle(deferred) {
    var me = this;
    if (this._state === null) {
      this._deferreds.push(deferred);
      return;
    }
    asap(function() {
      var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (me._state ? deferred.resolve : deferred.reject)(me._value);
        return;
      }
      var ret;
      try {
        ret = cb(me._value);
      }
      catch (e) {
        deferred.reject(e);
        return;
      }
      deferred.resolve(ret);
    });
  }

  function resolve(newValue) {
    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === this) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (typeof then === 'function') {
          doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));
          return;
        }
      }
      this._state = true;
      this._value = newValue;
      finale.call(this);
    } catch (e) { reject.call(this, e); }
  }

  function reject(newValue) {
    this._state = false;
    this._value = newValue;
    finale.call(this);
  }

  function finale() {
    for (var i = 0, len = this._deferreds.length; i < len; i++) {
      handle.call(this, this._deferreds[i]);
    }
    this._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, resolve, reject){
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.resolve = resolve;
    this.reject = reject;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, onFulfilled, onRejected) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        onFulfilled(value);
      }, function (reason) {
        if (done) return;
        done = true;
        onRejected(reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      onRejected(ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function(onFulfilled, onRejected) {
    var me = this;
    return new Promise(function(resolve, reject) {
      handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));
    });
  };

  Promise.all = function () {
    var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;
      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) { res(i, val); }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }
      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for(var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  return Promise;
});

/* jshint ignore:end */
/* eslint-enable */
/**
 * Mime.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Returns mime types for uris.
 */
define("ephox/imagetools/util/Mime", [], function() {
  function getUriPathName(uri) {
    var a = document.createElement('a');

    a.href = uri;

    return a.pathname;
  }

  function guessMimeType(uri) {
    var parts = getUriPathName(uri).split('.'),
      ext = parts[parts.length - 1],
      mimes = {
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png'
      };

    if (ext) {
      ext = ext.toLowerCase();
    }

    return mimes[ext];
  }

  return {
    guessMimeType: guessMimeType
  };
});
/**
 * Conversions.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Converts blob/uris/images back and forth.
 */
define("ephox/imagetools/util/Conversions", [
  "ephox/imagetools/util/Promise",
  "ephox/imagetools/util/Canvas",
  "ephox/imagetools/util/Mime",
  "ephox/imagetools/util/ImageSize"
], function(Promise, Canvas, Mime, ImageSize) {
  function loadImage(image) {
    return new Promise(function(resolve) {
      function loaded() {
        image.removeEventListener('load', loaded);
        resolve(image);
      }

      if (image.complete) {
        resolve(image);
      } else {
        image.addEventListener('load', loaded);
      }
    });
  }

  function imageToCanvas(image) {
    return loadImage(image).then(function(image) {
      var context, canvas;

      canvas = Canvas.create(ImageSize.getWidth(image), ImageSize.getHeight(image));
      context = Canvas.get2dContext(canvas);
      context.drawImage(image, 0, 0);

      return canvas;
    });
  }

  function imageToBlob(image) {
    return loadImage(image).then(function(image) {
      var src = image.src;

      if (src.indexOf('blob:') === 0) {
        return blobUriToBlob(src);
      }

      if (src.indexOf('data:') === 0) {
        return dataUriToBlob(src);
      }

      return imageToCanvas(image).then(function(canvas) {
        return dataUriToBlob(canvas.toDataURL(Mime.guessMimeType(src)));
      });
    });
  }

  function blobToImage(blob) {
    return new Promise(function(resolve) {
      var image = new Image();

      function loaded() {
        image.removeEventListener('load', loaded);
        resolve(image);
      }

      image.addEventListener('load', loaded);
      image.src = URL.createObjectURL(blob);

      if (image.complete) {
        loaded();
      }
    });
  }

  function blobUriToBlob(url) {
    return new Promise(function(resolve) {
      var xhr = new XMLHttpRequest();

      xhr.open('GET', url, true);
      xhr.responseType = 'blob';

      xhr.onload = function() {
        if (this.status == 200) {
          resolve(this.response);
        }
      };

      xhr.send();
    });
  }

  function dataUriToBlob(uri) {
    return new Promise(function(resolve) {
      var str, arr, i, matches, type, blobBuilder;

      uri = uri.split(',');

      matches = /data:([^;]+)/.exec(uri[0]);
      if (matches) {
        type = matches[1];
      }

      str = atob(uri[1]);

      if (window.WebKitBlobBuilder) {
        /*globals WebKitBlobBuilder:false */
        blobBuilder = new WebKitBlobBuilder();

        arr = new ArrayBuffer(str.length);
        for (i = 0; i < arr.length; i++) {
          arr[i] = str.charCodeAt(i);
        }

        blobBuilder.append(arr);

        resolve(blobBuilder.getBlob(type));
        return;
      }

      arr = new Uint8Array(str.length);

      for (i = 0; i < arr.length; i++) {
        arr[i] = str.charCodeAt(i);
      }

      resolve(new Blob([arr], {type: type}));
    });
  }

  function uriToBlob(url) {
    if (url.indexOf('blob:') === 0) {
      return blobUriToBlob(url);
    }

    if (url.indexOf('data:') === 0) {
      return dataUriToBlob(url);
    }

    return null;
  }

  function canvasToBlob(canvas, type) {
    return dataUriToBlob(canvas.toDataURL(type));
  }

  function blobToDataUri(blob) {
    return new Promise(function(resolve) {
      var reader = new FileReader();

      reader.onloadend = function() {
        resolve(reader.result);
      };

      reader.readAsDataURL(blob);
    });
  }

  function blobToBase64(blob) {
    return blobToDataUri(blob).then(function(dataUri) {
      return dataUri.split(',')[1];
    });
  }

  function revokeImageUrl(image) {
    URL.revokeObjectURL(image.src);
  }

  return {
    // used outside
    blobToImage: blobToImage,
    // used outside
    imageToBlob: imageToBlob,
    // used outside
    blobToDataUri: blobToDataUri,
    // used outside
    blobToBase64: blobToBase64,

    // helper method
    imageToCanvas: imageToCanvas,

    // helper method
    canvasToBlob: canvasToBlob,

    // helper method
    revokeImageUrl: revokeImageUrl,

     // helper method
    uriToBlob: uriToBlob

  };
});
/**
 * ImageTools.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 *
 * Some of the matrix calculations and constants are from the EaselJS library released under MIT:
 * https://github.com/CreateJS/EaselJS/blob/master/src/easeljs/filters/ColorMatrix.js
 */

/**
 * Various operations for color matrices.
 */
define("ephox/imagetools/transformations/ColorMatrix", [], function() {
  function clamp(value, min, max) {
    value = parseFloat(value);

    if (value > max) {
      value = max;
    } else if (value < min) {
      value = min;
    }

    return value;
  }

  function identity() {
    return [
      1, 0, 0, 0, 0,
      0, 1, 0, 0, 0,
      0, 0, 1, 0, 0,
      0, 0, 0, 1, 0,
      0, 0, 0, 0, 1
    ];
  }

  var DELTA_INDEX = [
    0, 0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1, 0.11,
    0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,
    0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,
    0.44, 0.46, 0.48, 0.5, 0.53, 0.56, 0.59, 0.62, 0.65, 0.68,
    0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,
    1.0, 1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,
    1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0, 2.12, 2.25,
    2.37, 2.50, 2.62, 2.75, 2.87, 3.0, 3.2, 3.4, 3.6, 3.8,
    4.0, 4.3, 4.7, 4.9, 5.0, 5.5, 6.0, 6.5, 6.8, 7.0,
    7.3, 7.5, 7.8, 8.0, 8.4, 8.7, 9.0, 9.4, 9.6, 9.8,
    10.0
  ];

  function multiply(matrix1, matrix2) {
    var i, j, k, val, col = [], out = new Array(10);

    for (i = 0; i < 5; i++) {
      for (j = 0; j < 5; j++) {
        col[j] = matrix2[j + i * 5];
      }

      for (j = 0; j < 5; j++) {
        val = 0;

        for (k = 0; k < 5; k++) {
          val += matrix1[j + k * 5] * col[k];
        }

        out[j + i * 5] = val;
      }
    }

    return out;
  }

  function adjust(matrix, adjustValue) {
    adjustValue = clamp(adjustValue, 0, 1);

    return matrix.map(function(value, index) {
      if (index % 6 === 0) {
        value = 1.0 - ((1 - value) * adjustValue);
      } else {
        value *= adjustValue;
      }

      return clamp(value, 0, 1);
    });
  }

  function adjustContrast(matrix, value) {
    var x;

    value = clamp(value, -1, 1);
    value *= 100;

    if (value < 0) {
      x = 127 + value / 100 * 127;
    } else {
      x = value % 1;

      if (x === 0) {
        x = DELTA_INDEX[value];
      } else {
        // use linear interpolation for more granularity.
        x = DELTA_INDEX[(Math.floor(value))] * (1 - x) + DELTA_INDEX[(Math.floor(value)) + 1] * x;
      }

      x = x * 127 + 127;
    }

    return multiply(matrix, [
      x / 127, 0, 0, 0, 0.5 * (127 - x),
      0, x / 127, 0, 0, 0.5 * (127 - x),
      0, 0, x / 127, 0, 0.5 * (127 - x),
      0, 0, 0, 1, 0,
      0, 0, 0, 0, 1
    ]);
  }

  function adjustSaturation(matrix, value) {
    var x, lumR, lumG, lumB;

    value = clamp(value, -1, 1);
    x = 1 + ((value > 0) ? 3 * value : value);
    lumR = 0.3086;
    lumG = 0.6094;
    lumB = 0.0820;

    return multiply(matrix, [
      lumR * (1 - x) + x, lumG * (1 - x), lumB * (1 - x), 0, 0,
      lumR * (1 - x), lumG * (1 - x) + x, lumB * (1 - x), 0, 0,
      lumR * (1 - x), lumG * (1 - x), lumB * (1 - x) + x, 0, 0,
      0, 0, 0, 1, 0,
      0, 0, 0, 0, 1
    ]);
  }

  function adjustHue(matrix, angle) {
    var cosVal, sinVal, lumR, lumG, lumB;

    angle = clamp(angle, -180, 180) / 180 * Math.PI;
    cosVal = Math.cos(angle);
    sinVal = Math.sin(angle);
    lumR = 0.213;
    lumG = 0.715;
    lumB = 0.072;

    return multiply(matrix, [
      lumR + cosVal * (1 - lumR) + sinVal * (-lumR), lumG + cosVal * (-lumG) + sinVal * (-lumG),
      lumB + cosVal * (-lumB) + sinVal * (1 - lumB), 0, 0,
      lumR + cosVal * (-lumR) + sinVal * (0.143), lumG + cosVal * (1 - lumG) + sinVal * (0.140),
      lumB + cosVal * (-lumB) + sinVal * (-0.283), 0, 0,
      lumR + cosVal * (-lumR) + sinVal * (-(1 - lumR)), lumG + cosVal * (-lumG) + sinVal * (lumG),
      lumB + cosVal * (1 - lumB) + sinVal * (lumB), 0, 0,
      0, 0, 0, 1, 0,
      0, 0, 0, 0, 1
    ]);
  }

  function adjustBrightness(matrix, value) {
    value = clamp(255 * value, -255, 255);

    return multiply(matrix, [
      1, 0, 0, 0, value,
      0, 1, 0, 0, value,
      0, 0, 1, 0, value,
      0, 0, 0, 1, 0,
      0, 0, 0, 0, 1
    ]);
  }

  function adjustColors(matrix, adjustR, adjustG, adjustB) {
    adjustR = clamp(adjustR, 0, 2);
    adjustG = clamp(adjustG, 0, 2);
    adjustB = clamp(adjustB, 0, 2);

    return multiply(matrix, [
      adjustR, 0, 0, 0, 0,
      0, adjustG, 0, 0, 0,
      0, 0, adjustB, 0, 0,
      0, 0, 0, 1, 0,
      0, 0, 0, 0, 1
    ]);
  }

  function adjustSepia(matrix, value) {
    value = clamp(value, 0, 1);

    return multiply(matrix, adjust([
      0.393, 0.769, 0.189, 0, 0,
      0.349, 0.686, 0.168, 0, 0,
      0.272, 0.534, 0.131, 0, 0,
      0, 0, 0, 1, 0,
      0, 0, 0, 0, 1
    ], value));
  }

  function adjustGrayscale(matrix, value) {
    value = clamp(value, 0, 1);

    return multiply(matrix, adjust([
      0.33, 0.34, 0.33, 0, 0,
      0.33, 0.34, 0.33, 0, 0,
      0.33, 0.34, 0.33, 0, 0,
      0, 0, 0, 1, 0,
      0, 0, 0, 0, 1
    ], value));
  }

  return {
    identity: identity,
    adjust: adjust,
    multiply: multiply,
    adjustContrast: adjustContrast,
    adjustBrightness: adjustBrightness,
    adjustSaturation: adjustSaturation,
    adjustHue: adjustHue,
    adjustColors: adjustColors,
    adjustSepia: adjustSepia,
    adjustGrayscale: adjustGrayscale
  };
});
/**
 * Filters.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Applies various filters to blobs.
 */
define("ephox/imagetools/transformations/Filters", [
  "ephox/imagetools/util/Canvas",
  "ephox/imagetools/util/ImageSize",
  "ephox/imagetools/util/Conversions",
  "ephox/imagetools/transformations/ColorMatrix"
], function(Canvas, ImageSize, Conversions, ColorMatrix) {
  var revokeImageUrl = Conversions.revokeImageUrl;

  function colorFilter(blob, matrix) {
    return Conversions.blobToImage(blob).then(function(image) {
      var canvas = Canvas.create(ImageSize.getWidth(image), ImageSize.getHeight(image)),
        context = Canvas.get2dContext(canvas),
        pixels;

      function applyMatrix(pixels, m) {
        var d = pixels.data, r, g, b, a, i,
          m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], m4 = m[4],
          m5 = m[5], m6 = m[6], m7 = m[7], m8 = m[8], m9 = m[9],
          m10 = m[10], m11 = m[11], m12 = m[12], m13 = m[13], m14 = m[14],
          m15 = m[15], m16 = m[16], m17 = m[17], m18 = m[18], m19 = m[19];

        for (i = 0; i < d.length; i += 4) {
          r = d[i];
          g = d[i + 1];
          b = d[i + 2];
          a = d[i + 3];

          d[i] = r * m0 + g * m1 + b * m2 + a * m3 + m4;
          d[i + 1] = r * m5 + g * m6 + b * m7 + a * m8 + m9;
          d[i + 2] = r * m10 + g * m11 + b * m12 + a * m13 + m14;
          d[i + 3] = r * m15 + g * m16 + b * m17 + a * m18 + m19;
        }

        return pixels;
      }

      context.drawImage(image, 0, 0);
      revokeImageUrl(image);
      pixels = applyMatrix(context.getImageData(0, 0, canvas.width, canvas.height), matrix);
      context.putImageData(pixels, 0, 0);

      return Conversions.canvasToBlob(canvas);
    });
  }

  function convoluteFilter(blob, matrix) {
    return Conversions.blobToImage(blob).then(function(image) {
      var canvas = Canvas.create(ImageSize.getWidth(image), ImageSize.getHeight(image)),
        context = Canvas.get2dContext(canvas),
        pixelsIn, pixelsOut;

      function applyMatrix(pixelsIn, pixelsOut, matrix) {
        var rgba, drgba, side, halfSide, x, y, r, g, b,
          cx, cy, scx, scy, offset, wt, w, h;

        function clamp(value, min, max) {
          if (value > max) {
            value = max;
          } else if (value < min) {
            value = min;
          }

          return value;
        }

        // Calc side and half side of matrix
        side = Math.round(Math.sqrt(matrix.length));
        halfSide = Math.floor(side / 2);
        rgba = pixelsIn.data;
        drgba = pixelsOut.data;
        w = pixelsIn.width;
        h = pixelsIn.height;

        // Apply convolution matrix to pixels
        for (y = 0; y < h; y++) {
          for (x = 0; x < w; x++) {
            r = g = b = 0;

            for (cy = 0; cy < side; cy++) {
              for (cx = 0; cx < side; cx++) {
                // Calc relative x, y based on matrix
                scx = clamp(x + cx - halfSide, 0, w - 1);
                scy = clamp(y + cy - halfSide, 0, h - 1);

                // Calc r, g, b
                offset = (scy * w + scx) * 4;
                wt = matrix[cy * side + cx];
                r += rgba[offset] * wt;
                g += rgba[offset + 1] * wt;
                b += rgba[offset + 2] * wt;
              }
            }

            // Set new RGB to destination buffer
            offset = (y * w + x) * 4;
            drgba[offset] = clamp(r, 0, 255);
            drgba[offset + 1] = clamp(g, 0, 255);
            drgba[offset + 2] = clamp(b, 0, 255);
          }
        }

        return pixelsOut;
      }

      context.drawImage(image, 0, 0);
      revokeImageUrl(image);
      pixelsIn = context.getImageData(0, 0, canvas.width, canvas.height);
      pixelsOut = context.getImageData(0, 0, canvas.width, canvas.height);
      pixelsOut = applyMatrix(pixelsIn, pixelsOut, matrix);
      context.putImageData(pixelsOut, 0, 0);

      return Conversions.canvasToBlob(canvas);
    });
  }

  function functionColorFilter(colorFn) {
    return function(blob, value) {
      return Conversions.blobToImage(blob).then(function(image) {
        var canvas = Canvas.create(ImageSize.getWidth(image), ImageSize.getHeight(image)),
          context = Canvas.get2dContext(canvas),
          pixels, i, lookup = new Array(256);

        function applyLookup(pixels, lookup) {
          var d = pixels.data, i;

          for (i = 0; i < d.length; i += 4) {
            d[i] = lookup[d[i]];
            d[i + 1] = lookup[d[i + 1]];
            d[i + 2] = lookup[d[i + 2]];
          }

          return pixels;
        }

        for (i = 0; i < lookup.length; i++) {
          lookup[i] = colorFn(i, value);
        }

        context.drawImage(image, 0, 0);
        revokeImageUrl(image);
        pixels = applyLookup(context.getImageData(0, 0, canvas.width, canvas.height), lookup);
        context.putImageData(pixels, 0, 0);

        return Conversions.canvasToBlob(canvas);
      });
    };
  }

  function complexAdjustableColorFilter(matrixAdjustFn) {
    return function(blob, adjust) {
      return colorFilter(blob, matrixAdjustFn(ColorMatrix.identity(), adjust));
    };
  }

  function basicColorFilter(matrix) {
    return function(blob) {
      return colorFilter(blob, matrix);
    };
  }

  function basicConvolutionFilter(kernel) {
    return function(blob) {
      return convoluteFilter(blob, kernel);
    };
  }

  return {
    invert: basicColorFilter([
      -1, 0, 0, 0, 255,
      0, -1, 0, 0, 255,
      0, 0, -1, 0, 255,
      0, 0, 0, 1, 0
    ]),

    brightness: complexAdjustableColorFilter(ColorMatrix.adjustBrightness),
    hue: complexAdjustableColorFilter(ColorMatrix.adjustHue),
    saturate: complexAdjustableColorFilter(ColorMatrix.adjustSaturation),
    contrast: complexAdjustableColorFilter(ColorMatrix.adjustContrast),
    grayscale: complexAdjustableColorFilter(ColorMatrix.adjustGrayscale),
    sepia: complexAdjustableColorFilter(ColorMatrix.adjustSepia),
    colorize: function(blob, adjustR, adjustG, adjustB) {
      return colorFilter(blob, ColorMatrix.adjustColors(ColorMatrix.identity(), adjustR, adjustG, adjustB));
    },

    sharpen: basicConvolutionFilter([
      0, -1, 0,
      -1, 5, -1,
      0, -1, 0
    ]),

    emboss: basicConvolutionFilter([
      -2, -1, 0,
      -1, 1, 1,
      0, 1, 2
    ]),

    gamma: functionColorFilter(function(color, value) {
      return Math.pow(color / 255, 1 - value) * 255;
    }),

    exposure: functionColorFilter(function(color, value) {
      return 255 * (1 - Math.exp(-(color / 255) * value));
    }),

    colorFilter: colorFilter,
    convoluteFilter: convoluteFilter
  };
});
/**
 * ImageResizerCanvas.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Resizes image/canvas using canvas
 */
define("ephox/imagetools/transformations/ImageResizerCanvas", [
    "ephox/imagetools/util/Promise",
    "ephox/imagetools/util/Conversions",
    "ephox/imagetools/util/Canvas",
    "ephox/imagetools/util/ImageSize"
], function(Promise, Conversions, Canvas, ImageSize) {

    /**
     * @method scale
     * @static
     * @param image {Image|Canvas}
     * @param dW {Number} Width that the image should be scaled to
     * @param dH {Number} Height that the image should be scaled to
     * @returns {Promise}
     */
    function scale(image, dW, dH) {
        var sW = ImageSize.getWidth(image);
        var sH = ImageSize.getHeight(image);
        var wRatio = dW / sW;
        var hRatio = dH / sH;
        var scaleCapped = false;

        if (wRatio < 0.5 || wRatio > 2) {
            wRatio = wRatio < 0.5 ? 0.5 : 2;
            scaleCapped = true;
        }
        if (hRatio < 0.5 || hRatio > 2) {
            hRatio = hRatio < 0.5 ? 0.5 : 2;
            scaleCapped = true;
        }

        var scaled = _scale(image, wRatio, hRatio);

        return !scaleCapped ? scaled : scaled.then(function (tCanvas) {
            return scale(tCanvas, dW, dH);
        });
    }


    function _scale(image, wRatio, hRatio) {
        return new Promise(function(resolve) {
            var sW = ImageSize.getWidth(image);
            var sH = ImageSize.getHeight(image);
            var dW = Math.floor(sW * wRatio);
            var dH = Math.floor(sH * hRatio);
            var canvas = Canvas.create(dW, dH);
            var context = Canvas.get2dContext(canvas);

            context.drawImage(image, 0, 0, sW, sH, 0, 0, dW, dH);

            resolve(canvas);
        });
    }

    return {
        scale: scale
    };

});

/**
 * ImageTools.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Modifies image blobs.
 */
define("ephox/imagetools/transformations/ImageTools", [
  "ephox/imagetools/util/Conversions",
  "ephox/imagetools/util/Canvas",
  "ephox/imagetools/util/ImageSize",
  "ephox/imagetools/transformations/ImageResizerCanvas"
], function(Conversions, Canvas, ImageSize, ImageResizerCanvas) {
  var revokeImageUrl = Conversions.revokeImageUrl;

  function rotate(blob, angle) {
    return Conversions.blobToImage(blob).then(function(image) {
      var canvas = Canvas.create(ImageSize.getWidth(image), ImageSize.getHeight(image)),
        context = Canvas.get2dContext(canvas),
        translateX = 0, translateY = 0;

      angle = angle < 0 ? 360 + angle : angle;

      if (angle == 90 || angle == 270) {
        Canvas.resize(canvas, canvas.height, canvas.width);
      }

      if (angle == 90 || angle == 180) {
        translateX = canvas.width;
      }

      if (angle == 270 || angle == 180) {
        translateY = canvas.height;
      }

      context.translate(translateX, translateY);
      context.rotate(angle * Math.PI / 180);
      context.drawImage(image, 0, 0);
      revokeImageUrl(image);

      return Conversions.canvasToBlob(canvas, blob.type);
    });
  }

  function flip(blob, axis) {
    return Conversions.blobToImage(blob).then(function(image) {
      var canvas = Canvas.create(ImageSize.getWidth(image), ImageSize.getHeight(image)),
        context = Canvas.get2dContext(canvas);

      if (axis == 'v') {
        context.scale(1, -1);
        context.drawImage(image, 0, -canvas.height);
      } else {
        context.scale(-1, 1);
        context.drawImage(image, -canvas.width, 0);
      }

      revokeImageUrl(image);

      return Conversions.canvasToBlob(canvas);
    });
  }

  function crop(blob, x, y, w, h) {
    return Conversions.blobToImage(blob).then(function(image) {
      var canvas = Canvas.create(w, h),
        context = Canvas.get2dContext(canvas);

      context.drawImage(image, -x, -y);
      revokeImageUrl(image);

      return Conversions.canvasToBlob(canvas);
    });
  }

  var revokeImage = function (image) {
    return function (result) {
      revokeImageUrl(image);
      return result;
    };
  };

  function resize(blob, w, h) {
    return Conversions.blobToImage(blob).then(function(image) {
      var result;

      result = ImageResizerCanvas.scale(image, w, h)
        .then(function(canvas) {
          return Conversions.canvasToBlob(canvas, blob.type);
        })
        .then(revokeImage(image))
        .catch(revokeImage(image));

      return result;
    });
  }

  return {
    rotate: rotate,
    flip: flip,
    crop: crop,
    resize: resize
  };
});

define(
  'ephox/imagetools/api/ImageTransformations',

  [
    'ephox/imagetools/transformations/Filters',
    'ephox/imagetools/transformations/ImageTools'
  ],

  function (Filters, ImageTools) {
    var invert = function (blob) {
      return Filters.invert(blob);
    };

    var sharpen = function (blob) {
      return Filters.sharpen(blob);
    };

    var emboss = function (blob) {
      return Filters.emboss(blob);
    };

    var gamma = function (blob, value) {
      return Filters.gamma(blob, value);
    };

    var exposure = function (blob, value) {
      return Filters.exposure(blob, value);
    };

    var colorize = function (blob, adjustR, adjustG, adjustB) {
      return Filters.colorize(blob, adjustR, adjustG, adjustB);
    };

    var brightness = function (blob, adjust) {
      return Filters.brightness(blob, adjust);
    };

    var hue = function (blob, adjust) {
      return Filters.hue(blob, adjust);
    };

    var saturate = function (blob, adjust) {
      return Filters.saturate(blob, adjust);
    };

    var contrast = function (blob, adjust) {
      return Filters.contrast(blob, adjust);
    };

    var grayscale = function (blob, adjust) {
      return Filters.grayscale(blob, adjust);
    };

    var sepia = function (blob, adjust) {
      return Filters.sepia(blob, adjust);
    };

    var flip = function (blob, axis) {
      return ImageTools.flip(blob, axis);
    };

    var crop = function (blob, x, y, w, h) {
      return ImageTools.crop(blob, x, y, w, h);
    };

    var resize = function (blob, w, h) {
      return ImageTools.resize(blob, w, h);
    };

    var rotate = function (blob, angle) {
      return ImageTools.rotate(blob, angle);
    };

    return {
      invert: invert,
      sharpen: sharpen,
      emboss: emboss,
      brightness: brightness,
      hue: hue,
      saturate: saturate,
      contrast: contrast,
      grayscale: grayscale,
      sepia: sepia,
      colorize: colorize,
      gamma: gamma,
      exposure: exposure,

      flip: flip,
      crop: crop,
      resize: resize,
      rotate: rotate
    };
  }
);
define(
  'ephox/imagetools/api/BlobConversions',

  [
    'ephox/imagetools/util/Conversions'
  ],

  function (Conversions) {
    var blobToImage = function (image) {
      return Conversions.blobToImage(image);
    };

    var imageToBlob = function (blob) {
      return Conversions.imageToBlob(blob);
    };

    var blobToDataUri = function (blob) {
      return Conversions.blobToDataUri(blob);
    };

    var blobToBase64 = function (blob) {
      return Conversions.blobToBase64(blob);
    };

    return {
      // used outside
      blobToImage: blobToImage,
      // used outside
      imageToBlob: imageToBlob,
      // used outside
      blobToDataUri: blobToDataUri,
      // used outside
      blobToBase64: blobToBase64
    };
  }
);
defineGlobal("global!tinymce.dom.DOMUtils", tinymce.dom.DOMUtils);
defineGlobal("global!tinymce.ui.Factory", tinymce.ui.Factory);
defineGlobal("global!tinymce.ui.Form", tinymce.ui.Form);
defineGlobal("global!tinymce.ui.Container", tinymce.ui.Container);
defineGlobal("global!tinymce.ui.Control", tinymce.ui.Control);
defineGlobal("global!tinymce.ui.DragHelper", tinymce.ui.DragHelper);
defineGlobal("global!tinymce.geom.Rect", tinymce.geom.Rect);
defineGlobal("global!tinymce.dom.DomQuery", tinymce.dom.DomQuery);
defineGlobal("global!tinymce.util.Observable", tinymce.util.Observable);
defineGlobal("global!tinymce.util.VK", tinymce.util.VK);
/**
 * CropRect.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * ...
 */
define("tinymce/imagetoolsplugin/CropRect", [
	"global!tinymce.dom.DomQuery",
	"global!tinymce.ui.DragHelper",
	"global!tinymce.geom.Rect",
	"global!tinymce.util.Tools",
	"global!tinymce.util.Observable",
	"global!tinymce.util.VK"
], function($, DragHelper, Rect, Tools, Observable, VK) {
	var count = 0;

	return function(currentRect, viewPortRect, clampRect, containerElm, action) {
		var instance, handles, dragHelpers, blockers, prefix = 'mce-', id = prefix + 'crid-' + (count++);

		handles = [
			{name: 'move', xMul: 0, yMul: 0, deltaX: 1, deltaY: 1, deltaW: 0, deltaH: 0, label: 'Crop Mask'},
			{name: 'nw', xMul: 0, yMul: 0, deltaX: 1, deltaY: 1, deltaW: -1, deltaH: -1, label: 'Top Left Crop Handle'},
			{name: 'ne', xMul: 1, yMul: 0, deltaX: 0, deltaY: 1, deltaW: 1, deltaH: -1, label: 'Top Right Crop Handle'},
			{name: 'sw', xMul: 0, yMul: 1, deltaX: 1, deltaY: 0, deltaW: -1, deltaH: 1, label: 'Bottom Left Crop Handle'},
			{name: 'se', xMul: 1, yMul: 1, deltaX: 0, deltaY: 0, deltaW: 1, deltaH: 1, label: 'Bottom Right Crop Handle'}
		];

		blockers = ["top", "right", "bottom", "left"];

		function getAbsoluteRect(outerRect, relativeRect) {
			return {
				x: relativeRect.x + outerRect.x,
				y: relativeRect.y + outerRect.y,
				w: relativeRect.w,
				h: relativeRect.h
			};
		}

		function getRelativeRect(outerRect, innerRect) {
			return {
				x: innerRect.x - outerRect.x,
				y: innerRect.y - outerRect.y,
				w: innerRect.w,
				h: innerRect.h
			};
		}

		function getInnerRect() {
			return getRelativeRect(clampRect, currentRect);
		}

		function moveRect(handle, startRect, deltaX, deltaY) {
			var x, y, w, h, rect;

			x = startRect.x;
			y = startRect.y;
			w = startRect.w;
			h = startRect.h;

			x += deltaX * handle.deltaX;
			y += deltaY * handle.deltaY;
			w += deltaX * handle.deltaW;
			h += deltaY * handle.deltaH;

			if (w < 20) {
				w = 20;
			}

			if (h < 20) {
				h = 20;
			}

			rect = currentRect = Rect.clamp({x: x, y: y, w: w, h: h}, clampRect, handle.name == 'move');
			rect = getRelativeRect(clampRect, rect);

			instance.fire('updateRect', {rect: rect});
			setInnerRect(rect);
		}

		function render() {
			function createDragHelper(handle) {
				var startRect;

				return new DragHelper(id, {
					document: containerElm.ownerDocument,
					handle: id + '-' + handle.name,

					start: function() {
						startRect = currentRect;
					},

					drag: function(e) {
						moveRect(handle, startRect, e.deltaX, e.deltaY);
					}
				});
			}

			$(
				'<div id="' + id + '" class="' + prefix + 'croprect-container"' +
				' role="grid" aria-dropeffect="execute">'
			).appendTo(containerElm);

			Tools.each(blockers, function(blocker) {
				$('#' + id, containerElm).append(
					'<div id="' + id + '-' + blocker + '"class="' + prefix + 'croprect-block" style="display: none" data-mce-bogus="all">'
				);
			});

			Tools.each(handles, function(handle) {
				$('#' + id, containerElm).append(
					'<div id="' + id + '-' + handle.name + '" class="' + prefix +
						'croprect-handle ' + prefix + 'croprect-handle-' + handle.name + '"' +
						'style="display: none" data-mce-bogus="all" role="gridcell" tabindex="-1"' +
						' aria-label="' + handle.label + '" aria-grabbed="false">'
				);
			});

			dragHelpers = Tools.map(handles, createDragHelper);

			repaint(currentRect);

			$(containerElm).on('focusin focusout', function(e) {
				$(e.target).attr('aria-grabbed', e.type === 'focus');
			});

			$(containerElm).on('keydown', function(e) {
				var activeHandle;

				Tools.each(handles, function(handle) {
					if (e.target.id == id + '-' + handle.name) {
						activeHandle = handle;
						return false;
					}
				});

				function moveAndBlock(evt, handle, startRect, deltaX, deltaY) {
					evt.stopPropagation();
					evt.preventDefault();

					moveRect(activeHandle, startRect, deltaX, deltaY);
				}

				switch (e.keyCode) {
					case VK.LEFT:
						moveAndBlock(e, activeHandle, currentRect, -10, 0);
						break;

					case VK.RIGHT:
						moveAndBlock(e, activeHandle, currentRect, 10, 0);
						break;

					case VK.UP:
						moveAndBlock(e, activeHandle, currentRect, 0, -10);
						break;

					case VK.DOWN:
						moveAndBlock(e, activeHandle, currentRect, 0, 10);
						break;

					case VK.ENTER:
					case VK.SPACEBAR:
						e.preventDefault();
						action();
						break;
				}
			});
		}

		function toggleVisibility(state) {
			var selectors;

			selectors = Tools.map(handles, function(handle) {
				return '#' + id + '-' + handle.name;
			}).concat(Tools.map(blockers, function(blocker) {
				return '#' + id + '-' + blocker;
			})).join(',');

			if (state) {
				$(selectors, containerElm).show();
			} else {
				$(selectors, containerElm).hide();
			}
		}

		function repaint(rect) {
			function updateElementRect(name, rect) {
				if (rect.h < 0) {
					rect.h = 0;
				}

				if (rect.w < 0) {
					rect.w = 0;
				}

				$('#' + id + '-' + name, containerElm).css({
					left: rect.x,
					top: rect.y,
					width: rect.w,
					height: rect.h
				});
			}

			Tools.each(handles, function(handle) {
				$('#' + id + '-' + handle.name, containerElm).css({
					left: rect.w * handle.xMul + rect.x,
					top: rect.h * handle.yMul + rect.y
				});
			});

			updateElementRect('top', {x: viewPortRect.x, y: viewPortRect.y, w: viewPortRect.w, h: rect.y - viewPortRect.y});
			updateElementRect('right', {x: rect.x + rect.w, y: rect.y, w: viewPortRect.w - rect.x - rect.w + viewPortRect.x, h: rect.h});
			updateElementRect('bottom', {
				x: viewPortRect.x,
				y: rect.y + rect.h,
				w: viewPortRect.w,
				h: viewPortRect.h - rect.y - rect.h + viewPortRect.y
			});
			updateElementRect('left', {x: viewPortRect.x, y: rect.y, w: rect.x - viewPortRect.x, h: rect.h});
			updateElementRect('move', rect);
		}

		function setRect(rect) {
			currentRect = rect;
			repaint(currentRect);
		}

		function setViewPortRect(rect) {
			viewPortRect = rect;
			repaint(currentRect);
		}

		function setInnerRect(rect) {
			setRect(getAbsoluteRect(clampRect, rect));
		}

		function setClampRect(rect) {
			clampRect = rect;
			repaint(currentRect);
		}

		function destroy() {
			Tools.each(dragHelpers, function(helper) {
				helper.destroy();
			});

			dragHelpers = [];
		}

		render(containerElm);

		instance = Tools.extend({
			toggleVisibility: toggleVisibility,
			setClampRect: setClampRect,
			setRect: setRect,
			getInnerRect: getInnerRect,
			setInnerRect: setInnerRect,
			setViewPortRect: setViewPortRect,
			destroy: destroy
		}, Observable);

		return instance;
	};
});

/**
 * ImagePanel.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * ...
 *
 * @-x-less ImagePanel.less
 */
define("tinymce/imagetoolsplugin/ImagePanel", [
	"global!tinymce.ui.Control",
	"global!tinymce.ui.DragHelper",
	"global!tinymce.geom.Rect",
	"global!tinymce.util.Tools",
	"global!tinymce.util.Promise",
	"tinymce/imagetoolsplugin/CropRect"
], function(Control, DragHelper, Rect, Tools, Promise, CropRect) {
	function loadImage(image) {
		return new Promise(function(resolve) {
			function loaded() {
				image.removeEventListener('load', loaded);
				resolve(image);
			}

			if (image.complete) {
				resolve(image);
			} else {
				image.addEventListener('load', loaded);
			}
		});
	}

	return Control.extend({
		Defaults: {
			classes: "imagepanel"
		},

		selection: function(rect) {
			if (arguments.length) {
				this.state.set('rect', rect);
				return this;
			}

			return this.state.get('rect');
		},

		imageSize: function() {
			var viewRect = this.state.get('viewRect');

			return {
				w: viewRect.w,
				h: viewRect.h
			};
		},

		toggleCropRect: function(state) {
			this.state.set('cropEnabled', state);
		},

		imageSrc: function(url) {
			var self = this, img = new Image();

			img.src = url;

			loadImage(img).then(function() {
				var rect, $img, lastRect = self.state.get('viewRect');

				$img = self.$el.find('img');
				if ($img[0]) {
					$img.replaceWith(img);
				} else {
					var bg = document.createElement('div');
					bg.className = 'mce-imagepanel-bg';
					self.getEl().appendChild(bg);
					self.getEl().appendChild(img);
				}

				rect = {x: 0, y: 0, w: img.naturalWidth, h: img.naturalHeight};
				self.state.set('viewRect', rect);
				self.state.set('rect', Rect.inflate(rect, -20, -20));

				if (!lastRect || lastRect.w != rect.w || lastRect.h != rect.h) {
					self.zoomFit();
				}

				self.repaintImage();
				self.fire('load');
			});
		},

		zoom: function(value) {
			if (arguments.length) {
				this.state.set('zoom', value);
				return this;
			}

			return this.state.get('zoom');
		},

		postRender: function() {
			this.imageSrc(this.settings.imageSrc);
			return this._super();
		},

		zoomFit: function() {
			var self = this, $img, pw, ph, w, h, zoom, padding;

			padding = 10;
			$img = self.$el.find('img');
			pw = self.getEl().clientWidth;
			ph = self.getEl().clientHeight;
			w = $img[0].naturalWidth;
			h = $img[0].naturalHeight;
			zoom = Math.min((pw - padding) / w, (ph - padding) / h);

			if (zoom >= 1) {
				zoom = 1;
			}

			self.zoom(zoom);
		},

		repaintImage: function() {
			var x, y, w, h, pw, ph, $img, $bg, zoom, rect, elm;

			elm = this.getEl();
			zoom = this.zoom();
			rect = this.state.get('rect');
			$img = this.$el.find('img');
			$bg = this.$el.find('.mce-imagepanel-bg');
			pw = elm.offsetWidth;
			ph = elm.offsetHeight;
			w = $img[0].naturalWidth * zoom;
			h = $img[0].naturalHeight * zoom;
			x = Math.max(0, pw / 2 - w / 2);
			y = Math.max(0, ph / 2 - h / 2);

			$img.css({
				left: x,
				top: y,
				width: w,
				height: h
			});

			$bg.css({
				left: x,
				top: y,
				width: w,
				height: h
			});

			if (this.cropRect) {
				this.cropRect.setRect({
					x: rect.x * zoom + x,
					y: rect.y * zoom + y,
					w: rect.w * zoom,
					h: rect.h * zoom
				});

				this.cropRect.setClampRect({
					x: x,
					y: y,
					w: w,
					h: h
				});

				this.cropRect.setViewPortRect({
					x: 0,
					y: 0,
					w: pw,
					h: ph
				});
			}
		},

		bindStates: function() {
			var self = this;

			function setupCropRect(rect) {
				self.cropRect = new CropRect(
					rect,
					self.state.get('viewRect'),
					self.state.get('viewRect'),
					self.getEl(),
					function() {
						self.fire('crop');
					}
				);

				self.cropRect.on('updateRect', function(e) {
					var rect = e.rect, zoom = self.zoom();

					rect = {
						x: Math.round(rect.x / zoom),
						y: Math.round(rect.y / zoom),
						w: Math.round(rect.w / zoom),
						h: Math.round(rect.h / zoom)
					};

					self.state.set('rect', rect);
				});

				self.on('remove', self.cropRect.destroy);
			}

			self.state.on('change:cropEnabled', function(e) {
				self.cropRect.toggleVisibility(e.value);
				self.repaintImage();
			});

			self.state.on('change:zoom', function() {
				self.repaintImage();
			});

			self.state.on('change:rect', function(e) {
				var rect = e.value;

				if (!self.cropRect) {
					setupCropRect(rect);
				}

				self.cropRect.setRect(rect);
			});
		}
	});
});

/**
 * UndoStack.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce/imagetoolsplugin/UndoStack", [
], function() {
	return function() {
		var data = [], index = -1;

		function add(state) {
			var removed;

			removed = data.splice(++index);
			data.push(state);

			return {
				state: state,
				removed: removed
			};
		}

		function undo() {
			if (canUndo()) {
				return data[--index];
			}
		}

		function redo() {
			if (canRedo()) {
				return data[++index];
			}
		}

		function canUndo() {
			return index > 0;
		}

		function canRedo() {
			return index != -1 && index < data.length - 1;
		}

		return {
			data: data,
			add: add,
			undo: undo,
			redo: redo,
			canUndo: canUndo,
			canRedo: canRedo
		};
	};
});

/**
 * Dialog.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * ...
 */
define("tinymce/imagetoolsplugin/Dialog", [
	"global!tinymce.dom.DOMUtils",
	"global!tinymce.util.Tools",
	"global!tinymce.util.Promise",
	"global!tinymce.ui.Factory",
	"global!tinymce.ui.Form",
	"global!tinymce.ui.Container",
	"tinymce/imagetoolsplugin/ImagePanel",
	"ephox/imagetools/api/ImageTransformations",
	"ephox/imagetools/api/BlobConversions",
	"tinymce/imagetoolsplugin/UndoStack"
], function(DOMUtils, Tools, Promise, Factory, Form, Container, ImagePanel, ImageTransformations, BlobConversions, UndoStack) {
	function createState(blob) {
		return {
			blob: blob,
			url: URL.createObjectURL(blob)
		};
	}

	function destroyState(state) {
		if (state) {
			URL.revokeObjectURL(state.url);
		}
	}

	function destroyStates(states) {
		Tools.each(states, destroyState);
	}

	function open(currentState, resolve, reject) {
		var win, undoStack = new UndoStack(), mainPanel, filtersPanel, tempState,
			cropPanel, resizePanel, flipRotatePanel, imagePanel, sidePanel, mainViewContainer,
			invertPanel, brightnessPanel, huePanel, saturatePanel, contrastPanel, grayscalePanel,
			sepiaPanel, colorizePanel, sharpenPanel, embossPanel, gammaPanel, exposurePanel, panels,
			width, height, ratioW, ratioH;

		function recalcSize(e) {
			var widthCtrl, heightCtrl, newWidth, newHeight;

			widthCtrl = win.find('#w')[0];
			heightCtrl = win.find('#h')[0];

			newWidth = parseInt(widthCtrl.value(), 10);
			newHeight = parseInt(heightCtrl.value(), 10);

			if (win.find('#constrain')[0].checked() && width && height && newWidth && newHeight) {
				if (e.control.settings.name == 'w') {
					newHeight = Math.round(newWidth * ratioW);
					heightCtrl.value(newHeight);
				} else {
					newWidth = Math.round(newHeight * ratioH);
					widthCtrl.value(newWidth);
				}
			}

			width = newWidth;
			height = newHeight;
		}

		function floatToPercent(value) {
			return Math.round(value * 100) + '%';
		}

		function updateButtonUndoStates() {
			win.find('#undo').disabled(!undoStack.canUndo());
			win.find('#redo').disabled(!undoStack.canRedo());
			win.statusbar.find('#save').disabled(!undoStack.canUndo());
		}

		function disableUndoRedo() {
			win.find('#undo').disabled(true);
			win.find('#redo').disabled(true);
		}

		function displayState(state) {
			if (state) {
				imagePanel.imageSrc(state.url);
			}
		}

		function switchPanel(targetPanel) {
			return function() {
				var hidePanels = Tools.grep(panels, function(panel) {
					return panel.settings.name != targetPanel;
				});

				Tools.each(hidePanels, function(panel) {
					panel.hide();
				});

				targetPanel.show();
				targetPanel.focus();
			};
		}

		function addTempState(blob) {
			tempState = createState(blob);
			displayState(tempState);
		}

		function addBlobState(blob) {
			currentState = createState(blob);
			displayState(currentState);
			destroyStates(undoStack.add(currentState).removed);
			updateButtonUndoStates();
		}

		function crop() {
			var rect = imagePanel.selection();

			ImageTransformations.crop(currentState.blob, rect.x, rect.y, rect.w, rect.h).then(function(blob) {
				addBlobState(blob);
				cancel();
			});
		}

		function tempAction(fn) {
			var args = [].slice.call(arguments, 1);

			return function() {
				var state = tempState || currentState;

				fn.apply(this, [state.blob].concat(args)).then(addTempState);
			};
		}

		function action(fn) {
			var args = [].slice.call(arguments, 1);

			return function() {
				fn.apply(this, [currentState.blob].concat(args)).then(addBlobState);
			};
		}

		function cancel() {
			displayState(currentState);
			destroyState(tempState);
			switchPanel(mainPanel)();
			updateButtonUndoStates();
		}

		function applyTempState() {
			if (tempState) {
				addBlobState(tempState.blob);
				cancel();
			}
		}

		function zoomIn() {
			var zoom = imagePanel.zoom();

			if (zoom < 2) {
				zoom += 0.1;
			}

			imagePanel.zoom(zoom);
		}

		function zoomOut() {
			var zoom = imagePanel.zoom();

			if (zoom > 0.1) {
				zoom -= 0.1;
			}

			imagePanel.zoom(zoom);
		}

		function undo() {
			currentState = undoStack.undo();
			displayState(currentState);
			updateButtonUndoStates();
		}

		function redo() {
			currentState = undoStack.redo();
			displayState(currentState);
			updateButtonUndoStates();
		}

		function save() {
			resolve(currentState.blob);
			win.close();
		}

		function createPanel(items) {
			return new Form({
				layout: 'flex',
				direction: 'row',
				labelGap: 5,
				border: '0 0 1 0',
				align: 'center',
				pack: 'center',
				padding: '0 10 0 10',
				spacing: 5,
				flex: 0,
				minHeight: 60,
				defaults: {
					classes: 'imagetool',
					type: 'button'
				},
				items: items
			});
		}

		function createFilterPanel(title, filter) {
			return createPanel([
				{text: 'Back', onclick: cancel},
				{type: 'spacer', flex: 1},
				{text: 'Apply', subtype: 'primary', onclick: applyTempState}
			]).hide().on('show', function() {
				disableUndoRedo();

				filter(currentState.blob).then(function(blob) {
					var newTempState = createState(blob);

					displayState(newTempState);
					destroyState(tempState);
					tempState = newTempState;
				});
			});
		}

		function createVariableFilterPanel(title, filter, value, min, max) {
			function update(value) {
				filter(currentState.blob, value).then(function(blob) {
					var newTempState = createState(blob);
					displayState(newTempState);
					destroyState(tempState);
					tempState = newTempState;
				});
			}

			return createPanel([
				{text: 'Back', onclick: cancel},
				{type: 'spacer', flex: 1},
				{
					type: 'slider',
					flex: 1,
					ondragend: function(e) {
						update(e.value);
					},
					minValue: min,
					maxValue: max,
					value: value,
					previewFilter: floatToPercent
				},
				{type: 'spacer', flex: 1},
				{text: 'Apply', subtype: 'primary', onclick: applyTempState}
			]).hide().on('show', function() {
				this.find('slider').value(value);
				disableUndoRedo();
			});
		}

		function createRgbFilterPanel(title, filter) {
			function update() {
				var r, g, b;

				r = win.find('#r')[0].value();
				g = win.find('#g')[0].value();
				b = win.find('#b')[0].value();

				filter(currentState.blob, r, g, b).then(function(blob) {
					var newTempState = createState(blob);
					displayState(newTempState);
					destroyState(tempState);
					tempState = newTempState;
				});
			}

			return createPanel([
				{text: 'Back', onclick: cancel},
				{type: 'spacer', flex: 1},
				{
					type: 'slider', label: 'R', name: 'r', minValue: 0,
					value: 1, maxValue: 2, ondragend: update, previewFilter: floatToPercent
				},
				{
					type: 'slider', label: 'G', name: 'g', minValue: 0,
					value: 1, maxValue: 2, ondragend: update, previewFilter: floatToPercent
				},
				{
					type: 'slider', label: 'B', name: 'b', minValue: 0,
					value: 1, maxValue: 2, ondragend: update, previewFilter: floatToPercent
				},
				{type: 'spacer', flex: 1},
				{text: 'Apply', subtype: 'primary', onclick: applyTempState}
			]).hide().on('show', function() {
				win.find('#r,#g,#b').value(1);
				disableUndoRedo();
			});
		}

		cropPanel = createPanel([
			{text: 'Back', onclick: cancel},
			{type: 'spacer', flex: 1},
			{text: 'Apply', subtype: 'primary', onclick: crop}
		]).hide().on('show hide', function(e) {
			imagePanel.toggleCropRect(e.type == 'show');
		}).on('show', disableUndoRedo);

		function toggleConstrain(e) {
			if (e.control.value() === true) {
				ratioW = height / width;
				ratioH = width / height;
			}
		}

		resizePanel = createPanel([
			{text: 'Back', onclick: cancel},
			{type: 'spacer', flex: 1},
			{type: 'textbox', name: 'w', label: 'Width', size: 4, onkeyup: recalcSize},
			{type: 'textbox', name: 'h', label: 'Height', size: 4, onkeyup: recalcSize},
			{type: 'checkbox', name: 'constrain', text: 'Constrain proportions', checked: true, onchange: toggleConstrain},
			{type: 'spacer', flex: 1},
			{text: 'Apply', subtype: 'primary', onclick: 'submit'}
		]).hide().on('submit', function(e) {
			var width = parseInt(win.find('#w').value(), 10),
				height = parseInt(win.find('#h').value(), 10);

			e.preventDefault();

			action(ImageTransformations.resize, width, height)();
			cancel();
		}).on('show', disableUndoRedo);

		flipRotatePanel = createPanel([
			{text: 'Back', onclick: cancel},
			{type: 'spacer', flex: 1},
			{icon: 'fliph', tooltip: 'Flip horizontally', onclick: tempAction(ImageTransformations.flip, 'h')},
			{icon: 'flipv', tooltip: 'Flip vertically', onclick: tempAction(ImageTransformations.flip, 'v')},
			{icon: 'rotateleft', tooltip: 'Rotate counterclockwise', onclick: tempAction(ImageTransformations.rotate, -90)},
			{icon: 'rotateright', tooltip: 'Rotate clockwise', onclick: tempAction(ImageTransformations.rotate, 90)},
			{type: 'spacer', flex: 1},
			{text: 'Apply', subtype: 'primary', onclick: applyTempState}
		]).hide().on('show', disableUndoRedo);

		invertPanel = createFilterPanel("Invert", ImageTransformations.invert);
		sharpenPanel = createFilterPanel("Sharpen", ImageTransformations.sharpen);
		embossPanel = createFilterPanel("Emboss", ImageTransformations.emboss);

		brightnessPanel = createVariableFilterPanel("Brightness", ImageTransformations.brightness, 0, -1, 1);
		huePanel = createVariableFilterPanel("Hue", ImageTransformations.hue, 180, 0, 360);
		saturatePanel = createVariableFilterPanel("Saturate", ImageTransformations.saturate, 0, -1, 1);
		contrastPanel = createVariableFilterPanel("Contrast", ImageTransformations.contrast, 0, -1, 1);
		grayscalePanel = createVariableFilterPanel("Grayscale", ImageTransformations.grayscale, 0, 0, 1);
		sepiaPanel = createVariableFilterPanel("Sepia", ImageTransformations.sepia, 0, 0, 1);
		colorizePanel = createRgbFilterPanel("Colorize", ImageTransformations.colorize);
		gammaPanel = createVariableFilterPanel("Gamma", ImageTransformations.gamma, 0, -1, 1);
		exposurePanel = createVariableFilterPanel("Exposure", ImageTransformations.exposure, 1, 0, 2);

		filtersPanel = createPanel([
			{text: 'Back', onclick: cancel},
			{type: 'spacer', flex: 1},
			{text: 'hue', icon: 'hue', onclick: switchPanel(huePanel)},
			{text: 'saturate', icon: 'saturate', onclick: switchPanel(saturatePanel)},
			{text: 'sepia', icon: 'sepia', onclick: switchPanel(sepiaPanel)},
			{text: 'emboss', icon: 'emboss', onclick: switchPanel(embossPanel)},
			{text: 'exposure', icon: 'exposure', onclick: switchPanel(exposurePanel)},
			{type: 'spacer', flex: 1}
		]).hide();

		mainPanel = createPanel([
			{tooltip: 'Crop', icon: 'crop', onclick: switchPanel(cropPanel)},
			{tooltip: 'Resize', icon: 'resize2', onclick: switchPanel(resizePanel)},
			{tooltip: 'Orientation', icon: 'orientation', onclick: switchPanel(flipRotatePanel)},
			{tooltip: 'Brightness', icon: 'sun', onclick: switchPanel(brightnessPanel)},
			{tooltip: 'Sharpen', icon: 'sharpen', onclick: switchPanel(sharpenPanel)},
			{tooltip: 'Contrast', icon: 'contrast', onclick: switchPanel(contrastPanel)},
			{tooltip: 'Color levels', icon: 'drop', onclick: switchPanel(colorizePanel)},
			{tooltip: 'Gamma', icon: 'gamma', onclick: switchPanel(gammaPanel)},
			{tooltip: 'Invert', icon: 'invert', onclick: switchPanel(invertPanel)}
			//{text: 'More', onclick: switchPanel(filtersPanel)}
		]);

		imagePanel = new ImagePanel({
			flex: 1,
			imageSrc: currentState.url
		});

		sidePanel = new Container({
			layout: 'flex',
			direction: 'column',
			border: '0 1 0 0',
			padding: 5,
			spacing: 5,
			items: [
				{type: 'button', icon: 'undo', tooltip: 'Undo', name: 'undo', onclick: undo},
				{type: 'button', icon: 'redo', tooltip: 'Redo', name: 'redo', onclick: redo},
				{type: 'button', icon: 'zoomin', tooltip: 'Zoom in', onclick: zoomIn},
				{type: 'button', icon: 'zoomout', tooltip: 'Zoom out', onclick: zoomOut}
			]
		});

		mainViewContainer = new Container({
			type: 'container',
			layout: 'flex',
			direction: 'row',
			align: 'stretch',
			flex: 1,
			items: [sidePanel, imagePanel]
		});

		panels = [
			mainPanel,
			cropPanel,
			resizePanel,
			flipRotatePanel,
			filtersPanel,
			invertPanel,
			brightnessPanel,
			huePanel,
			saturatePanel,
			contrastPanel,
			grayscalePanel,
			sepiaPanel,
			colorizePanel,
			sharpenPanel,
			embossPanel,
			gammaPanel,
			exposurePanel
		];

		win = Factory.create('window', {
			layout: 'flex',
			direction: 'column',
			align: 'stretch',
			minWidth: Math.min(DOMUtils.DOM.getViewPort().w, 800),
			minHeight: Math.min(DOMUtils.DOM.getViewPort().h, 650),
			title: 'Edit image',
			items: panels.concat([mainViewContainer]),
			buttons: [
				{text: 'Save', name: 'save', subtype: 'primary', onclick: save},
				{text: 'Cancel', onclick: 'close'}
			]
		});

		win.renderTo(document.body).reflow();

		win.on('close', function() {
			reject();
			destroyStates(undoStack.data);
			undoStack = null;
			tempState = null;
		});

		undoStack.add(currentState);
		updateButtonUndoStates();

		imagePanel.on('load', function() {
			width = imagePanel.imageSize().w;
			height = imagePanel.imageSize().h;
			ratioW = height / width;
			ratioH = width / height;

			win.find('#w').value(width);
			win.find('#h').value(height);
		});

		imagePanel.on('crop', crop);
	}

	function edit(blob) {
		return new Promise(function(resolve, reject) {
			open(createState(blob), resolve, reject);
		});
	}

	//edit('img/dogleft.jpg');

	return {
		edit: edit
	};
});

/**
 * ImageSize.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce/imagetoolsplugin/ImageSize", [
], function() {
	function getImageSize(img) {
		var width, height;

		function isPxValue(value) {
			return /^[0-9\.]+px$/.test(value);
		}

		width = img.style.width;
		height = img.style.height;
		if (width || height) {
			if (isPxValue(width) && isPxValue(height)) {
				return {
					w: parseInt(width, 10),
					h: parseInt(height, 10)
				};
			}

			return null;
		}

		width = img.width;
		height = img.height;

		if (width && height) {
			return {
				w: parseInt(width, 10),
				h: parseInt(height, 10)
			};
		}

		return null;
	}

	function setImageSize(img, size) {
		var width, height;

		if (size) {
			width = img.style.width;
			height = img.style.height;

			if (width || height) {
				img.style.width = size.w + 'px';
				img.style.height = size.h + 'px';
				img.removeAttribute('data-mce-style');
			}

			width = img.width;
			height = img.height;

			if (width || height) {
				img.setAttribute('width', size.w);
				img.setAttribute('height', size.h);
			}
		}
	}

	function getNaturalImageSize(img) {
		return {
			w: img.naturalWidth,
			h: img.naturalHeight
		};
	}

	return {
		getImageSize: getImageSize,
		setImageSize: setImageSize,
		getNaturalImageSize: getNaturalImageSize
	};
});

/**
 * Utils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce/imagetoolsplugin/Utils", [
	"global!tinymce.util.Promise",
	"global!tinymce.util.Tools"
], function(Promise, Tools) {
	var isValue = function (obj) {
		return obj !== null && obj !== undefined;
	};

	var traverse = function (json, path) {
		var value;

		value = path.reduce(function(result, key) {
			return isValue(result) ? result[key] : undefined;
		}, json);

		return isValue(value) ? value : null;
	};

	var requestUrlAsBlob = function (url, headers) {
		return new Promise(function(resolve) {
			var xhr;

			xhr = new XMLHttpRequest();

			xhr.onreadystatechange = function () {
				if (xhr.readyState === 4) {
					resolve({
						status: xhr.status,
						blob: this.response
					});
				}
			};

			xhr.open('GET', url, true);

			Tools.each(headers, function (value, key) {
				xhr.setRequestHeader(key, value);
			});

			xhr.responseType = 'blob';
			xhr.send();
		});
	};

	var readBlob = function (blob) {
		return new Promise(function(resolve) {
			var fr = new FileReader();

			fr.onload = function (e) {
				var data = e.target;
				resolve(data.result);
			};

			fr.readAsText(blob);
		});
	};

	var parseJson = function (text) {
		var json;

		try {
			json = JSON.parse(text);
		} catch (ex) {
			// Ignore
		}

		return json;
	};

	return {
		traverse: traverse,
		readBlob: readBlob,
		requestUrlAsBlob: requestUrlAsBlob,
		parseJson: parseJson
	};
});

/**
 * Proxy.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Handles loading images though a proxy for working around cors.
 */
define("tinymce/imagetoolsplugin/Proxy", [
	"global!tinymce.util.Promise",
	"global!tinymce.util.Tools",
	"tinymce/imagetoolsplugin/Utils"
], function(Promise, Tools, Utils) {
	var isServiceErrorCode = function (code) {
		return code === 400 || code === 403 || code === 500;
	};

	var handleHttpError = function (status) {
		return Promise.reject("ImageProxy HTTP error: " + status);
	};

	var proxyServiceError = function (error) {
		Promise.reject("ImageProxy Service error: " + error);
	};

	var handleServiceError = function (status, blob) {
		return Utils.readBlob(blob).then(function(text) {
			var serviceError = Utils.parseJson(text);
			var errorType = Utils.traverse(serviceError, ['error', 'type']);
			return errorType ? proxyServiceError(errorType) : proxyServiceError('Invalid JSON');
		});
	};

	var handleServiceErrorResponse = function (status, blob) {
		return isServiceErrorCode(status) ? handleServiceError(status, blob) : handleHttpError(status);
	};

	var requestServiceBlob = function (url, apiKey) {
		return Utils.requestUrlAsBlob(url, {
			'Content-Type': 'application/json;charset=UTF-8',
			'tiny-api-key': apiKey
		}).then(function (result) {
			return result.status >= 400 ? handleServiceErrorResponse(result.status, result.blob) : Promise.resolve(result.blob);
		});
	};

	function requestBlob(url) {
		return Utils.requestUrlAsBlob(url, {}).then(function (result) {
			return result.status >= 400 ? handleHttpError(result.status) : Promise.resolve(result.blob);
		});
	}

	var getUrl = function (url, apiKey) {
		return apiKey ? requestServiceBlob(url, apiKey) : requestBlob(url);
	};

	return {
		getUrl: getUrl
	};
});

/**
 * Plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 *
 * Settings:
 *  imagetools_cors_hosts - Array of remote domains that has CORS setup.
 *  imagetools_proxy - Url to proxy that streams images from remote host to local host.
 *  imagetools_toolbar - Toolbar items to render when an editable image is selected.
 */
define("tinymce/imagetoolsplugin/Plugin", [
	"global!tinymce.PluginManager",
	"global!tinymce.Env",
	"global!tinymce.util.Promise",
	"global!tinymce.util.URI",
	"global!tinymce.util.Tools",
	"global!tinymce.util.Delay",
	"ephox/imagetools/api/ImageTransformations",
	"ephox/imagetools/api/BlobConversions",
	"tinymce/imagetoolsplugin/Dialog",
	"tinymce/imagetoolsplugin/ImageSize",
	"tinymce/imagetoolsplugin/Proxy"
], function(PluginManager, Env, Promise, URI, Tools, Delay, ImageTransformations, BlobConversions, Dialog, ImageSize, Proxy) {
	var plugin = function(editor) {
		var count = 0, imageUploadTimer, lastSelectedImage;

		if (!Env.fileApi) {
			return;
		}

		function displayError(error) {
			editor.notificationManager.open({
				text: error,
				type: 'error'
			});
		}

		function getSelectedImage() {
			return editor.selection.getNode();
		}

		function extractFilename(url) {
			var m = url.match(/\/([^\/\?]+)?\.(?:jpeg|jpg|png|gif)(?:\?|$)/i);
			if (m) {
				return editor.dom.encode(m[1]);
			}
			return null;
		}

		function createId() {
			return 'imagetools' + count++;
		}

		function isLocalImage(img) {
			var url = img.src;

			return url.indexOf('data:') === 0 || url.indexOf('blob:') === 0 || new URI(url).host === editor.documentBaseURI.host;
		}

		function isCorsImage(img) {
			return Tools.inArray(editor.settings.imagetools_cors_hosts, new URI(img.src).host) !== -1;
		}

		function getApiKey() {
			return editor.settings.api_key || editor.settings.imagetools_api_key;
		}

		function imageToBlob(img) {
			var src = img.src, apiKey;

			if (isCorsImage(img)) {
				return Proxy.getUrl(img.src, null);
			}

			if (!isLocalImage(img)) {
				src = editor.settings.imagetools_proxy;
				src += (src.indexOf('?') === -1 ? '?' : '&') + 'url=' + encodeURIComponent(img.src);
				apiKey = getApiKey();
				return Proxy.getUrl(src, apiKey);
			}

			return BlobConversions.imageToBlob(img);
		}

		function findSelectedBlob() {
			var blobInfo;

			blobInfo = editor.editorUpload.blobCache.getByUri(getSelectedImage().src);
			if (blobInfo) {
				return blobInfo.blob();
			}

			return imageToBlob(getSelectedImage());
		}

		function startTimedUpload() {
			imageUploadTimer = Delay.setEditorTimeout(editor, function() {
				editor.editorUpload.uploadImagesAuto();
			}, editor.settings.images_upload_timeout || 30000);
		}

		function cancelTimedUpload() {
			clearTimeout(imageUploadTimer);
		}

		function updateSelectedImage(blob, uploadImmediately) {
			return BlobConversions.blobToDataUri(blob).then(function(dataUri) {
				var id, filename, base64, blobCache, blobInfo, selectedImage;

				selectedImage = getSelectedImage();
				blobCache = editor.editorUpload.blobCache;
				blobInfo = blobCache.getByUri(selectedImage.src);
				base64 = URI.parseDataUri(dataUri).data;
				id = createId();
				if (editor.settings.images_reuse_filename) {
					filename = blobInfo ? blobInfo.filename() : extractFilename(selectedImage.src);
				}
				blobInfo = blobCache.create(id, blob, base64, filename);
				blobCache.add(blobInfo);

				editor.undoManager.transact(function() {
					function imageLoadedHandler() {
						editor.$(selectedImage).off('load', imageLoadedHandler);
						editor.nodeChanged();

						if (uploadImmediately) {
							editor.editorUpload.uploadImagesAuto();
						} else {
							cancelTimedUpload();
							startTimedUpload();
						}
					}

					editor.$(selectedImage).on('load', imageLoadedHandler);

					editor.$(selectedImage).attr({
						src: blobInfo.blobUri()
					}).removeAttr('data-mce-src');
				});

				return blobInfo;
			});
		}

		function selectedImageOperation(fn) {
			return function() {
				return editor._scanForImages().then(findSelectedBlob).then(fn).then(updateSelectedImage, displayError);
			};
		}

		function rotate(angle) {
			return function() {
				return selectedImageOperation(function(blob) {
					var size = ImageSize.getImageSize(getSelectedImage());

					if (size) {
						ImageSize.setImageSize(getSelectedImage(), {
							w: size.h,
							h: size.w
						});
					}

					return ImageTransformations.rotate(blob, angle);
				})();
			};
		}

		function flip(axis) {
			return function() {
				return selectedImageOperation(function(blob) {
					return ImageTransformations.flip(blob, axis);
				})();
			};
		}

		function editImageDialog() {
			var img = getSelectedImage(), originalSize = ImageSize.getNaturalImageSize(img);
			var handleDialogBlob = function(blob) {
				return new Promise(function(resolve) {
					BlobConversions.blobToImage(blob).then(function(newImage) {
						var newSize = ImageSize.getNaturalImageSize(newImage);

						if (originalSize.w != newSize.w || originalSize.h != newSize.h) {
							if (ImageSize.getImageSize(img)) {
								ImageSize.setImageSize(img, newSize);
							}
						}

						URL.revokeObjectURL(newImage.src);
						resolve(blob);
					});
				});
			};

			var openDialog = function (blob) {
				return Dialog.edit(blob).then(handleDialogBlob).then(function(blob) {
					updateSelectedImage(blob, true);
				}, function () {
					// Close dialog
				});
			};

			if (img) {
				imageToBlob(img).then(openDialog, displayError);
			}
		}

		function addButtons() {
			editor.addButton('rotateleft', {
				title: 'Rotate counterclockwise',
				cmd: 'mceImageRotateLeft'
			});

			editor.addButton('rotateright', {
				title: 'Rotate clockwise',
				cmd: 'mceImageRotateRight'
			});

			editor.addButton('flipv', {
				title: 'Flip vertically',
				cmd: 'mceImageFlipVertical'
			});

			editor.addButton('fliph', {
				title: 'Flip horizontally',
				cmd: 'mceImageFlipHorizontal'
			});

			editor.addButton('editimage', {
				title: 'Edit image',
				cmd: 'mceEditImage'
			});

			editor.addButton('imageoptions', {
				title: 'Image options',
				icon: 'options',
				cmd: 'mceImage'
			});

			/*
			editor.addButton('crop', {
				title: 'Crop',
				onclick: startCrop
			});
			*/
		}

		function addEvents() {
			editor.on('NodeChange', function(e) {
				//If the last node we selected was an image
				//And had a source that doesn't match the current blob url
				//We need to attempt to upload it
				if (lastSelectedImage && lastSelectedImage.src != e.element.src) {
					cancelTimedUpload();
					editor.editorUpload.uploadImagesAuto();
					lastSelectedImage = undefined;
				}

				//Set up the lastSelectedImage
				if (isEditableImage(e.element)) {
					lastSelectedImage = e.element;
				}
			});
		}

		function isEditableImage(img) {
			var selectorMatched = editor.dom.is(img, 'img:not([data-mce-object],[data-mce-placeholder])');

			return selectorMatched && (isLocalImage(img) || isCorsImage(img) || editor.settings.imagetools_proxy);
		}

		function addToolbars() {
			var toolbarItems = editor.settings.imagetools_toolbar;

			if (!toolbarItems) {
				toolbarItems = 'rotateleft rotateright | flipv fliph | crop editimage imageoptions';
			}

			editor.addContextToolbar(
				isEditableImage,
				toolbarItems
			);
		}

		Tools.each({
			mceImageRotateLeft: rotate(-90),
			mceImageRotateRight: rotate(90),
			mceImageFlipVertical: flip('v'),
			mceImageFlipHorizontal: flip('h'),
			mceEditImage: editImageDialog
		}, function(fn, cmd) {
			editor.addCommand(cmd, fn);
		});

		addButtons();
		addToolbars();
		addEvents();
	};

	PluginManager.add('imagetools', plugin);

	return function() {};
});

dem('tinymce/imagetoolsplugin/Plugin')();
})();

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('insertdatetime', function(editor) {
	var daysShort = "Sun Mon Tue Wed Thu Fri Sat Sun".split(' ');
	var daysLong = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday".split(' ');
	var monthsShort = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(' ');
	var monthsLong = "January February March April May June July August September October November December".split(' ');
	var menuItems = [], lastFormat, defaultButtonTimeFormat;

	function getDateTime(fmt, date) {
		function addZeros(value, len) {
			value = "" + value;

			if (value.length < len) {
				for (var i = 0; i < (len - value.length); i++) {
					value = "0" + value;
				}
			}

			return value;
		}

		date = date || new Date();

		fmt = fmt.replace("%D", "%m/%d/%Y");
		fmt = fmt.replace("%r", "%I:%M:%S %p");
		fmt = fmt.replace("%Y", "" + date.getFullYear());
		fmt = fmt.replace("%y", "" + date.getYear());
		fmt = fmt.replace("%m", addZeros(date.getMonth() + 1, 2));
		fmt = fmt.replace("%d", addZeros(date.getDate(), 2));
		fmt = fmt.replace("%H", "" + addZeros(date.getHours(), 2));
		fmt = fmt.replace("%M", "" + addZeros(date.getMinutes(), 2));
		fmt = fmt.replace("%S", "" + addZeros(date.getSeconds(), 2));
		fmt = fmt.replace("%I", "" + ((date.getHours() + 11) % 12 + 1));
		fmt = fmt.replace("%p", "" + (date.getHours() < 12 ? "AM" : "PM"));
		fmt = fmt.replace("%B", "" + editor.translate(monthsLong[date.getMonth()]));
		fmt = fmt.replace("%b", "" + editor.translate(monthsShort[date.getMonth()]));
		fmt = fmt.replace("%A", "" + editor.translate(daysLong[date.getDay()]));
		fmt = fmt.replace("%a", "" + editor.translate(daysShort[date.getDay()]));
		fmt = fmt.replace("%%", "%");

		return fmt;
	}

	function insertDateTime(format) {
		var html = getDateTime(format);

		if (editor.settings.insertdatetime_element) {
			var computerTime;

			if (/%[HMSIp]/.test(format)) {
				computerTime = getDateTime("%Y-%m-%dT%H:%M");
			} else {
				computerTime = getDateTime("%Y-%m-%d");
			}

			html = '<time datetime="' + computerTime + '">' + html + '</time>';

			var timeElm = editor.dom.getParent(editor.selection.getStart(), 'time');
			if (timeElm) {
				editor.dom.setOuterHTML(timeElm, html);
				return;
			}
		}

		editor.insertContent(html);
	}

	editor.addCommand('mceInsertDate', function() {
		insertDateTime(editor.getParam("insertdatetime_dateformat", editor.translate("%Y-%m-%d")));
	});

	editor.addCommand('mceInsertTime', function() {
		insertDateTime(editor.getParam("insertdatetime_timeformat", editor.translate('%H:%M:%S')));
	});

	editor.addButton('insertdatetime', {
		type: 'splitbutton',
		title: 'Insert date/time',
		onclick: function() {
			insertDateTime(lastFormat || defaultButtonTimeFormat);
		},
		menu: menuItems
	});

	tinymce.each(editor.settings.insertdatetime_formats || [
		"%H:%M:%S",
		"%Y-%m-%d",
		"%I:%M:%S %p",
		"%D"
	], function(fmt) {
		if (!defaultButtonTimeFormat) {
			defaultButtonTimeFormat = fmt;
		}

		menuItems.push({
			text: getDateTime(fmt),
			onclick: function() {
				lastFormat = fmt;
				insertDateTime(fmt);
			}
		});
	});

	editor.addMenuItem('insertdatetime', {
		icon: 'date',
		text: 'Date/time',
		menu: menuItems,
		context: 'insert'
	});
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('importcss', function(editor) {
	var self = this, each = tinymce.each;

	function removeCacheSuffix(url) {
		var cacheSuffix = tinymce.Env.cacheSuffix;

		if (typeof url == 'string') {
			url = url.replace('?' + cacheSuffix, '').replace('&' + cacheSuffix, '');
		}

		return url;
	}

	function isSkinContentCss(href) {
		var settings = editor.settings, skin = settings.skin !== false ? settings.skin || 'lightgray' : false;

		if (skin) {
			var skinUrl = settings.skin_url;

			if (skinUrl) {
				skinUrl = editor.documentBaseURI.toAbsolute(skinUrl);
			} else {
				skinUrl = tinymce.baseURL + '/skins/' + skin;
			}

			return href === skinUrl + '/content' + (editor.inline ? '.inline' : '') + '.min.css';
		}

		return false;
	}

	function compileFilter(filter) {
		if (typeof filter == "string") {
			return function(value) {
				return value.indexOf(filter) !== -1;
			};
		} else if (filter instanceof RegExp) {
			return function(value) {
				return filter.test(value);
			};
		}

		return filter;
	}

	function getSelectors(doc, fileFilter) {
		var selectors = [], contentCSSUrls = {};

		function append(styleSheet, imported) {
			var href = styleSheet.href, rules;

			href = removeCacheSuffix(href);

			if (!href || !fileFilter(href, imported) || isSkinContentCss(href)) {
				return;
			}

			each(styleSheet.imports, function(styleSheet) {
				append(styleSheet, true);
			});

			try {
				rules = styleSheet.cssRules || styleSheet.rules;
			} catch (e) {
				// Firefox fails on rules to remote domain for example:
				// @import url(//fonts.googleapis.com/css?family=Pathway+Gothic+One);
			}

			each(rules, function(cssRule) {
				if (cssRule.styleSheet) {
					append(cssRule.styleSheet, true);
				} else if (cssRule.selectorText) {
					each(cssRule.selectorText.split(','), function(selector) {
						selectors.push(tinymce.trim(selector));
					});
				}
			});
		}

		each(editor.contentCSS, function(url) {
			contentCSSUrls[url] = true;
		});

		if (!fileFilter) {
			fileFilter = function(href, imported) {
				return imported || contentCSSUrls[href];
			};
		}

		try {
			each(doc.styleSheets, function(styleSheet) {
				append(styleSheet);
			});
		} finally {
			// Ignore
		}

		return selectors;
	}

	function defaultConvertSelectorToFormat(selectorText) {
		var format;

		// Parse simple element.class1, .class1
		var selector = /^(?:([a-z0-9\-_]+))?(\.[a-z0-9_\-\.]+)$/i.exec(selectorText);
		if (!selector) {
			return;
		}

		var elementName = selector[1];
		var classes = selector[2].substr(1).split('.').join(' ');
		var inlineSelectorElements = tinymce.makeMap('a,img');

		// element.class - Produce block formats
		if (selector[1]) {
			format = {
				title: selectorText
			};

			if (editor.schema.getTextBlockElements()[elementName]) {
				// Text block format ex: h1.class1
				format.block = elementName;
			} else if (editor.schema.getBlockElements()[elementName] || inlineSelectorElements[elementName.toLowerCase()]) {
				// Block elements such as table.class and special inline elements such as a.class or img.class
				format.selector = elementName;
			} else {
				// Inline format strong.class1
				format.inline = elementName;
			}
		} else if (selector[2]) {
			// .class - Produce inline span with classes
			format = {
				inline: 'span',
				title: selectorText.substr(1),
				classes: classes
			};
		}

		// Append to or override class attribute
		if (editor.settings.importcss_merge_classes !== false) {
			format.classes = classes;
		} else {
			format.attributes = {"class": classes};
		}

		return format;
	}

	function getGroupsBySelector(groups, selector) {
		return tinymce.util.Tools.grep(groups, function (group) {
			return !group.filter || group.filter(selector);
		});
	}

	function compileUserDefinedGroups(groups) {
		return tinymce.util.Tools.map(groups, function(group) {
			return tinymce.util.Tools.extend({}, group, {
				original: group,
				selectors: {},
				filter: compileFilter(group.filter),
				item: {
					text: group.title,
					menu: []
				}
			});
		});
	}

	function isExclusiveMode(editor, group) {
		// Exclusive mode can only be disabled when there are groups allowing the same style to be present in multiple groups
		return group === null || editor.settings.importcss_exclusive !== false;
	}

	function isUniqueSelector(selector, group, globallyUniqueSelectors) {
		return !(isExclusiveMode(editor, group) ? selector in globallyUniqueSelectors : selector in group.selectors);
	}

	function markUniqueSelector(selector, group, globallyUniqueSelectors) {
		if (isExclusiveMode(editor, group)) {
			globallyUniqueSelectors[selector] = true;
		} else {
			group.selectors[selector] = true;
		}
	}

	function convertSelectorToFormat(plugin, selector, group) {
		var selectorConverter, settings = editor.settings;

		if (group && group.selector_converter) {
			selectorConverter = group.selector_converter;
		} else if (settings.importcss_selector_converter) {
			selectorConverter = settings.importcss_selector_converter;
		} else {
			selectorConverter = defaultConvertSelectorToFormat;
		}

		return selectorConverter.call(plugin, selector, group);
	}

	editor.on('renderFormatsMenu', function(e) {
		var settings = editor.settings, globallyUniqueSelectors = {};
		var selectorFilter = compileFilter(settings.importcss_selector_filter), ctrl = e.control;
		var groups = compileUserDefinedGroups(settings.importcss_groups);

		var processSelector = function (selector, group) {
			if (isUniqueSelector(selector, group, globallyUniqueSelectors)) {
				markUniqueSelector(selector, group, globallyUniqueSelectors);

				var format = convertSelectorToFormat(self, selector, group);
				if (format) {
					var formatName = format.name || tinymce.DOM.uniqueId();
					editor.formatter.register(formatName, format);

					return tinymce.extend({}, ctrl.settings.itemDefaults, {
						text: format.title,
						format: formatName
					});
				}
			}

			return null;
		};

		if (!editor.settings.importcss_append) {
			ctrl.items().remove();
		}

		each(getSelectors(e.doc || editor.getDoc(), compileFilter(settings.importcss_file_filter)), function(selector) {
			if (selector.indexOf('.mce-') === -1) {
				if (!selectorFilter || selectorFilter(selector)) {
					var selectorGroups = getGroupsBySelector(groups, selector);

					if (selectorGroups.length > 0) {
						tinymce.util.Tools.each(selectorGroups, function (group) {
							var menuItem = processSelector(selector, group);
							if (menuItem) {
								group.item.menu.push(menuItem);
							}
						});
					} else {
						var menuItem = processSelector(selector, null);
						if (menuItem) {
							ctrl.add(menuItem);
						}
					}
				}
			}
		});

		each(groups, function(group) {
			if (group.item.menu.length > 0) {
				ctrl.add(group.item);
			}
		});

		e.control.renderNew();
	});

	// Expose default convertSelectorToFormat implementation
	self.convertSelectorToFormat = defaultConvertSelectorToFormat;
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 *
 * This plugin will force TinyMCE to produce deprecated legacy output such as font elements, u elements, align
 * attributes and so forth. There are a few cases where these old items might be needed for example in email applications or with Flash
 *
 * However you should NOT use this plugin if you are building some system that produces web contents such as a CMS. All these elements are
 * not apart of the newer specifications for HTML and XHTML.
 */

/*global tinymce:true */

(function(tinymce) {
	tinymce.PluginManager.add('legacyoutput', function(editor, url, $) {
		editor.settings.inline_styles = false;

		editor.on('init', function() {
			var alignElements = 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img',
				fontSizes = tinymce.explode(editor.settings.font_size_style_values),
				schema = editor.schema;

			// Override some internal formats to produce legacy elements and attributes
			editor.formatter.register({
				// Change alignment formats to use the deprecated align attribute
				alignleft: {selector: alignElements, attributes: {align: 'left'}},
				aligncenter: {selector: alignElements, attributes: {align: 'center'}},
				alignright: {selector: alignElements, attributes: {align: 'right'}},
				alignjustify: {selector: alignElements, attributes: {align: 'justify'}},

				// Change the basic formatting elements to use deprecated element types
				bold: [
					{inline: 'b', remove: 'all'},
					{inline: 'strong', remove: 'all'},
					{inline: 'span', styles: {fontWeight: 'bold'}}
				],
				italic: [
					{inline: 'i', remove: 'all'},
					{inline: 'em', remove: 'all'},
					{inline: 'span', styles: {fontStyle: 'italic'}}
				],
				underline: [
					{inline: 'u', remove: 'all'},
					{inline: 'span', styles: {textDecoration: 'underline'}, exact: true}
				],
				strikethrough: [
					{inline: 'strike', remove: 'all'},
					{inline: 'span', styles: {textDecoration: 'line-through'}, exact: true}
				],

				// Change font size and font family to use the deprecated font element
				fontname: {inline: 'font', attributes: {face: '%value'}},
				fontsize: {
					inline: 'font',
					attributes: {
						size: function(vars) {
							return tinymce.inArray(fontSizes, vars.value) + 1;
						}
					}
				},

				// Setup font elements for colors as well
				forecolor: {inline: 'font', attributes: {color: '%value'}},
				hilitecolor: {inline: 'font', styles: {backgroundColor: '%value'}}
			});

			// Check that deprecated elements are allowed if not add them
			tinymce.each('b,i,u,strike'.split(','), function(name) {
				schema.addValidElements(name + '[*]');
			});

			// Add font element if it's missing
			if (!schema.getElementRule("font")) {
				schema.addValidElements("font[face|size|color|style]");
			}

			// Add the missing and depreacted align attribute for the serialization engine
			tinymce.each(alignElements.split(','), function(name) {
				var rule = schema.getElementRule(name);

				if (rule) {
					if (!rule.attributes.align) {
						rule.attributes.align = {};
						rule.attributesOrder.push('align');
					}
				}
			});
		});

		editor.addButton('fontsizeselect', function() {
			var items = [], defaultFontsizeFormats = '8pt=1 10pt=2 12pt=3 14pt=4 18pt=5 24pt=6 36pt=7';
			var fontsize_formats = editor.settings.fontsize_formats || defaultFontsizeFormats;

			editor.$.each(fontsize_formats.split(' '), function(i, item) {
				var text = item, value = item;
				var values = item.split('=');

				if (values.length > 1) {
					text = values[0];
					value = values[1];
				}

				items.push({text: text, value: value});
			});

			return {
				type: 'listbox',
				text: 'Font Sizes',
				tooltip: 'Font Sizes',
				values: items,
				fixedWidth: true,
				onPostRender: function() {
					var self = this;

					editor.on('NodeChange', function() {
						var fontElm;

						fontElm = editor.dom.getParent(editor.selection.getNode(), 'font');
						if (fontElm) {
							self.value(fontElm.size);
						} else {
							self.value('');
						}
					});
				},
				onclick: function(e) {
					if (e.control.settings.value) {
						editor.execCommand('FontSize', false, e.control.settings.value);
					}
				}
			};
		});

		editor.addButton('fontselect', function() {
			function createFormats(formats) {
				formats = formats.replace(/;$/, '').split(';');

				var i = formats.length;
				while (i--) {
					formats[i] = formats[i].split('=');
				}

				return formats;
			}

			var defaultFontsFormats =
				'Andale Mono=andale mono,monospace;' +
				'Arial=arial,helvetica,sans-serif;' +
				'Arial Black=arial black,sans-serif;' +
				'Book Antiqua=book antiqua,palatino,serif;' +
				'Comic Sans MS=comic sans ms,sans-serif;' +
				'Courier New=courier new,courier,monospace;' +
				'Georgia=georgia,palatino,serif;' +
				'Helvetica=helvetica,arial,sans-serif;' +
				'Impact=impact,sans-serif;' +
				'Symbol=symbol;' +
				'Tahoma=tahoma,arial,helvetica,sans-serif;' +
				'Terminal=terminal,monaco,monospace;' +
				'Times New Roman=times new roman,times,serif;' +
				'Trebuchet MS=trebuchet ms,geneva,sans-serif;' +
				'Verdana=verdana,geneva,sans-serif;' +
				'Webdings=webdings;' +
				'Wingdings=wingdings,zapf dingbats';

			var items = [], fonts = createFormats(editor.settings.font_formats || defaultFontsFormats);

			$.each(fonts, function(i, font) {
				items.push({
					text: {raw: font[0]},
					value: font[1],
					textStyle: font[1].indexOf('dings') == -1 ? 'font-family:' + font[1] : ''
				});
			});

			return {
				type: 'listbox',
				text: 'Font Family',
				tooltip: 'Font Family',
				values: items,
				fixedWidth: true,
				onPostRender: function() {
					var self = this;

					editor.on('NodeChange', function() {
						var fontElm;

						fontElm = editor.dom.getParent(editor.selection.getNode(), 'font');
						if (fontElm) {
							self.value(fontElm.face);
						} else {
							self.value('');
						}
					});
				},
				onselect: function(e) {
					if (e.control.settings.value) {
						editor.execCommand('FontName', false, e.control.settings.value);
					}
				}
			};
		});
	});
})(tinymce);

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('link', function(editor) {
	var attachState = {};

	function isLink(elm) {
		return elm && elm.nodeName === 'A' && elm.href;
	}

	function hasLinks(elements) {
		return tinymce.util.Tools.grep(elements, isLink).length > 0;
	}

	function getLink(elm) {
		return editor.dom.getParent(elm, 'a[href]');
	}

	function getSelectedLink() {
		return getLink(editor.selection.getStart());
	}

	function getHref(elm) {
		// Returns the real href value not the resolved a.href value
		var href = elm.getAttribute('data-mce-href');
		return href ? href : elm.getAttribute('href');
	}

	function isContextMenuVisible() {
		var contextmenu = editor.plugins.contextmenu;
		return contextmenu ? contextmenu.isContextMenuVisible() : false;
	}

	var hasOnlyAltModifier = function (e) {
		return e.altKey === true && e.shiftKey === false && e.ctrlKey === false && e.metaKey === false;
	};

	function leftClickedOnAHref(elm) {
		var sel, rng, node;
		if (editor.settings.link_context_toolbar && !isContextMenuVisible() && isLink(elm)) {
			sel = editor.selection;
			rng = sel.getRng();
			node = rng.startContainer;
			// ignore cursor positions at the beginning/end (to make context toolbar less noisy)
			if (node.nodeType == 3 && sel.isCollapsed() && rng.startOffset > 0 && rng.startOffset < node.data.length) {
				return true;
			}
		}
		return false;
	}

	function appendClickRemove(link, evt) {
		document.body.appendChild(link);
		link.dispatchEvent(evt);
		document.body.removeChild(link);
	}

	function openDetachedWindow(url) {
		// Chrome and Webkit has implemented noopener and works correctly with/without popup blocker
		// Firefox has it implemented noopener but when the popup blocker is activated it doesn't work
		// Edge has only implemented noreferrer and it seems to remove opener as well
		// Older IE versions pre IE 11 falls back to a window.open approach
		if (!tinymce.Env.ie || tinymce.Env.ie > 10) {
			var link = document.createElement('a');
			link.target = '_blank';
			link.href = url;
			link.rel = 'noreferrer noopener';

			var evt = document.createEvent('MouseEvents');
			evt.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);

			appendClickRemove(link, evt);
		} else {
			var win = window.open('', '_blank');
			if (win) {
				win.opener = null;
				var doc = win.document;
				doc.open();
				doc.write('<meta http-equiv="refresh" content="0; url=' + tinymce.DOM.encode(url) + '">');
				doc.close();
			}
		}
	}

	function gotoLink(a) {
		if (a) {
			var href = getHref(a);
			if (/^#/.test(href)) {
				var targetEl = editor.$(href);
				if (targetEl.length) {
					editor.selection.scrollIntoView(targetEl[0], true);
				}
			} else {
				openDetachedWindow(a.href);
			}
		}
	}

	function gotoSelectedLink() {
		gotoLink(getSelectedLink());
	}

	function toggleViewLinkState() {
        var self = this;

		var toggleVisibility = function (e) {
			if (hasLinks(e.parents)) {
				self.show();
			} else {
				self.hide();
			}
		};

		if (!hasLinks(editor.dom.getParents(editor.selection.getStart()))) {
			self.hide();
		}

        editor.on('nodechange', toggleVisibility);

		self.on('remove', function () {
			editor.off('nodechange', toggleVisibility);
		});
	}

	function createLinkList(callback) {
		return function() {
			var linkList = editor.settings.link_list;

			if (typeof linkList == "string") {
				tinymce.util.XHR.send({
					url: linkList,
					success: function(text) {
						callback(tinymce.util.JSON.parse(text));
					}
				});
			} else if (typeof linkList == "function") {
				linkList(callback);
			} else {
				callback(linkList);
			}
		};
	}

	function buildListItems(inputList, itemCallback, startItems) {
		function appendItems(values, output) {
			output = output || [];

			tinymce.each(values, function(item) {
				var menuItem = {text: item.text || item.title};

				if (item.menu) {
					menuItem.menu = appendItems(item.menu);
				} else {
					menuItem.value = item.value;

					if (itemCallback) {
						itemCallback(menuItem);
					}
				}

				output.push(menuItem);
			});

			return output;
		}

		return appendItems(inputList, startItems || []);
	}

	function showDialog(linkList) {
		var data = {}, selection = editor.selection, dom = editor.dom, selectedElm, anchorElm, initialText;
		var win, onlyText, textListCtrl, linkListCtrl, relListCtrl, targetListCtrl, classListCtrl, linkTitleCtrl, value;

		function linkListChangeHandler(e) {
			var textCtrl = win.find('#text');

			if (!textCtrl.value() || (e.lastControl && textCtrl.value() == e.lastControl.text())) {
				textCtrl.value(e.control.text());
			}

			win.find('#href').value(e.control.value());
		}

		function buildAnchorListControl(url) {
			var anchorList = [];

			tinymce.each(editor.dom.select('a:not([href])'), function(anchor) {
				var id = anchor.name || anchor.id;

				if (id) {
					anchorList.push({
						text: id,
						value: '#' + id,
						selected: url.indexOf('#' + id) != -1
					});
				}
			});

			if (anchorList.length) {
				anchorList.unshift({text: 'None', value: ''});

				return {
					name: 'anchor',
					type: 'listbox',
					label: 'Anchors',
					values: anchorList,
					onselect: linkListChangeHandler
				};
			}
		}

		function updateText() {
			if (!initialText && data.text.length === 0 && onlyText) {
				this.parent().parent().find('#text')[0].value(this.value());
			}
		}

		function urlChange(e) {
			var meta = e.meta || {};

			if (linkListCtrl) {
				linkListCtrl.value(editor.convertURL(this.value(), 'href'));
			}

			tinymce.each(e.meta, function(value, key) {
				var inp = win.find('#' + key);

				if (key === 'text') {
					if (initialText.length === 0) {
						inp.value(value);
						data.text = value;
					}
				} else {
					inp.value(value);
				}
			});

			if (meta.attach) {
				attachState = {
					href: this.value(),
					attach: meta.attach
				};
			}

			if (!meta.text) {
				updateText.call(this);
			}
		}

		function isOnlyTextSelected(anchorElm) {
			var html = selection.getContent();

			// Partial html and not a fully selected anchor element
			if (/</.test(html) && (!/^<a [^>]+>[^<]+<\/a>$/.test(html) || html.indexOf('href=') == -1)) {
				return false;
			}

			if (anchorElm) {
				var nodes = anchorElm.childNodes, i;

				if (nodes.length === 0) {
					return false;
				}

				for (i = nodes.length - 1; i >= 0; i--) {
					if (nodes[i].nodeType != 3) {
						return false;
					}
				}
			}

			return true;
		}

		function onBeforeCall(e) {
			e.meta = win.toJSON();
		}

		selectedElm = selection.getNode();
		anchorElm = dom.getParent(selectedElm, 'a[href]');
		onlyText = isOnlyTextSelected();

		data.text = initialText = anchorElm ? (anchorElm.innerText || anchorElm.textContent) : selection.getContent({format: 'text'});
		data.href = anchorElm ? dom.getAttrib(anchorElm, 'href') : '';

		if (anchorElm) {
			data.target = dom.getAttrib(anchorElm, 'target');
		} else if (editor.settings.default_link_target) {
			data.target = editor.settings.default_link_target;
		}

		if ((value = dom.getAttrib(anchorElm, 'rel'))) {
			data.rel = value;
		}

		if ((value = dom.getAttrib(anchorElm, 'class'))) {
			data['class'] = value;
		}

		if ((value = dom.getAttrib(anchorElm, 'title'))) {
			data.title = value;
		}

		if (onlyText) {
			textListCtrl = {
				name: 'text',
				type: 'textbox',
				size: 40,
				label: 'Text to display',
				onchange: function() {
					data.text = this.value();
				}
			};
		}

		if (linkList) {
			linkListCtrl = {
				type: 'listbox',
				label: 'Link list',
				values: buildListItems(
					linkList,
					function(item) {
						item.value = editor.convertURL(item.value || item.url, 'href');
					},
					[{text: 'None', value: ''}]
				),
				onselect: linkListChangeHandler,
				value: editor.convertURL(data.href, 'href'),
				onPostRender: function() {
					/*eslint consistent-this:0*/
					linkListCtrl = this;
				}
			};
		}

		if (editor.settings.target_list !== false) {
			if (!editor.settings.target_list) {
				editor.settings.target_list = [
					{text: 'None', value: ''},
					{text: 'New window', value: '_blank'}
				];
			}

			targetListCtrl = {
				name: 'target',
				type: 'listbox',
				label: 'Target',
				values: buildListItems(editor.settings.target_list)
			};
		}

		if (editor.settings.rel_list) {
			relListCtrl = {
				name: 'rel',
				type: 'listbox',
				label: 'Rel',
				values: buildListItems(editor.settings.rel_list)
			};
		}

		if (editor.settings.link_class_list) {
			classListCtrl = {
				name: 'class',
				type: 'listbox',
				label: 'Class',
				values: buildListItems(
					editor.settings.link_class_list,
					function(item) {
						if (item.value) {
							item.textStyle = function() {
								return editor.formatter.getCssText({inline: 'a', classes: [item.value]});
							};
						}
					}
				)
			};
		}

		if (editor.settings.link_title !== false) {
			linkTitleCtrl = {
				name: 'title',
				type: 'textbox',
				label: 'Title',
				value: data.title
			};
		}

		win = editor.windowManager.open({
			title: 'Insert link',
			data: data,
			body: [
				{
					name: 'href',
					type: 'filepicker',
					filetype: 'file',
					size: 40,
					autofocus: true,
					label: 'Url',
					onchange: urlChange,
					onkeyup: updateText,
					onbeforecall: onBeforeCall
				},
				textListCtrl,
				linkTitleCtrl,
				buildAnchorListControl(data.href),
				linkListCtrl,
				relListCtrl,
				targetListCtrl,
				classListCtrl
			],
			onSubmit: function(e) {
				/*eslint dot-notation: 0*/
				var href;

				data = tinymce.extend(data, e.data);
				href = data.href;

				// Delay confirm since onSubmit will move focus
				function delayedConfirm(message, callback) {
					var rng = editor.selection.getRng();

					tinymce.util.Delay.setEditorTimeout(editor, function() {
						editor.windowManager.confirm(message, function(state) {
							editor.selection.setRng(rng);
							callback(state);
						});
					});
				}

				function toggleTargetRules(rel, isUnsafe) {
					var rules = 'noopener noreferrer';

					function addTargetRules(rel) {
						rel = removeTargetRules(rel);
						return rel ? [rel, rules].join(' ') : rules;
					}

					function removeTargetRules(rel) {
						var regExp = new RegExp('(' + rules.replace(' ', '|') + ')', 'g');
						if (rel) {
							rel = tinymce.trim(rel.replace(regExp, ''));
						}
						return rel ? rel : null;
					}

					return isUnsafe ? addTargetRules(rel) : removeTargetRules(rel);
				}

				function createLink() {
					var linkAttrs = {
						href: href,
						target: data.target ? data.target : null,
						rel: data.rel ? data.rel : null,
						"class": data["class"] ? data["class"] : null,
						title: data.title ? data.title : null
					};

					if (!editor.settings.allow_unsafe_link_target) {
						linkAttrs.rel = toggleTargetRules(linkAttrs.rel, linkAttrs.target == '_blank');
					}

					if (href === attachState.href) {
						attachState.attach();
						attachState = {};
					}

					if (anchorElm) {
						editor.focus();

						if (onlyText && data.text != initialText) {
							if ("innerText" in anchorElm) {
								anchorElm.innerText = data.text;
							} else {
								anchorElm.textContent = data.text;
							}
						}

						dom.setAttribs(anchorElm, linkAttrs);

						selection.select(anchorElm);
						editor.undoManager.add();
					} else {
						if (onlyText) {
							editor.insertContent(dom.createHTML('a', linkAttrs, dom.encode(data.text)));
						} else {
							editor.execCommand('mceInsertLink', false, linkAttrs);
						}
					}
				}

				function insertLink() {
					editor.undoManager.transact(createLink);
				}

				if (!href) {
					editor.execCommand('unlink');
					return;
				}

				// Is email and not //user@domain.com
				if (href.indexOf('@') > 0 && href.indexOf('//') == -1 && href.indexOf('mailto:') == -1) {
					delayedConfirm(
						'The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?',
						function(state) {
							if (state) {
								href = 'mailto:' + href;
							}

							insertLink();
						}
					);

					return;
				}

				// Is not protocol prefixed
				if ((editor.settings.link_assume_external_targets && !/^\w+:/i.test(href)) ||
					(!editor.settings.link_assume_external_targets && /^\s*www[\.|\d\.]/i.test(href))) {
					delayedConfirm(
						'The URL you entered seems to be an external link. Do you want to add the required http:// prefix?',
						function(state) {
							if (state) {
								href = 'http://' + href;
							}

							insertLink();
						}
					);

					return;
				}

				insertLink();
			}
		});
	}

	editor.addButton('link', {
		icon: 'link',
		tooltip: 'Insert/edit link',
		shortcut: 'Meta+K',
		onclick: createLinkList(showDialog),
		stateSelector: 'a[href]'
	});

	editor.addButton('unlink', {
		icon: 'unlink',
		tooltip: 'Remove link',
		cmd: 'unlink',
		stateSelector: 'a[href]'
	});


	if (editor.addContextToolbar) {
		editor.addButton('openlink', {
			icon: 'newtab',
			tooltip: 'Open link',
			onclick: gotoSelectedLink
		});

		editor.addContextToolbar(
			leftClickedOnAHref,
			'openlink | link unlink'
		);
	}


	editor.addShortcut('Meta+K', '', createLinkList(showDialog));
	editor.addCommand('mceLink', createLinkList(showDialog));

	editor.on('click', function (e) {
		var link = getLink(e.target);
		if (link && tinymce.util.VK.metaKeyPressed(e)) {
			e.preventDefault();
			gotoLink(link);
		}
	});

	editor.on('keydown', function (e) {
		var link = getSelectedLink();
		if (link && e.keyCode === 13 && hasOnlyAltModifier(e)) {
			e.preventDefault();
			gotoLink(link);
		}
	});

	this.showDialog = showDialog;

	editor.addMenuItem('openlink', {
		text: 'Open link',
		icon: 'newtab',
		onclick: gotoSelectedLink,
		onPostRender: toggleViewLinkState,
		prependToContext: true
	});

	editor.addMenuItem('link', {
		icon: 'link',
		text: 'Link',
		shortcut: 'Meta+K',
		onclick: createLinkList(showDialog),
		stateSelector: 'a[href]',
		context: 'insert',
		prependToContext: true
	});
});

(function () {

var defs = {}; // id -> {dependencies, definition, instance (possibly undefined)}

// Used when there is no 'main' module.
// The name is probably (hopefully) unique so minification removes for releases.
var register_3795 = function (id) {
  var module = dem(id);
  var fragments = id.split('.');
  var target = Function('return this;')();
  for (var i = 0; i < fragments.length - 1; ++i) {
    if (target[fragments[i]] === undefined)
      target[fragments[i]] = {};
    target = target[fragments[i]];
  }
  target[fragments[fragments.length - 1]] = module;
};

var instantiate = function (id) {
  var actual = defs[id];
  var dependencies = actual.deps;
  var definition = actual.defn;
  var len = dependencies.length;
  var instances = new Array(len);
  for (var i = 0; i < len; ++i)
    instances[i] = dem(dependencies[i]);
  var defResult = definition.apply(null, instances);
  if (defResult === undefined)
     throw 'module [' + id + '] returned undefined';
  actual.instance = defResult;
};

var def = function (id, dependencies, definition) {
  if (typeof id !== 'string')
    throw 'module id must be a string';
  else if (dependencies === undefined)
    throw 'no dependencies for ' + id;
  else if (definition === undefined)
    throw 'no definition function for ' + id;
  defs[id] = {
    deps: dependencies,
    defn: definition,
    instance: undefined
  };
};

var dem = function (id) {
  var actual = defs[id];
  if (actual === undefined)
    throw 'module [' + id + '] was undefined';
  else if (actual.instance === undefined)
    instantiate(id);
  return actual.instance;
};

var req = function (ids, callback) {
  var len = ids.length;
  var instances = new Array(len);
  for (var i = 0; i < len; ++i)
    instances.push(dem(ids[i]));
  callback.apply(null, callback);
};

var ephox = {};

ephox.bolt = {
  module: {
    api: {
      define: def,
      require: req,
      demand: dem
    }
  }
};

var define = def;
var require = req;
var demand = dem;
// this helps with minificiation when using a lot of global references
var defineGlobal = function (id, ref) {
  define(id, [], function () { return ref; });
};
/*jsc
["tinymce.lists.Plugin","global!tinymce.PluginManager","global!tinymce.util.Tools","global!tinymce.util.VK","tinymce.lists.core.NodeType","tinymce.lists.core.Delete","tinymce.lists.actions.Indent","tinymce.lists.actions.Outdent","tinymce.lists.actions.ToggleList","global!tinymce.dom.TreeWalker","global!tinymce.dom.RangeUtils","tinymce.lists.core.Selection","tinymce.lists.core.Bookmark","tinymce.lists.core.Range","tinymce.lists.core.NormalizeLists","global!tinymce.dom.BookmarkManager","tinymce.lists.core.SplitList","global!tinymce.dom.DOMUtils.DOM","tinymce.lists.core.TextBlock","global!tinymce.Env"]
jsc*/
defineGlobal("global!tinymce.PluginManager", tinymce.PluginManager);
defineGlobal("global!tinymce.util.Tools", tinymce.util.Tools);
defineGlobal("global!tinymce.util.VK", tinymce.util.VK);
/**
 * NodeType.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.core.NodeType", [
], function () {
	var isTextNode = function (node) {
		return node && node.nodeType === 3;
	};

	var isListNode = function (node) {
		return node && (/^(OL|UL|DL)$/).test(node.nodeName);
	};

	var isListItemNode = function (node) {
		return node && /^(LI|DT|DD)$/.test(node.nodeName);
	};

	var isBr = function (node) {
		return node && node.nodeName === 'BR';
	};

	var isFirstChild = function (node) {
		return node.parentNode.firstChild === node;
	};

	var isLastChild = function (node) {
		return node.parentNode.lastChild === node;
	};

	var isTextBlock = function (editor, node) {
		return node && !!editor.schema.getTextBlockElements()[node.nodeName];
	};

	var isBogusBr = function (dom, node) {
		if (!isBr(node)) {
			return false;
		}

		if (dom.isBlock(node.nextSibling) && !isBr(node.previousSibling)) {
			return true;
		}

		return false;
	};

	var isEmpty = function (dom, elm, keepBookmarks) {
		var empty = dom.isEmpty(elm);

		if (keepBookmarks && dom.select('span[data-mce-type=bookmark]', elm).length > 0) {
			return false;
		}

		return empty;
	};

	var isChildOfBody = function (dom, elm) {
		return dom.isChildOf(elm, dom.getRoot());
	};

	return {
		isTextNode: isTextNode,
		isListNode: isListNode,
		isListItemNode: isListItemNode,
		isBr: isBr,
		isFirstChild: isFirstChild,
		isLastChild: isLastChild,
		isTextBlock: isTextBlock,
		isBogusBr: isBogusBr,
		isEmpty: isEmpty,
		isChildOfBody: isChildOfBody
	};
});


defineGlobal("global!tinymce.dom.TreeWalker", tinymce.dom.TreeWalker);
defineGlobal("global!tinymce.dom.RangeUtils", tinymce.dom.RangeUtils);
/**
 * Selection.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.core.Selection", [
	"global!tinymce.util.Tools",
	"tinymce.lists.core.NodeType"
], function (Tools, NodeType) {
	var getSelectedListItems = function (editor) {
		return Tools.grep(editor.selection.getSelectedBlocks(), function (block) {
			return NodeType.isListItemNode(block);
		});
	};

	return {
		getSelectedListItems: getSelectedListItems
	};
});


defineGlobal("global!tinymce.dom.DOMUtils.DOM", tinymce.dom.DOMUtils.DOM);
/**
 * Range.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.core.Range", [
	"global!tinymce.dom.RangeUtils",
	"tinymce.lists.core.NodeType"
], function (RangeUtils, NodeType) {
	var getNormalizedEndPoint = function (container, offset) {
		var node = RangeUtils.getNode(container, offset);

		if (NodeType.isListItemNode(container) && NodeType.isTextNode(node)) {
			var textNodeOffset = offset >= container.childNodes.length ? node.data.length : 0;
			return {container: node, offset: textNodeOffset};
		}

		return {container: container, offset: offset};
	};

	var normalizeRange = function (rng) {
		var outRng = rng.cloneRange();

		var rangeStart = getNormalizedEndPoint(rng.startContainer, rng.startOffset);
		outRng.setStart(rangeStart.container, rangeStart.offset);

		var rangeEnd = getNormalizedEndPoint(rng.endContainer, rng.endOffset);
		outRng.setEnd(rangeEnd.container, rangeEnd.offset);

		return outRng;
	};

	return {
		getNormalizedEndPoint: getNormalizedEndPoint,
		normalizeRange: normalizeRange
	};
});


/**
 * Bookmark.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.core.Bookmark", [
	"global!tinymce.dom.DOMUtils.DOM",
	"tinymce.lists.core.NodeType",
	"tinymce.lists.core.Range"
], function (DOM, NodeType, Range) {
	/**
	 * Returns a range bookmark. This will convert indexed bookmarks into temporary span elements with
	 * index 0 so that they can be restored properly after the DOM has been modified. Text bookmarks will not have spans
	 * added to them since they can be restored after a dom operation.
	 *
	 * So this: <p><b>|</b><b>|</b></p>
	 * becomes: <p><b><span data-mce-type="bookmark">|</span></b><b data-mce-type="bookmark">|</span></b></p>
	 *
	 * @param  {DOMRange} rng DOM Range to get bookmark on.
	 * @return {Object} Bookmark object.
	 */
	var createBookmark = function (rng) {
		var bookmark = {};

		var setupEndPoint = function (start) {
			var offsetNode, container, offset;

			container = rng[start ? 'startContainer' : 'endContainer'];
			offset = rng[start ? 'startOffset' : 'endOffset'];

			if (container.nodeType === 1) {
				offsetNode = DOM.create('span', {'data-mce-type': 'bookmark'});

				if (container.hasChildNodes()) {
					offset = Math.min(offset, container.childNodes.length - 1);

					if (start) {
						container.insertBefore(offsetNode, container.childNodes[offset]);
					} else {
						DOM.insertAfter(offsetNode, container.childNodes[offset]);
					}
				} else {
					container.appendChild(offsetNode);
				}

				container = offsetNode;
				offset = 0;
			}

			bookmark[start ? 'startContainer' : 'endContainer'] = container;
			bookmark[start ? 'startOffset' : 'endOffset'] = offset;
		};

		setupEndPoint(true);

		if (!rng.collapsed) {
			setupEndPoint();
		}

		return bookmark;
	};

	var resolveBookmark = function (bookmark) {
		function restoreEndPoint (start) {
			var container, offset, node;

			var nodeIndex = function (container) {
				var node = container.parentNode.firstChild, idx = 0;

				while (node) {
					if (node === container) {
						return idx;
					}

					// Skip data-mce-type=bookmark nodes
					if (node.nodeType !== 1 || node.getAttribute('data-mce-type') !== 'bookmark') {
						idx++;
					}

					node = node.nextSibling;
				}

				return -1;
			};

			container = node = bookmark[start ? 'startContainer' : 'endContainer'];
			offset = bookmark[start ? 'startOffset' : 'endOffset'];

			if (!container) {
				return;
			}

			if (container.nodeType === 1) {
				offset = nodeIndex(container);
				container = container.parentNode;
				DOM.remove(node);
			}

			bookmark[start ? 'startContainer' : 'endContainer'] = container;
			bookmark[start ? 'startOffset' : 'endOffset'] = offset;
		}

		restoreEndPoint(true);
		restoreEndPoint();

		var rng = DOM.createRng();

		rng.setStart(bookmark.startContainer, bookmark.startOffset);

		if (bookmark.endContainer) {
			rng.setEnd(bookmark.endContainer, bookmark.endOffset);
		}

		return Range.normalizeRange(rng);
	};

	return {
		createBookmark: createBookmark,
		resolveBookmark: resolveBookmark
	};
});


/**
 * NormalizeLists.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.core.NormalizeLists", [
	"global!tinymce.dom.DOMUtils.DOM",
	"global!tinymce.util.Tools",
	"tinymce.lists.core.NodeType"
], function (DOM, Tools, NodeType) {
	var normalizeList = function (dom, ul) {
		var sibling, parentNode = ul.parentNode;

		// Move UL/OL to previous LI if it's the only child of a LI
		if (parentNode.nodeName === 'LI' && parentNode.firstChild === ul) {
			sibling = parentNode.previousSibling;
			if (sibling && sibling.nodeName === 'LI') {
				sibling.appendChild(ul);

				if (NodeType.isEmpty(dom, parentNode)) {
					DOM.remove(parentNode);
				}
			} else {
				DOM.setStyle(parentNode, 'listStyleType', 'none');
			}
		}

		// Append OL/UL to previous LI if it's in a parent OL/UL i.e. old HTML4
		if (NodeType.isListNode(parentNode)) {
			sibling = parentNode.previousSibling;
			if (sibling && sibling.nodeName === 'LI') {
				sibling.appendChild(ul);
			}
		}
	};

	var normalizeLists = function (dom, element) {
		Tools.each(Tools.grep(dom.select('ol,ul', element)), function (ul) {
			normalizeList(dom, ul);
		});
	};

	return {
		normalizeList: normalizeList,
		normalizeLists: normalizeLists
	};
});


defineGlobal("global!tinymce.dom.BookmarkManager", tinymce.dom.BookmarkManager);
defineGlobal("global!tinymce.Env", tinymce.Env);
/**
 * TextBlock.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.core.TextBlock", [
	"global!tinymce.dom.DOMUtils.DOM",
	"global!tinymce.Env"
], function (DOM, Env) {
	var createNewTextBlock = function (editor, contentNode, blockName) {
		var node, textBlock, fragment = DOM.createFragment(), hasContentNode;
		var blockElements = editor.schema.getBlockElements();

		if (editor.settings.forced_root_block) {
			blockName = blockName || editor.settings.forced_root_block;
		}

		if (blockName) {
			textBlock = DOM.create(blockName);

			if (textBlock.tagName === editor.settings.forced_root_block) {
				DOM.setAttribs(textBlock, editor.settings.forced_root_block_attrs);
			}

			fragment.appendChild(textBlock);
		}

		if (contentNode) {
			while ((node = contentNode.firstChild)) {
				var nodeName = node.nodeName;

				if (!hasContentNode && (nodeName !== 'SPAN' || node.getAttribute('data-mce-type') !== 'bookmark')) {
					hasContentNode = true;
				}

				if (blockElements[nodeName]) {
					fragment.appendChild(node);
					textBlock = null;
				} else {
					if (blockName) {
						if (!textBlock) {
							textBlock = DOM.create(blockName);
							fragment.appendChild(textBlock);
						}

						textBlock.appendChild(node);
					} else {
						fragment.appendChild(node);
					}
				}
			}
		}

		if (!editor.settings.forced_root_block) {
			fragment.appendChild(DOM.create('br'));
		} else {
			// BR is needed in empty blocks on non IE browsers
			if (!hasContentNode && (!Env.ie || Env.ie > 10)) {
				textBlock.appendChild(DOM.create('br', {'data-mce-bogus': '1'}));
			}
		}

		return fragment;
	};

	return {
		createNewTextBlock: createNewTextBlock
	};
});

/**
 * SplitList.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.core.SplitList", [
	"global!tinymce.dom.DOMUtils.DOM",
	"global!tinymce.util.Tools",
	"tinymce.lists.core.TextBlock",
	"tinymce.lists.core.NodeType"
], function (DOM, Tools, TextBlock, NodeType) {
	var splitList = function (editor, ul, li, newBlock) {
		var tmpRng, fragment, bookmarks, node;

		var removeAndKeepBookmarks = function (targetNode) {
			Tools.each(bookmarks, function (node) {
				targetNode.parentNode.insertBefore(node, li.parentNode);
			});

			DOM.remove(targetNode);
		};

		bookmarks = DOM.select('span[data-mce-type="bookmark"]', ul);
		newBlock = newBlock || TextBlock.createNewTextBlock(editor, li);
		tmpRng = DOM.createRng();
		tmpRng.setStartAfter(li);
		tmpRng.setEndAfter(ul);
		fragment = tmpRng.extractContents();

		for (node = fragment.firstChild; node; node = node.firstChild) {
			if (node.nodeName === 'LI' && editor.dom.isEmpty(node)) {
				DOM.remove(node);
				break;
			}
		}

		if (!editor.dom.isEmpty(fragment)) {
			DOM.insertAfter(fragment, ul);
		}

		DOM.insertAfter(newBlock, ul);

		if (NodeType.isEmpty(editor.dom, li.parentNode)) {
			removeAndKeepBookmarks(li.parentNode);
		}

		DOM.remove(li);

		if (NodeType.isEmpty(editor.dom, ul)) {
			DOM.remove(ul);
		}
	};

	return {
		splitList: splitList
	};
});


/**
 * Outdent.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.actions.Outdent", [
	"global!tinymce.dom.DOMUtils.DOM",
	"tinymce.lists.core.NodeType",
	"tinymce.lists.core.Bookmark",
	"tinymce.lists.core.Selection",
	"tinymce.lists.core.SplitList",
	"tinymce.lists.core.NormalizeLists",
	"tinymce.lists.core.TextBlock"
], function (DOM, NodeType, Bookmark, Selection, SplitList, NormalizeLists, TextBlock) {
	var removeEmptyLi = function (dom, li) {
		if (NodeType.isEmpty(dom, li)) {
			DOM.remove(li);
		}
	};

	var outdent = function (editor, li) {
		var ul = li.parentNode, ulParent = ul.parentNode, newBlock;

		if (ul === editor.getBody()) {
			return true;
		}

		if (li.nodeName === 'DD') {
			DOM.rename(li, 'DT');
			return true;
		}

		if (NodeType.isFirstChild(li) && NodeType.isLastChild(li)) {
			if (ulParent.nodeName === "LI") {
				DOM.insertAfter(li, ulParent);
				removeEmptyLi(editor.dom, ulParent);
				DOM.remove(ul);
			} else if (NodeType.isListNode(ulParent)) {
				DOM.remove(ul, true);
			} else {
				ulParent.insertBefore(TextBlock.createNewTextBlock(editor, li), ul);
				DOM.remove(ul);
			}

			return true;
		} else if (NodeType.isFirstChild(li)) {
			if (ulParent.nodeName === "LI") {
				DOM.insertAfter(li, ulParent);
				li.appendChild(ul);
				removeEmptyLi(editor.dom, ulParent);
			} else if (NodeType.isListNode(ulParent)) {
				ulParent.insertBefore(li, ul);
			} else {
				ulParent.insertBefore(TextBlock.createNewTextBlock(editor, li), ul);
				DOM.remove(li);
			}

			return true;
		} else if (NodeType.isLastChild(li)) {
			if (ulParent.nodeName === "LI") {
				DOM.insertAfter(li, ulParent);
			} else if (NodeType.isListNode(ulParent)) {
				DOM.insertAfter(li, ul);
			} else {
				DOM.insertAfter(TextBlock.createNewTextBlock(editor, li), ul);
				DOM.remove(li);
			}

			return true;
		}

		if (ulParent.nodeName === 'LI') {
			ul = ulParent;
			newBlock = TextBlock.createNewTextBlock(editor, li, 'LI');
		} else if (NodeType.isListNode(ulParent)) {
			newBlock = TextBlock.createNewTextBlock(editor, li, 'LI');
		} else {
			newBlock = TextBlock.createNewTextBlock(editor, li);
		}

		SplitList.splitList(editor, ul, li, newBlock);
		NormalizeLists.normalizeLists(editor.dom, ul.parentNode);

		return true;
	};

	var outdentSelection = function (editor) {
		var listElements = Selection.getSelectedListItems(editor);

		if (listElements.length) {
			var bookmark = Bookmark.createBookmark(editor.selection.getRng(true));
			var i, y, root = editor.getBody();

			i = listElements.length;
			while (i--) {
				var node = listElements[i].parentNode;

				while (node && node !== root) {
					y = listElements.length;
					while (y--) {
						if (listElements[y] === node) {
							listElements.splice(i, 1);
							break;
						}
					}

					node = node.parentNode;
				}
			}

			for (i = 0; i < listElements.length; i++) {
				if (!outdent(editor, listElements[i]) && i === 0) {
					break;
				}
			}

			editor.selection.setRng(Bookmark.resolveBookmark(bookmark));
			editor.nodeChanged();

			return true;
		}
	};

	return {
		outdent: outdent,
		outdentSelection: outdentSelection
	};
});


/**
 * ToggleList.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.actions.ToggleList", [
	"global!tinymce.util.Tools",
	"global!tinymce.dom.BookmarkManager",
	"tinymce.lists.core.Selection",
	"tinymce.lists.core.NodeType",
	"tinymce.lists.core.Bookmark",
	"tinymce.lists.core.SplitList",
	"tinymce.lists.core.NormalizeLists",
	"tinymce.lists.actions.Outdent"
], function (Tools, BookmarkManager, Selection, NodeType, Bookmark, SplitList, NormalizeLists, Outdent) {
	var updateListStyle = function (dom, el, detail) {
		var type = detail['list-style-type'] ? detail['list-style-type'] : null;
		dom.setStyle(el, 'list-style-type', type);
	};

	var setAttribs = function (elm, attrs) {
		Tools.each(attrs, function (value, key) {
			elm.setAttribute(key, value);
		});
	};

	var updateListAttrs = function (dom, el, detail) {
		setAttribs(el, detail['list-attributes']);
		Tools.each(dom.select('li', el), function (li) {
			setAttribs(li, detail['list-item-attributes']);
		});
	};

	var updateListWithDetails = function (dom, el, detail) {
		updateListStyle(dom, el, detail);
		updateListAttrs(dom, el, detail);
	};

	var getEndPointNode = function (editor, rng, start) {
		var container, offset, root = editor.getBody();

		container = rng[start ? 'startContainer' : 'endContainer'];
		offset = rng[start ? 'startOffset' : 'endOffset'];

		// Resolve node index
		if (container.nodeType === 1) {
			container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
		}

		while (container.parentNode !== root) {
			if (NodeType.isTextBlock(editor, container)) {
				return container;
			}

			if (/^(TD|TH)$/.test(container.parentNode.nodeName)) {
				return container;
			}

			container = container.parentNode;
		}

		return container;
	};

	var getSelectedTextBlocks = function (editor, rng) {
		var textBlocks = [], root = editor.getBody(), dom = editor.dom;

		var startNode = getEndPointNode(editor, rng, true);
		var endNode = getEndPointNode(editor, rng, false);
		var block, siblings = [];

		for (var node = startNode; node; node = node.nextSibling) {
			siblings.push(node);

			if (node === endNode) {
				break;
			}
		}

		Tools.each(siblings, function (node) {
			if (NodeType.isTextBlock(editor, node)) {
				textBlocks.push(node);
				block = null;
				return;
			}

			if (dom.isBlock(node) || NodeType.isBr(node)) {
				if (NodeType.isBr(node)) {
					dom.remove(node);
				}

				block = null;
				return;
			}

			var nextSibling = node.nextSibling;
			if (BookmarkManager.isBookmarkNode(node)) {
				if (NodeType.isTextBlock(editor, nextSibling) || (!nextSibling && node.parentNode === root)) {
					block = null;
					return;
				}
			}

			if (!block) {
				block = dom.create('p');
				node.parentNode.insertBefore(block, node);
				textBlocks.push(block);
			}

			block.appendChild(node);
		});

		return textBlocks;
	};

	var applyList = function (editor, listName, detail) {
		var rng = editor.selection.getRng(true), bookmark, listItemName = 'LI';
		var dom = editor.dom;

		detail = detail ? detail : {};

		if (dom.getContentEditable(editor.selection.getNode()) === "false") {
			return;
		}

		listName = listName.toUpperCase();

		if (listName === 'DL') {
			listItemName = 'DT';
		}

		bookmark = Bookmark.createBookmark(rng);

		Tools.each(getSelectedTextBlocks(editor, rng), function (block) {
			var listBlock, sibling;

			var hasCompatibleStyle = function (sib) {
				var sibStyle = dom.getStyle(sib, 'list-style-type');
				var detailStyle = detail ? detail['list-style-type'] : '';

				detailStyle = detailStyle === null ? '' : detailStyle;

				return sibStyle === detailStyle;
			};

			sibling = block.previousSibling;
			if (sibling && NodeType.isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(sibling)) {
				listBlock = sibling;
				block = dom.rename(block, listItemName);
				sibling.appendChild(block);
			} else {
				listBlock = dom.create(listName);
				block.parentNode.insertBefore(listBlock, block);
				listBlock.appendChild(block);
				block = dom.rename(block, listItemName);
			}

			updateListWithDetails(dom, listBlock, detail);
			mergeWithAdjacentLists(editor.dom, listBlock);
		});

		editor.selection.setRng(Bookmark.resolveBookmark(bookmark));
	};

	var removeList = function (editor) {
		var bookmark = Bookmark.createBookmark(editor.selection.getRng(true)), root = editor.getBody();
		var listItems = Selection.getSelectedListItems(editor);
		var emptyListItems = Tools.grep(listItems, function (li) {
			return editor.dom.isEmpty(li);
		});

		listItems = Tools.grep(listItems, function (li) {
			return !editor.dom.isEmpty(li);
		});

		Tools.each(emptyListItems, function (li) {
			if (NodeType.isEmpty(editor.dom, li)) {
				Outdent.outdent(editor, li);
				return;
			}
		});

		Tools.each(listItems, function (li) {
			var node, rootList;

			if (li.parentNode === editor.getBody()) {
				return;
			}

			for (node = li; node && node !== root; node = node.parentNode) {
				if (NodeType.isListNode(node)) {
					rootList = node;
				}
			}

			SplitList.splitList(editor, rootList, li);
			NormalizeLists.normalizeLists(editor.dom, rootList.parentNode);
		});

		editor.selection.setRng(Bookmark.resolveBookmark(bookmark));
	};

	var isValidLists = function (list1, list2) {
		return list1 && list2 && NodeType.isListNode(list1) && list1.nodeName === list2.nodeName;
	};

	var hasSameListStyle = function (dom, list1, list2) {
		var targetStyle = dom.getStyle(list1, 'list-style-type', true);
		var style = dom.getStyle(list2, 'list-style-type', true);
		return targetStyle === style;
	};

	var hasSameClasses = function (elm1, elm2) {
		return elm1.className === elm2.className;
	};

	var shouldMerge = function (dom, list1, list2) {
		return isValidLists(list1, list2) && hasSameListStyle(dom, list1, list2) && hasSameClasses(list1, list2);
	};

	var mergeWithAdjacentLists = function (dom, listBlock) {
		var sibling, node;

		sibling = listBlock.nextSibling;
		if (shouldMerge(dom, listBlock, sibling)) {
			while ((node = sibling.firstChild)) {
				listBlock.appendChild(node);
			}

			dom.remove(sibling);
		}

		sibling = listBlock.previousSibling;
		if (shouldMerge(dom, listBlock, sibling)) {
			while ((node = sibling.lastChild)) {
				listBlock.insertBefore(node, listBlock.firstChild);
			}

			dom.remove(sibling);
		}
	};

	var toggleList = function (editor, listName, detail) {
		var parentList = editor.dom.getParent(editor.selection.getStart(), 'OL,UL,DL');

		detail = detail ? detail : {};

		if (parentList === editor.getBody()) {
			return;
		}

		if (parentList) {
			if (parentList.nodeName === listName) {
				removeList(editor, listName);
			} else {
				var bookmark = Bookmark.createBookmark(editor.selection.getRng(true));
				updateListWithDetails(editor.dom, parentList, detail);
				mergeWithAdjacentLists(editor.dom, editor.dom.rename(parentList, listName));
				editor.selection.setRng(Bookmark.resolveBookmark(bookmark));
			}
		} else {
			applyList(editor, listName, detail);
		}
	};

	return {
		toggleList: toggleList,
		removeList: removeList,
		mergeWithAdjacentLists: mergeWithAdjacentLists
	};
});


/**
 * Delete.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.core.Delete", [
	"global!tinymce.dom.TreeWalker",
	"global!tinymce.dom.RangeUtils",
	"global!tinymce.util.VK",
	"tinymce.lists.core.Selection",
	"tinymce.lists.core.NodeType",
	"tinymce.lists.core.Bookmark",
	"tinymce.lists.core.Range",
	"tinymce.lists.core.NormalizeLists",
	"tinymce.lists.actions.ToggleList"
], function (
	TreeWalker, RangeUtils, VK, Selection, NodeType, Bookmark, Range, NormalizeLists, ToggleList
) {
	var findNextCaretContainer = function (editor, rng, isForward) {
		var node = rng.startContainer, offset = rng.startOffset;
		var nonEmptyBlocks, walker;

		if (node.nodeType === 3 && (isForward ? offset < node.data.length : offset > 0)) {
			return node;
		}

		nonEmptyBlocks = editor.schema.getNonEmptyElements();
		if (node.nodeType === 1) {
			node = RangeUtils.getNode(node, offset);
		}

		walker = new TreeWalker(node, editor.getBody());

		// Delete at <li>|<br></li> then jump over the bogus br
		if (isForward) {
			if (NodeType.isBogusBr(editor.dom, node)) {
				walker.next();
			}
		}

		while ((node = walker[isForward ? 'next' : 'prev2']())) {
			if (node.nodeName === 'LI' && !node.hasChildNodes()) {
				return node;
			}

			if (nonEmptyBlocks[node.nodeName]) {
				return node;
			}

			if (node.nodeType === 3 && node.data.length > 0) {
				return node;
			}
		}
	};

	var mergeLiElements = function (dom, fromElm, toElm) {
		var node, listNode, ul = fromElm.parentNode;

		if (!NodeType.isChildOfBody(dom, fromElm) || !NodeType.isChildOfBody(dom, toElm)) {
			return;
		}

		if (NodeType.isListNode(toElm.lastChild)) {
			listNode = toElm.lastChild;
		}

		if (ul === toElm.lastChild) {
			if (NodeType.isBr(ul.previousSibling)) {
				dom.remove(ul.previousSibling);
			}
		}

		node = toElm.lastChild;
		if (node && NodeType.isBr(node) && fromElm.hasChildNodes()) {
			dom.remove(node);
		}

		if (NodeType.isEmpty(dom, toElm, true)) {
			dom.$(toElm).empty();
		}

		if (!NodeType.isEmpty(dom, fromElm, true)) {
			while ((node = fromElm.firstChild)) {
				toElm.appendChild(node);
			}
		}

		if (listNode) {
			toElm.appendChild(listNode);
		}

		dom.remove(fromElm);

		if (NodeType.isEmpty(dom, ul) && ul !== dom.getRoot()) {
			dom.remove(ul);
		}
	};

	var backspaceDeleteFromListToListCaret = function (editor, isForward) {
		var dom = editor.dom, selection = editor.selection;
		var li = dom.getParent(selection.getStart(), 'LI'), ul, rng, otherLi;

		if (li) {
			ul = li.parentNode;
			if (ul === editor.getBody() && NodeType.isEmpty(dom, ul)) {
				return true;
			}

			rng = Range.normalizeRange(selection.getRng(true));
			otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward), 'LI');

			if (otherLi && otherLi !== li) {
				var bookmark = Bookmark.createBookmark(rng);

				if (isForward) {
					mergeLiElements(dom, otherLi, li);
				} else {
					mergeLiElements(dom, li, otherLi);
				}

				editor.selection.setRng(Bookmark.resolveBookmark(bookmark));

				return true;
			} else if (!otherLi) {
				if (!isForward && ToggleList.removeList(editor, ul.nodeName)) {
					return true;
				}
			}
		}

		return false;
	};

	var backspaceDeleteIntoListCaret = function (editor, isForward) {
		var dom = editor.dom;
		var block = dom.getParent(editor.selection.getStart(), dom.isBlock);

		if (block && dom.isEmpty(block)) {
			var rng = Range.normalizeRange(editor.selection.getRng(true));
			var otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward), 'LI');

			if (otherLi) {
				editor.undoManager.transact(function () {
					dom.remove(block);
					ToggleList.mergeWithAdjacentLists(dom, otherLi.parentNode);
					editor.selection.select(otherLi, true);
					editor.selection.collapse(isForward);
				});

				return true;
			}
		}

		return false;
	};

	var backspaceDeleteCaret = function (editor, isForward) {
		return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);
	};

	var backspaceDeleteRange = function (editor) {
		var startListParent = editor.dom.getParent(editor.selection.getStart(), 'LI,DT,DD');

		if (startListParent || Selection.getSelectedListItems(editor).length > 0) {
			editor.undoManager.transact(function () {
				editor.execCommand('Delete');
				NormalizeLists.normalizeLists(editor.dom, editor.getBody());
			});

			return true;
		}

		return false;
	};

	var backspaceDelete = function (editor, isForward) {
		return editor.selection.isCollapsed() ? backspaceDeleteCaret(editor, isForward) : backspaceDeleteRange(editor);
	};

	var setup = function (editor) {
		editor.on('keydown', function (e) {
			if (e.keyCode === VK.BACKSPACE) {
				if (backspaceDelete(editor, false)) {
					e.preventDefault();
				}
			} else if (e.keyCode === VK.DELETE) {
				if (backspaceDelete(editor, true)) {
					e.preventDefault();
				}
			}
		});
	};

	return {
		setup: setup,
		backspaceDelete: backspaceDelete
	};
});


/**
 * Indent.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.actions.Indent", [
	"global!tinymce.dom.DOMUtils.DOM",
	"tinymce.lists.core.NodeType",
	"tinymce.lists.core.Bookmark",
	"tinymce.lists.core.Selection"
], function (DOM, NodeType, Bookmark, Selection) {
	var mergeLists = function (from, to) {
		var node;

		if (NodeType.isListNode(from)) {
			while ((node = from.firstChild)) {
				to.appendChild(node);
			}

			DOM.remove(from);
		}
	};

	var indent = function (li) {
		var sibling, newList, listStyle;

		if (li.nodeName === 'DT') {
			DOM.rename(li, 'DD');
			return true;
		}

		sibling = li.previousSibling;

		if (sibling && NodeType.isListNode(sibling)) {
			sibling.appendChild(li);
			return true;
		}

		if (sibling && sibling.nodeName === 'LI' && NodeType.isListNode(sibling.lastChild)) {
			sibling.lastChild.appendChild(li);
			mergeLists(li.lastChild, sibling.lastChild);
			return true;
		}

		sibling = li.nextSibling;

		if (sibling && NodeType.isListNode(sibling)) {
			sibling.insertBefore(li, sibling.firstChild);
			return true;
		}

		/*if (sibling && sibling.nodeName === 'LI' && isListNode(li.lastChild)) {
			return false;
		}*/

		sibling = li.previousSibling;
		if (sibling && sibling.nodeName === 'LI') {
			newList = DOM.create(li.parentNode.nodeName);
			listStyle = DOM.getStyle(li.parentNode, 'listStyleType');
			if (listStyle) {
				DOM.setStyle(newList, 'listStyleType', listStyle);
			}
			sibling.appendChild(newList);
			newList.appendChild(li);
			mergeLists(li.lastChild, newList);
			return true;
		}

		return false;
	};

	var indentSelection = function (editor) {
		var listElements = Selection.getSelectedListItems(editor);

		if (listElements.length) {
			var bookmark = Bookmark.createBookmark(editor.selection.getRng(true));

			for (var i = 0; i < listElements.length; i++) {
				if (!indent(listElements[i]) && i === 0) {
					break;
				}
			}

			editor.selection.setRng(Bookmark.resolveBookmark(bookmark));
			editor.nodeChanged();

			return true;
		}
	};

	return {
		indentSelection: indentSelection
	};
});


/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.lists.Plugin", [
	"global!tinymce.PluginManager",
	"global!tinymce.util.Tools",
	"global!tinymce.util.VK",
	"tinymce.lists.core.NodeType",
	"tinymce.lists.core.Delete",
	"tinymce.lists.actions.Indent",
	"tinymce.lists.actions.Outdent",
	"tinymce.lists.actions.ToggleList"
], function (PluginManager, Tools, VK, NodeType, Delete, Indent, Outdent, ToggleList) {
	var queryListCommandState = function (editor, listName) {
		return function () {
			var parentList = editor.dom.getParent(editor.selection.getStart(), 'UL,OL,DL');
			return parentList && parentList.nodeName === listName;
		};
	};

	var setupCommands = function (editor) {
		editor.on('BeforeExecCommand', function (e) {
			var cmd = e.command.toLowerCase(), isHandled;

			if (cmd === "indent") {
				if (Indent.indentSelection(editor)) {
					isHandled = true;
				}
			} else if (cmd === "outdent") {
				if (Outdent.outdentSelection(editor)) {
					isHandled = true;
				}
			}

			if (isHandled) {
				editor.fire('ExecCommand', {command: e.command});
				e.preventDefault();
				return true;
			}
		});

		editor.addCommand('InsertUnorderedList', function (ui, detail) {
			ToggleList.toggleList(editor, 'UL', detail);
		});

		editor.addCommand('InsertOrderedList', function (ui, detail) {
			ToggleList.toggleList(editor, 'OL', detail);
		});

		editor.addCommand('InsertDefinitionList', function (ui, detail) {
			ToggleList.toggleList(editor, 'DL', detail);
		});
	};

	var setupStateHandlers = function (editor) {
		editor.addQueryStateHandler('InsertUnorderedList', queryListCommandState(editor, 'UL'));
		editor.addQueryStateHandler('InsertOrderedList', queryListCommandState(editor, 'OL'));
		editor.addQueryStateHandler('InsertDefinitionList', queryListCommandState(editor, 'DL'));
	};

	var setupTabKey = function (editor) {
		editor.on('keydown', function (e) {
			// Check for tab but not ctrl/cmd+tab since it switches browser tabs
			if (e.keyCode !== 9 || VK.metaKeyPressed(e)) {
				return;
			}

			if (editor.dom.getParent(editor.selection.getStart(), 'LI,DT,DD')) {
				e.preventDefault();

				if (e.shiftKey) {
					Outdent.outdentSelection(editor);
				} else {
					Indent.indentSelection(editor);
				}
			}
		});
	};

	var setupUi = function (editor) {
		var listState = function (listName) {
			return function () {
				var self = this;

				editor.on('NodeChange', function (e) {
					var lists = Tools.grep(e.parents, NodeType.isListNode);
					self.active(lists.length > 0 && lists[0].nodeName === listName);
				});
			};
		};

		var hasPlugin = function (editor, plugin) {
			var plugins = editor.settings.plugins ? editor.settings.plugins : '';
			return Tools.inArray(plugins.split(/[ ,]/), plugin) !== -1;
		};

		if (!hasPlugin(editor, 'advlist')) {
			editor.addButton('numlist', {
				title: 'Numbered list',
				cmd: 'InsertOrderedList',
				onPostRender: listState('OL')
			});

			editor.addButton('bullist', {
				title: 'Bullet list',
				cmd: 'InsertUnorderedList',
				onPostRender: listState('UL')
			});
		}

		editor.addButton('indent', {
			icon: 'indent',
			title: 'Increase indent',
			cmd: 'Indent',
			onPostRender: function (e) {
				var ctrl = e.control;

				editor.on('nodechange', function () {
					var blocks = editor.selection.getSelectedBlocks();
					var disable = false;

					for (var i = 0, l = blocks.length; !disable && i < l; i++) {
						var tag = blocks[i].nodeName;

						disable = (tag === 'LI' && NodeType.isFirstChild(blocks[i]) || tag === 'UL' || tag === 'OL' || tag === 'DD');
					}

					ctrl.disabled(disable);
				});
			}
		});
	};

	PluginManager.add('lists', function (editor) {
		setupUi(editor);
		Delete.setup(editor);

		editor.on('init', function () {
			setupCommands(editor);
			setupStateHandlers(editor);
			setupTabKey(editor);
		});

		return {
			backspaceDelete: function (isForward) {
				Delete.backspaceDelete(editor, isForward);
			}
		};
	});

	return function () {};
});


dem('tinymce.lists.Plugin')();
})();

(function () {

var defs = {}; // id -> {dependencies, definition, instance (possibly undefined)}

// Used when there is no 'main' module.
// The name is probably (hopefully) unique so minification removes for releases.
var register_3795 = function (id) {
  var module = dem(id);
  var fragments = id.split('.');
  var target = Function('return this;')();
  for (var i = 0; i < fragments.length - 1; ++i) {
    if (target[fragments[i]] === undefined)
      target[fragments[i]] = {};
    target = target[fragments[i]];
  }
  target[fragments[fragments.length - 1]] = module;
};

var instantiate = function (id) {
  var actual = defs[id];
  var dependencies = actual.deps;
  var definition = actual.defn;
  var len = dependencies.length;
  var instances = new Array(len);
  for (var i = 0; i < len; ++i)
    instances[i] = dem(dependencies[i]);
  var defResult = definition.apply(null, instances);
  if (defResult === undefined)
     throw 'module [' + id + '] returned undefined';
  actual.instance = defResult;
};

var def = function (id, dependencies, definition) {
  if (typeof id !== 'string')
    throw 'module id must be a string';
  else if (dependencies === undefined)
    throw 'no dependencies for ' + id;
  else if (definition === undefined)
    throw 'no definition function for ' + id;
  defs[id] = {
    deps: dependencies,
    defn: definition,
    instance: undefined
  };
};

var dem = function (id) {
  var actual = defs[id];
  if (actual === undefined)
    throw 'module [' + id + '] was undefined';
  else if (actual.instance === undefined)
    instantiate(id);
  return actual.instance;
};

var req = function (ids, callback) {
  var len = ids.length;
  var instances = new Array(len);
  for (var i = 0; i < len; ++i)
    instances.push(dem(ids[i]));
  callback.apply(null, callback);
};

var ephox = {};

ephox.bolt = {
  module: {
    api: {
      define: def,
      require: req,
      demand: dem
    }
  }
};

var define = def;
var require = req;
var demand = dem;
// this helps with minificiation when using a lot of global references
var defineGlobal = function (id, ref) {
  define(id, [], function () { return ref; });
};
/*jsc
["tinymce.media.Plugin","global!tinymce.PluginManager","tinymce.media.ui.Dialog","tinymce.media.core.Sanitize","tinymce.media.core.UpdateHtml","tinymce.media.core.Nodes","global!tinymce.util.Delay","tinymce.media.core.HtmlToData","global!tinymce.html.Writer","global!tinymce.html.SaxParser","global!tinymce.html.Schema","global!tinymce.dom.DOMUtils.DOM","tinymce.media.core.Size","tinymce.media.core.Service","global!tinymce.util.Tools","global!tinymce.Env","tinymce.media.ui.SizeManager","tinymce.media.core.VideoScript","global!tinymce.html.Node","tinymce.media.core.DataToHtml","global!tinymce.util.Promise","tinymce.media.core.Mime","tinymce.media.core.UrlPatterns"]
jsc*/
defineGlobal("global!tinymce.PluginManager", tinymce.PluginManager);
defineGlobal("global!tinymce.util.Delay", tinymce.util.Delay);
defineGlobal("global!tinymce.util.Tools", tinymce.util.Tools);
defineGlobal("global!tinymce.html.SaxParser", tinymce.html.SaxParser);
defineGlobal("global!tinymce.html.Schema", tinymce.html.Schema);
defineGlobal("global!tinymce.dom.DOMUtils.DOM", tinymce.dom.DOMUtils.DOM);
define('tinymce.media.core.VideoScript', [
], function () {
	var getVideoScriptMatch = function (prefixes, src) {
		// var prefixes = editor.settings.media_scripts;

		if (prefixes) {
			for (var i = 0; i < prefixes.length; i++) {
				if (src.indexOf(prefixes[i].filter) !== -1) {
					return prefixes[i];
				}
			}
		}
	};

	return {
		getVideoScriptMatch: getVideoScriptMatch
	};
});
define('tinymce.media.core.Size', [
], function () {
	var trimPx = function (value) {
		return value.replace(/px$/, '');
	};

	var addPx = function (value) {
		return /^[0-9.]+$/.test(value) ? (value + 'px') : value;
	};

	var getSize = function (name) {
		return function (elm) {
			return elm ? trimPx(elm.style[name]) : '';
		};
	};

	var setSize = function (name) {
		return function (elm, value) {
			if (elm) {
				elm.style[name] = addPx(value);
			}
		};
	};

	return {
		getMaxWidth: getSize('maxWidth'),
		getMaxHeight: getSize('maxHeight'),
		setMaxWidth: setSize('maxWidth'),
		setMaxHeight: setSize('maxHeight')
	};
});
define('tinymce.media.core.HtmlToData', [
	'global!tinymce.util.Tools',
	'global!tinymce.html.SaxParser',
	'global!tinymce.html.Schema',
	'global!tinymce.dom.DOMUtils.DOM',
	'tinymce.media.core.VideoScript',
	'tinymce.media.core.Size'
], function (Tools, SaxParser, Schema, DOM, VideoScript, Size) {
	var getEphoxEmbedIri = function (elm) {
		return DOM.getAttrib(elm, 'data-ephox-embed-iri');
	};

	var isEphoxEmbed = function (html) {
		var fragment = DOM.createFragment(html);
		return getEphoxEmbedIri(fragment.firstChild) !== '';
	};

	var htmlToDataSax = function (prefixes, html) {
		var data = {};

		new SaxParser({
			validate: false,
			allow_conditional_comments: true,
			special: 'script,noscript',
			start: function (name, attrs) {
				if (!data.source1 && name === "param") {
					data.source1 = attrs.map.movie;
				}

				if (name === "iframe" || name === "object" || name === "embed" || name === "video" || name === "audio") {
					if (!data.type) {
						data.type = name;
					}

					data = Tools.extend(attrs.map, data);
				}

				if (name === "script") {
					var videoScript = VideoScript.getVideoScriptMatch(prefixes, attrs.map.src);
					if (!videoScript) {
						return;
					}

					data = {
						type: "script",
						source1: attrs.map.src,
						width: videoScript.width,
						height: videoScript.height
					};
				}

				if (name === "source") {
					if (!data.source1) {
						data.source1 = attrs.map.src;
					} else if (!data.source2) {
						data.source2 = attrs.map.src;
					}
				}

				if (name === "img" && !data.poster) {
					data.poster = attrs.map.src;
				}
			}
		}).parse(html);

		data.source1 = data.source1 || data.src || data.data;
		data.source2 = data.source2 || '';
		data.poster = data.poster || '';

		return data;
	};

	var ephoxEmbedHtmlToData = function (html) {
		var fragment = DOM.createFragment(html);
		var div = fragment.firstChild;

		return {
			type: 'ephox-embed-iri',
			source1: getEphoxEmbedIri(div),
			source2: '',
			poster: '',
			width: Size.getMaxWidth(div),
			height: Size.getMaxHeight(div)
		};
	};

	var htmlToData = function (prefixes, html) {
		return isEphoxEmbed(html) ? ephoxEmbedHtmlToData(html) : htmlToDataSax(prefixes, html);
	};

	return {
		htmlToData: htmlToData
	};
});
defineGlobal("global!tinymce.html.Writer", tinymce.html.Writer);
define('tinymce.media.core.UpdateHtml', [
	'global!tinymce.html.Writer',
	'global!tinymce.html.SaxParser',
	'global!tinymce.html.Schema',
	'global!tinymce.dom.DOMUtils.DOM',
	'tinymce.media.core.Size'
], function (Writer, SaxParser, Schema, DOM, Size) {
	var setAttributes = function (attrs, updatedAttrs) {
		var name;
		var i;
		var value;
		var attr;

		for (name in updatedAttrs) {
			value = "" + updatedAttrs[name];

			if (attrs.map[name]) {
				i = attrs.length;
				while (i--) {
					attr = attrs[i];

					if (attr.name === name) {
						if (value) {
							attrs.map[name] = value;
							attr.value = value;
						} else {
							delete attrs.map[name];
							attrs.splice(i, 1);
						}
					}
				}
			} else if (value) {
				attrs.push({
					name: name,
					value: value
				});

				attrs.map[name] = value;
			}
		}
	};

	var normalizeHtml = function (html) {
		var writer = new Writer();
		var parser = new SaxParser(writer);
		parser.parse(html);
		return writer.getContent();
	};

	var updateHtmlSax = function (html, data, updateAll) {
		var writer = new Writer();
		var sourceCount = 0;
		var hasImage;

		new SaxParser({
			validate: false,
			allow_conditional_comments: true,
			special: 'script,noscript',

			comment: function (text) {
				writer.comment(text);
			},

			cdata: function (text) {
				writer.cdata(text);
			},

			text: function (text, raw) {
				writer.text(text, raw);
			},

			start: function (name, attrs, empty) {
				switch (name) {
				case "video":
				case "object":
				case "embed":
				case "img":
				case "iframe":
					setAttributes(attrs, {
						width: data.width,
						height: data.height
					});
					break;
				}

				if (updateAll) {
					switch (name) {
					case "video":
						setAttributes(attrs, {
							poster: data.poster,
							src: ""
						});

						if (data.source2) {
							setAttributes(attrs, {
								src: ""
							});
						}
						break;

					case "iframe":
						setAttributes(attrs, {
							src: data.source1
						});
						break;

					case "source":
						sourceCount++;

						if (sourceCount <= 2) {
							setAttributes(attrs, {
								src: data["source" + sourceCount],
								type: data["source" + sourceCount + "mime"]
							});

							if (!data["source" + sourceCount]) {
								return;
							}
						}
						break;

					case "img":
						if (!data.poster) {
							return;
						}

						hasImage = true;
						break;
					}
				}

				writer.start(name, attrs, empty);
			},

			end: function (name) {
				if (name === "video" && updateAll) {
					for (var index = 1; index <= 2; index++) {
						if (data["source" + index]) {
							var attrs = [];
							attrs.map = {};

							if (sourceCount < index) {
								setAttributes(attrs, {
									src: data["source" + index],
									type: data["source" + index + "mime"]
								});

								writer.start("source", attrs, true);
							}
						}
					}
				}

				if (data.poster && name === "object" && updateAll && !hasImage) {
					var imgAttrs = [];
					imgAttrs.map = {};

					setAttributes(imgAttrs, {
						src: data.poster,
						width: data.width,
						height: data.height
					});

					writer.start("img", imgAttrs, true);
				}

				writer.end(name);
			}
		}, new Schema({})).parse(html);

		return writer.getContent();
	};

	var isEphoxEmbed = function (html) {
		var fragment = DOM.createFragment(html);
		return DOM.getAttrib(fragment.firstChild, 'data-ephox-embed-iri') !== '';
	};

	var updateEphoxEmbed = function (html, data) {
		var fragment = DOM.createFragment(html);
		var div = fragment.firstChild;

		Size.setMaxWidth(div, data.width);
		Size.setMaxHeight(div, data.height);

		return normalizeHtml(div.outerHTML);
	};

	var updateHtml = function (html, data, updateAll) {
		return isEphoxEmbed(html) ? updateEphoxEmbed(html, data) : updateHtmlSax(html, data, updateAll);
	};

	return {
		updateHtml: updateHtml
	};
});
define('tinymce.media.core.Mime', [
], function () {
	var guess = function (url) {
		var mimes = {
			'mp3': 'audio/mpeg',
			'wav': 'audio/wav',
			'mp4': 'video/mp4',
			'webm': 'video/webm',
			'ogg': 'video/ogg',
			'swf': 'application/x-shockwave-flash'
		};
		var fileEnd = url.toLowerCase().split('.').pop();
		var mime = mimes[fileEnd];

		return mime ? mime : '';
	};

	return {
		guess: guess
	};
});
define('tinymce.media.core.UrlPatterns', [
], function () {
	var urlPatterns = [
		{
			regex: /youtu\.be\/([\w\-.]+)/,
			type: 'iframe', w: 560, h: 314,
			url: '//www.youtube.com/embed/$1',
			allowFullscreen: true
		},
		{
			regex: /youtube\.com(.+)v=([^&]+)/,
			type: 'iframe', w: 560, h: 314,
			url: '//www.youtube.com/embed/$2',
			allowFullscreen: true
		},
		{
			regex: /youtube.com\/embed\/([a-z0-9\-_]+(?:\?.+)?)/i,
			type: 'iframe', w: 560, h: 314,
			url: '//www.youtube.com/embed/$1',
			allowFullscreen: true
		},
		{
			regex: /vimeo\.com\/([0-9]+)/,
			type: 'iframe', w: 425, h: 350,
			url: '//player.vimeo.com/video/$1?title=0&byline=0&portrait=0&color=8dc7dc',
			allowfullscreen: true
		},
		{
			regex: /vimeo\.com\/(.*)\/([0-9]+)/,
			type: "iframe", w: 425, h: 350,
			url: "//player.vimeo.com/video/$2?title=0&amp;byline=0",
			allowfullscreen: true
		},
		{
			regex: /maps\.google\.([a-z]{2,3})\/maps\/(.+)msid=(.+)/,
			type: 'iframe', w: 425, h: 350,
			url: '//maps.google.com/maps/ms?msid=$2&output=embed"',
			allowFullscreen: false
		},
		{
			regex: /dailymotion\.com\/video\/([^_]+)/,
			type: 'iframe', w: 480, h: 270,
			url: '//www.dailymotion.com/embed/video/$1',
			allowFullscreen: true
		}
	];

	return {
		urlPatterns: urlPatterns
	};
});
define('tinymce.media.core.DataToHtml', [
	'tinymce.media.core.Mime',
	'tinymce.media.core.HtmlToData',
	'tinymce.media.core.UrlPatterns',
	'tinymce.media.core.VideoScript',
	'tinymce.media.core.UpdateHtml',
	'global!tinymce.util.Tools'
], function (Mime, HtmlToData, UrlPatterns, VideoScript, UpdateHtml, Tools) {
	var dataToHtml = function (editor, dataIn) {
		var html = '';
		var data = Tools.extend({}, dataIn);

		if (!data.source1) {
			Tools.extend(data, HtmlToData.htmlToData(editor.settings.media_scripts, data.embed));
			if (!data.source1) {
				return '';
			}
		}

		if (!data.source2) {
			data.source2 = '';
		}

		if (!data.poster) {
			data.poster = '';
		}

		data.source1 = editor.convertURL(data.source1, "source");
		data.source2 = editor.convertURL(data.source2, "source");
		data.source1mime = Mime.guess(data.source1);
		data.source2mime = Mime.guess(data.source2);
		data.poster = editor.convertURL(data.poster, "poster");

		Tools.each(UrlPatterns.urlPatterns, function (pattern) {
			var i;
			var url;

			var match = pattern.regex.exec(data.source1);

			if (match) {
				url = pattern.url;

				for (i = 0; match[i]; i++) {
					/*jshint loopfunc:true*/
					/*eslint no-loop-func:0 */
					url = url.replace('$' + i, function () {
						return match[i];
					});
				}

				data.source1 = url;
				data.type = pattern.type;
				data.allowFullscreen = pattern.allowFullscreen;
				data.width = data.width || pattern.w;
				data.height = data.height || pattern.h;
			}
		});

		if (data.embed) {
			html = UpdateHtml.updateHtml(data.embed, data, true);
		} else {
			var videoScript = VideoScript.getVideoScriptMatch(editor.settings.media_scripts, data.source1);
			if (videoScript) {
				data.type = 'script';
				data.width = videoScript.width;
				data.height = videoScript.height;
			}

			data.width = data.width || 300;
			data.height = data.height || 150;

			Tools.each(data, function (value, key) {
				data[key] = editor.dom.encode(value);
			});

			if (data.type === "iframe") {
				var allowFullscreen = data.allowFullscreen ? ' allowFullscreen="1"' : '';
				html +=
					'<iframe src="' + data.source1 +
					'" width="' + data.width +
					'" height="' + data.height +
					'"' + allowFullscreen + '></iframe>';
			} else if (data.source1mime === "application/x-shockwave-flash") {
				html +=
					'<object data="' + data.source1 +
					'" width="' + data.width +
					'" height="' + data.height +
					'" type="application/x-shockwave-flash">';

				if (data.poster) {
					html += '<img src="' + data.poster + '" width="' + data.width + '" height="' + data.height + '" />';
				}

				html += '</object>';
			} else if (data.source1mime.indexOf('audio') !== -1) {
				if (editor.settings.audio_template_callback) {
					html = editor.settings.audio_template_callback(data);
				} else {
					html += (
						'<audio controls="controls" src="' + data.source1 + '">' +
							(
								data.source2 ?
									'\n<source src="' + data.source2 + '"' +
										(data.source2mime ? ' type="' + data.source2mime + '"' : '') +
									' />\n' : '') +
						'</audio>'
					);
				}
			} else if (data.type === "script") {
				html += '<script src="' + data.source1 + '"></script>';
			} else {
				if (editor.settings.video_template_callback) {
					html = editor.settings.video_template_callback(data);
				} else {
					html = (
						'<video width="' + data.width +
							'" height="' + data.height + '"' +
								(data.poster ? ' poster="' + data.poster + '"' : '') + ' controls="controls">\n' +
							'<source src="' + data.source1 + '"' +
								(data.source1mime ? ' type="' + data.source1mime + '"' : '') + ' />\n' +
							(data.source2 ? '<source src="' + data.source2 + '"' +
								(data.source2mime ? ' type="' + data.source2mime + '"' : '') + ' />\n' : '') +
						'</video>'
					);
				}
			}
		}

		return html;
	};

	return {
		dataToHtml: dataToHtml
	};
});
defineGlobal("global!tinymce.util.Promise", tinymce.util.Promise);
define('tinymce.media.core.Service', [
	'tinymce.media.core.DataToHtml',
	'global!tinymce.util.Promise'
], function (DataToHtml, Promise) {

	var embedPromise = function (data, dataToHtml, handler) {
		var cache = {};
		return new Promise(function (res, rej) {
			var wrappedResolve = function (response) {
				if (response.html) {
					cache[data.source1] = response;
				}
				return res({
					url: data.source1,
					html: response.html ? response.html : dataToHtml(data)
				});
			};
			if (cache[data.source1]) {
				wrappedResolve(cache[data.source1]);
			} else {
				handler({url: data.source1}, wrappedResolve, rej);
			}
		});
	};

	var defaultPromise = function (data, dataToHtml) {
		return new Promise(function (res) {
			res({html: dataToHtml(data), url: data.source1});
		});
	};

	var loadedData = function (editor) {
		return function (data) {
			return DataToHtml.dataToHtml(editor, data);
		};
	};

	var getEmbedHtml = function (editor, data) {
		var embedHandler = editor.settings.media_url_resolver;

		return embedHandler ? embedPromise(data, loadedData(editor), embedHandler) : defaultPromise(data, loadedData(editor));
	};

	return {
		getEmbedHtml: getEmbedHtml
	};
});
defineGlobal("global!tinymce.Env", tinymce.Env);
define('tinymce.media.ui.SizeManager', [
], function () {
	var doSyncSize = function (widthCtrl, heightCtrl) {
		widthCtrl.state.set('oldVal', widthCtrl.value());
		heightCtrl.state.set('oldVal', heightCtrl.value());
	};
	var doSizeControls = function (win, f) {
		var widthCtrl = win.find('#width')[0];
		var heightCtrl = win.find('#height')[0];
		var constrained = win.find('#constrain')[0];
		if (widthCtrl && heightCtrl && constrained) {
			f(widthCtrl, heightCtrl, constrained.checked());
		}
	};

	var doUpdateSize = function (widthCtrl, heightCtrl, isContrained) {
		var oldWidth = widthCtrl.state.get('oldVal');
		var oldHeight = heightCtrl.state.get('oldVal');
		var newWidth = widthCtrl.value();
		var newHeight = heightCtrl.value();

		if (isContrained && oldWidth && oldHeight && newWidth && newHeight) {
			if (newWidth !== oldWidth) {
				newHeight = Math.round((newWidth / oldWidth) * newHeight);

				if (!isNaN(newHeight)) {
					heightCtrl.value(newHeight);
				}
			} else {
				newWidth = Math.round((newHeight / oldHeight) * newWidth);

				if (!isNaN(newWidth)) {
					widthCtrl.value(newWidth);
				}
			}
		}

		doSyncSize(widthCtrl, heightCtrl);
	};

	var syncSize = function (win) {
		doSizeControls(win, doSyncSize);
	};

	var updateSize = function (win) {
		doSizeControls(win, doUpdateSize);
	};

	var createUi = function (onChange) {
		var recalcSize = function () {
			onChange(function (win) {
				updateSize(win);
			});
		};

		return {
			type: 'container',
			label: 'Dimensions',
			layout: 'flex',
			align: 'center',
			spacing: 5,
			items: [
				{
					name: 'width', type: 'textbox', maxLength: 5, size: 5,
					onchange: recalcSize, ariaLabel: 'Width'
				},
				{type: 'label', text: 'x'},
				{
					name: 'height', type: 'textbox', maxLength: 5, size: 5,
					onchange: recalcSize, ariaLabel: 'Height'
				},
				{name: 'constrain', type: 'checkbox', checked: true, text: 'Constrain proportions'}
			]
		};
	};

	return {
		createUi: createUi,
		syncSize: syncSize,
		updateSize: updateSize
	};
});
define('tinymce.media.ui.Dialog', [
	'global!tinymce.util.Delay',
	'tinymce.media.core.HtmlToData',
	'tinymce.media.core.UpdateHtml',
	'tinymce.media.core.Service',
	'tinymce.media.core.Size',
	'global!tinymce.util.Tools',
	'global!tinymce.Env',
	'tinymce.media.ui.SizeManager'
], function (Delay, HtmlToData, UpdateHtml, Service, Size, Tools, Env, SizeManager) {
	var embedChange = (Env.ie && Env.ie <= 8) ? 'onChange' : 'onInput';

	var handleError = function (editor) {
		return function (error) {
			var errorMessage = error && error.msg ?
				'Media embed handler error: ' + error.msg :
				'Media embed handler threw unknown error.';
			editor.notificationManager.open({type: 'error', text: errorMessage});
		};
	};

	var getData = function (editor) {
		var element = editor.selection.getNode();
		var dataEmbed = element.getAttribute('data-ephox-embed-iri');

		if (dataEmbed) {
			return {
				source1: dataEmbed,
				'data-ephox-embed-iri': dataEmbed,
				width: Size.getMaxWidth(element),
				height: Size.getMaxHeight(element)
			};
		}

		return element.getAttribute('data-mce-object') ?
			HtmlToData.htmlToData(editor.settings.media_scripts, editor.serializer.serialize(element, {selection: true})) :
			{};
	};

	var getSource = function (editor) {
		var elm = editor.selection.getNode();

		if (elm.getAttribute('data-mce-object') || elm.getAttribute('data-ephox-embed-iri')) {
			return editor.selection.getContent();
		}
	};

	var addEmbedHtml = function (win, editor) {
		return function (response) {
			var html = response.html;
			var embed = win.find('#embed')[0];
			var data = Tools.extend(HtmlToData.htmlToData(editor.settings.media_scripts, html), {source1: response.url});
			win.fromJSON(data);

			if (embed) {
				embed.value(html);
				SizeManager.updateSize(win);
			}
		};
	};

	var selectPlaceholder = function (editor, beforeObjects) {
		var i;
		var y;
		var afterObjects = editor.dom.select('img[data-mce-object]');

		// Find new image placeholder so we can select it
		for (i = 0; i < beforeObjects.length; i++) {
			for (y = afterObjects.length - 1; y >= 0; y--) {
				if (beforeObjects[i] === afterObjects[y]) {
					afterObjects.splice(y, 1);
				}
			}
		}

		editor.selection.select(afterObjects[0]);
	};

	var handleInsert = function (editor, html) {
		var beforeObjects = editor.dom.select('img[data-mce-object]');

		editor.insertContent(html);
		selectPlaceholder(editor, beforeObjects);
		editor.nodeChanged();
	};

	var submitForm = function (win, editor) {
		var data = win.toJSON();

		data.embed = UpdateHtml.updateHtml(data.embed, data);

		if (data.embed) {
			handleInsert(editor, data.embed);
		} else {
			Service.getEmbedHtml(editor, data)
				.then(function (response) {
					handleInsert(editor, response.html);
				})["catch"](handleError(editor));
		}
	};

	var populateMeta = function (win, meta) {
		Tools.each(meta, function (value, key) {
			win.find('#' + key).value(value);
		});
	};

	var showDialog = function (editor) {
		var win;
		var data;

		var generalFormItems = [
			{
				name: 'source1',
				type: 'filepicker',
				filetype: 'media',
				size: 40,
				autofocus: true,
				label: 'Source',
				onpaste: function () {
					setTimeout(function () {
						Service.getEmbedHtml(editor, win.toJSON())
							.then(
								addEmbedHtml(win, editor)
							)["catch"](handleError(editor));
					}, 1);
				},
				onchange: function (e) {
					Service.getEmbedHtml(editor, win.toJSON())
						.then(
							addEmbedHtml(win, editor)
						)["catch"](handleError(editor));

					populateMeta(win, e.meta);
				},
				onbeforecall: function (e) {
					e.meta = win.toJSON();
				}
			}
		];

		var advancedFormItems = [];

		var reserialise = function (update) {
			update(win);
			data = win.toJSON();
			win.find('#embed').value(UpdateHtml.updateHtml(data.embed, data));
		};

		if (editor.settings.media_alt_source !== false) {
			advancedFormItems.push({name: 'source2', type: 'filepicker', filetype: 'media', size: 40, label: 'Alternative source'});
		}

		if (editor.settings.media_poster !== false) {
			advancedFormItems.push({name: 'poster', type: 'filepicker', filetype: 'image', size: 40, label: 'Poster'});
		}

		if (editor.settings.media_dimensions !== false) {
			var control = SizeManager.createUi(reserialise);
			generalFormItems.push(control);
		}

		data = getData(editor);

		var embedTextBox = {
			id: 'mcemediasource',
			type: 'textbox',
			flex: 1,
			name: 'embed',
			value: getSource(editor),
			multiline: true,
			rows: 5,
			label: 'Source'
		};

		var updateValueOnChange = function () {
			data = Tools.extend({}, HtmlToData.htmlToData(editor.settings.media_scripts, this.value()));
			this.parent().parent().fromJSON(data);
		};

		embedTextBox[embedChange] = updateValueOnChange;

		win = editor.windowManager.open({
			title: 'Insert/edit media',
			data: data,
			bodyType: 'tabpanel',
			body: [
				{
					title: 'General',
					type: "form",
					items: generalFormItems
				},

				{
					title: 'Embed',
					type: "container",
					layout: 'flex',
					direction: 'column',
					align: 'stretch',
					padding: 10,
					spacing: 10,
					items: [
						{
							type: 'label',
							text: 'Paste your embed code below:',
							forId: 'mcemediasource'
						},
						embedTextBox
					]
				},

				{
					title: 'Advanced',
					type: "form",
					items: advancedFormItems
				}
			],
			onSubmit: function () {
				SizeManager.updateSize(win);
				submitForm(win, editor);
			}
		});

		SizeManager.syncSize(win);
	};

	return {
		showDialog: showDialog
	};
});
define('tinymce.media.core.Sanitize', [
	'global!tinymce.util.Tools',
	'global!tinymce.html.Writer',
	'global!tinymce.html.SaxParser',
	'global!tinymce.html.Schema'
], function (Tools, Writer, SaxParser, Schema) {
	var sanitize = function (editor, html) {
		if (editor.settings.media_filter_html === false) {
			return html;
		}

		var writer = new Writer();
		var blocked;

		new SaxParser({
			validate: false,
			allow_conditional_comments: false,
			special: 'script,noscript',

			comment: function (text) {
				writer.comment(text);
			},

			cdata: function (text) {
				writer.cdata(text);
			},

			text: function (text, raw) {
				writer.text(text, raw);
			},

			start: function (name, attrs, empty) {
				blocked = true;

				if (name === 'script' || name === 'noscript') {
					return;
				}

				for (var i = 0; i < attrs.length; i++) {
					if (attrs[i].name.indexOf('on') === 0) {
						return;
					}

					if (attrs[i].name === 'style') {
						attrs[i].value = editor.dom.serializeStyle(editor.dom.parseStyle(attrs[i].value), name);
					}
				}

				writer.start(name, attrs, empty);
				blocked = false;
			},

			end: function (name) {
				if (blocked) {
					return;
				}

				writer.end(name);
			}
		}, new Schema({})).parse(html);

		return writer.getContent();
	};

	return {
		sanitize: sanitize
	};
});
defineGlobal("global!tinymce.html.Node", tinymce.html.Node);
define('tinymce.media.core.Nodes', [
	'tinymce.media.core.Sanitize',
	'tinymce.media.core.VideoScript',
	'global!tinymce.html.Node',
	'global!tinymce.Env'
], function (Sanitize, VideoScript, Node, Env) {
	var createPlaceholderNode = function (editor, node) {
		var placeHolder;
		var name = node.name;

		placeHolder = new Node('img', 1);
		placeHolder.shortEnded = true;

		retainAttributesAndInnerHtml(editor, node, placeHolder);

		placeHolder.attr({
			width: node.attr('width') || "300",
			height: node.attr('height') || (name === "audio" ? "30" : "150"),
			style: node.attr('style'),
			src: Env.transparentSrc,
			"data-mce-object": name,
			"class": "mce-object mce-object-" + name
		});

		return placeHolder;
	};

	var createPreviewIframeNode = function (editor, node) {
		var previewWrapper;
		var previewNode;
		var shimNode;
		var name = node.name;

		previewWrapper = new Node('span', 1);
		previewWrapper.attr({
			contentEditable: 'false',
			style: node.attr('style'),
			"data-mce-object": name,
			"class": "mce-preview-object mce-object-" + name
		});

		retainAttributesAndInnerHtml(editor, node, previewWrapper);

		previewNode = new Node(name, 1);
		previewNode.attr({
			src: node.attr('src'),
			allowfullscreen: node.attr('allowfullscreen'),
			width: node.attr('width') || "300",
			height: node.attr('height') || (name === "audio" ? "30" : "150"),
			frameborder: '0'
		});

		shimNode = new Node('span', 1);
		shimNode.attr('class', 'mce-shim');

		previewWrapper.append(previewNode);
		previewWrapper.append(shimNode);

		return previewWrapper;
	};

	var retainAttributesAndInnerHtml = function (editor, sourceNode, targetNode) {
		var attrName;
		var attrValue;
		var attribs;
		var ai;
		var innerHtml;

		// Prefix all attributes except width, height and style since we
		// will add these to the placeholder
		attribs = sourceNode.attributes;
		ai = attribs.length;
		while (ai--) {
			attrName = attribs[ai].name;
			attrValue = attribs[ai].value;

			if (attrName !== "width" && attrName !== "height" && attrName !== "style") {
				if (attrName === "data" || attrName === "src") {
					attrValue = editor.convertURL(attrValue, attrName);
				}

				targetNode.attr('data-mce-p-' + attrName, attrValue);
			}
		}

		// Place the inner HTML contents inside an escaped attribute
		// This enables us to copy/paste the fake object
		innerHtml = sourceNode.firstChild && sourceNode.firstChild.value;
		if (innerHtml) {
			targetNode.attr("data-mce-html", escape(Sanitize.sanitize(editor, innerHtml)));
			targetNode.firstChild = null;
		}
	};

	var isWithinEphoxEmbed = function (node) {
		while ((node = node.parent)) {
			if (node.attr('data-ephox-embed-iri')) {
				return true;
			}
		}

		return false;
	};

	var placeHolderConverter = function (editor) {
		return function (nodes) {
			var i = nodes.length;
			var node;
			var videoScript;

			while (i--) {
				node = nodes[i];
				if (!node.parent) {
					continue;
				}

				if (node.parent.attr('data-mce-object')) {
					continue;
				}

				if (node.name === 'script') {
					videoScript = VideoScript.getVideoScriptMatch(editor.settings.media_scripts, node.attr('src'));
					if (!videoScript) {
						continue;
					}
				}

				if (videoScript) {
					if (videoScript.width) {
						node.attr('width', videoScript.width.toString());
					}

					if (videoScript.height) {
						node.attr('height', videoScript.height.toString());
					}
				}

				if (node.name === 'iframe' && editor.settings.media_live_embeds !== false && Env.ceFalse) {
					if (!isWithinEphoxEmbed(node)) {
						node.replace(createPreviewIframeNode(editor, node));
					}
				} else {
					if (!isWithinEphoxEmbed(node)) {
						node.replace(createPlaceholderNode(editor, node));
					}
				}
			}
		};
	};

	return {
		createPreviewIframeNode: createPreviewIframeNode,
		createPlaceholderNode: createPlaceholderNode,
		placeHolderConverter: placeHolderConverter
	};
});
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*jshint maxlen:255 */
/*eslint max-len:0 */
/*global tinymce:true */

define('tinymce.media.Plugin', [
	'global!tinymce.PluginManager',
	'tinymce.media.ui.Dialog',
	'tinymce.media.core.Sanitize',
	'tinymce.media.core.UpdateHtml',
	'tinymce.media.core.Nodes'
], function (PluginManager, Dialog, Sanitize, UpdateHtml, Nodes) {
	var Plugin = function (editor) {
		editor.on('ResolveName', function (e) {
			var name;

			if (e.target.nodeType === 1 && (name = e.target.getAttribute("data-mce-object"))) {
				e.name = name;
			}
		});

		editor.on('preInit', function () {
			// Make sure that any messy HTML is retained inside these
			var specialElements = editor.schema.getSpecialElements();
			tinymce.each('video audio iframe object'.split(' '), function (name) {
				specialElements[name] = new RegExp('<\/' + name + '[^>]*>', 'gi');
			});

			// Allow elements
			//editor.schema.addValidElements('object[id|style|width|height|classid|codebase|*],embed[id|style|width|height|type|src|*],video[*],audio[*]');

			// Set allowFullscreen attribs as boolean
			var boolAttrs = editor.schema.getBoolAttrs();
			tinymce.each('webkitallowfullscreen mozallowfullscreen allowfullscreen'.split(' '), function (name) {
				boolAttrs[name] = {};
			});

			// Converts iframe, video etc into placeholder images
			editor.parser.addNodeFilter('iframe,video,audio,object,embed,script',
				Nodes.placeHolderConverter(editor));

			// Replaces placeholder images with real elements for video, object, iframe etc
			editor.serializer.addAttributeFilter('data-mce-object', function (nodes, name) {
				var i = nodes.length;
				var node;
				var realElm;
				var ai;
				var attribs;
				var innerHtml;
				var innerNode;
				var realElmName;
				var className;

				while (i--) {
					node = nodes[i];
					if (!node.parent) {
						continue;
					}

					realElmName = node.attr(name);
					realElm = new tinymce.html.Node(realElmName, 1);

					// Add width/height to everything but audio
					if (realElmName !== "audio" && realElmName !== "script") {
						className = node.attr('class');
						if (className && className.indexOf('mce-preview-object') !== -1) {
							realElm.attr({
								width: node.firstChild.attr('width'),
								height: node.firstChild.attr('height')
							});
						} else {
							realElm.attr({
								width: node.attr('width'),
								height: node.attr('height')
							});
						}
					}

					realElm.attr({
						style: node.attr('style')
					});

					// Unprefix all placeholder attributes
					attribs = node.attributes;
					ai = attribs.length;
					while (ai--) {
						var attrName = attribs[ai].name;

						if (attrName.indexOf('data-mce-p-') === 0) {
							realElm.attr(attrName.substr(11), attribs[ai].value);
						}
					}

					if (realElmName === "script") {
						realElm.attr('type', 'text/javascript');
					}

					// Inject innerhtml
					innerHtml = node.attr('data-mce-html');
					if (innerHtml) {
						innerNode = new tinymce.html.Node('#text', 3);
						innerNode.raw = true;
						innerNode.value = Sanitize.sanitize(editor, unescape(innerHtml));
						realElm.append(innerNode);
					}

					node.replace(realElm);
				}
			});
		});

		editor.on('click keyup', function () {
			var selectedNode = editor.selection.getNode();

			if (selectedNode && editor.dom.hasClass(selectedNode, 'mce-preview-object')) {
				if (editor.dom.getAttrib(selectedNode, 'data-mce-selected')) {
					selectedNode.setAttribute('data-mce-selected', '2');
				}
			}
		});

		editor.on('ObjectSelected', function (e) {
			var objectType = e.target.getAttribute('data-mce-object');

			if (objectType === "audio" || objectType === "script") {
				e.preventDefault();
			}
		});

		editor.on('objectResized', function (e) {
			var target = e.target;
			var html;

			if (target.getAttribute('data-mce-object')) {
				html = target.getAttribute('data-mce-html');
				if (html) {
					html = unescape(html);
					target.setAttribute('data-mce-html', escape(
						UpdateHtml.updateHtml(html, {
							width: e.width,
							height: e.height
						})
					));
				}
			}
		});

		this.showDialog = function () {
			Dialog.showDialog(editor);
		};

		editor.addButton('media', {
			tooltip: 'Insert/edit media',
			onclick: this.showDialog,
			stateSelector: ['img[data-mce-object]', 'span[data-mce-object]', 'div[data-ephox-embed-iri]']
		});

		editor.addMenuItem('media', {
			icon: 'media',
			text: 'Media',
			onclick: this.showDialog,
			context: 'insert',
			prependToContext: true
		});

		editor.on('setContent', function () {
			// TODO: This shouldn't be needed there should be a way to mark bogus
			// elements so they are never removed except external save
			editor.$('span.mce-preview-object').each(function (index, elm) {
				var $elm = editor.$(elm);

				if ($elm.find('span.mce-shim', elm).length === 0) {
					$elm.append('<span class="mce-shim"></span>');
				}
			});
		});

		editor.addCommand('mceMedia', this.showDialog);
	};

	PluginManager.add('media', Plugin);

	return function () {};
});


dem('tinymce.media.Plugin')();
})();

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('nonbreaking', function(editor) {
	var setting = editor.getParam('nonbreaking_force_tab');

	editor.addCommand('mceNonBreaking', function() {
		editor.insertContent(
			(editor.plugins.visualchars && editor.plugins.visualchars.state) ?
			'<span class="mce-nbsp">&nbsp;</span>' : '&nbsp;'
		);

		editor.dom.setAttrib(editor.dom.select('span.mce-nbsp'), 'data-mce-bogus', '1');
	});

	editor.addButton('nonbreaking', {
		title: 'Nonbreaking space',
		cmd: 'mceNonBreaking'
	});

	editor.addMenuItem('nonbreaking', {
		text: 'Nonbreaking space',
		cmd: 'mceNonBreaking',
		context: 'insert'
	});

	if (setting) {
		var spaces = +setting > 1 ? +setting : 3;  // defaults to 3 spaces if setting is true (or 1)

		editor.on('keydown', function(e) {
			if (e.keyCode == 9) {

				if (e.shiftKey) {
					return;
				}

				e.preventDefault();
				for (var i = 0; i < spaces; i++) {
					editor.execCommand('mceNonBreaking');
				}
			}
		});
	}
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('noneditable', function(editor) {
	var editClass, nonEditClass, nonEditableRegExps, contentEditableAttrName = 'contenteditable';

	function hasClass(checkClassName) {
		return function(node) {
			return (" " + node.attr("class") + " ").indexOf(checkClassName) !== -1;
		};
	}

	function convertRegExpsToNonEditable(e) {
		var i = nonEditableRegExps.length, content = e.content, cls = tinymce.trim(nonEditClass);

		function replaceMatchWithSpan(match) {
			var args = arguments, index = args[args.length - 2];
			var prevChar = index > 0 ? content.charAt(index - 1) : '';

			// Is value inside an attribute then don't replace
			if (prevChar === '"') {
				return match;
			}

			// Is value inside a contentEditable="false" tag
			if (prevChar === '>') {
				var findStartTagIndex = content.lastIndexOf('<', index);
				if (findStartTagIndex !== -1) {
					var tagHtml = content.substring(findStartTagIndex, index);
					if (tagHtml.indexOf('contenteditable="false"') !== -1) {
						return match;
					}
				}
			}

			return (
				'<span class="' + cls + '" data-mce-content="' + editor.dom.encode(args[0]) + '">' +
				editor.dom.encode(typeof args[1] === "string" ? args[1] : args[0]) + '</span>'
			);
		}

		// Don't replace the variables when raw is used for example on undo/redo
		if (e.format == "raw") {
			return;
		}

		while (i--) {
			content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan);
		}

		e.content = content;
	}

	editClass = " " + tinymce.trim(editor.getParam("noneditable_editable_class", "mceEditable")) + " ";
	nonEditClass = " " + tinymce.trim(editor.getParam("noneditable_noneditable_class", "mceNonEditable")) + " ";

	var hasEditClass = hasClass(editClass);
	var hasNonEditClass = hasClass(nonEditClass);

	nonEditableRegExps = editor.getParam("noneditable_regexp");
	if (nonEditableRegExps && !nonEditableRegExps.length) {
		nonEditableRegExps = [nonEditableRegExps];
	}

	editor.on('PreInit', function() {
		if (nonEditableRegExps) {
			editor.on('BeforeSetContent', convertRegExpsToNonEditable);
		}

		editor.parser.addAttributeFilter('class', function(nodes) {
			var i = nodes.length, node;

			while (i--) {
				node = nodes[i];

				if (hasEditClass(node)) {
					node.attr(contentEditableAttrName, "true");
				} else if (hasNonEditClass(node)) {
					node.attr(contentEditableAttrName, "false");
				}
			}
		});

		editor.serializer.addAttributeFilter(contentEditableAttrName, function(nodes) {
			var i = nodes.length, node;

			while (i--) {
				node = nodes[i];
				if (!hasEditClass(node) && !hasNonEditClass(node)) {
					continue;
				}

				if (nonEditableRegExps && node.attr('data-mce-content')) {
					node.name = "#text";
					node.type = 3;
					node.raw = true;
					node.value = node.attr('data-mce-content');
				} else {
					node.attr(contentEditableAttrName, null);
				}
			}
		});
	});
});
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('pagebreak', function(editor) {
	var pageBreakClass = 'mce-pagebreak', separatorHtml = editor.getParam('pagebreak_separator', '<!-- pagebreak -->');

	var pageBreakSeparatorRegExp = new RegExp(separatorHtml.replace(/[\?\.\*\[\]\(\)\{\}\+\^\$\:]/g, function(a) {
		return '\\' + a;
	}), 'gi');

	var pageBreakPlaceHolderHtml = '<img src="' + tinymce.Env.transparentSrc + '" class="' +
		pageBreakClass + '" data-mce-resize="false" data-mce-placeholder />';

	// Register commands
	editor.addCommand('mcePageBreak', function() {
		if (editor.settings.pagebreak_split_block) {
			editor.insertContent('<p>' + pageBreakPlaceHolderHtml + '</p>');
		} else {
			editor.insertContent(pageBreakPlaceHolderHtml);
		}
	});

	// Register buttons
	editor.addButton('pagebreak', {
		title: 'Page break',
		cmd: 'mcePageBreak'
	});

	editor.addMenuItem('pagebreak', {
		text: 'Page break',
		icon: 'pagebreak',
		cmd: 'mcePageBreak',
		context: 'insert'
	});

	editor.on('ResolveName', function(e) {
		if (e.target.nodeName == 'IMG' && editor.dom.hasClass(e.target, pageBreakClass)) {
			e.name = 'pagebreak';
		}
	});

	editor.on('click', function(e) {
		e = e.target;

		if (e.nodeName === 'IMG' && editor.dom.hasClass(e, pageBreakClass)) {
			editor.selection.select(e);
		}
	});

	editor.on('BeforeSetContent', function(e) {
		e.content = e.content.replace(pageBreakSeparatorRegExp, pageBreakPlaceHolderHtml);
	});

	editor.on('PreInit', function() {
		editor.serializer.addNodeFilter('img', function(nodes) {
			var i = nodes.length, node, className;

			while (i--) {
				node = nodes[i];
				className = node.attr('class');
				if (className && className.indexOf('mce-pagebreak') !== -1) {
					// Replace parent block node if pagebreak_split_block is enabled
					var parentNode = node.parent;
					if (editor.schema.getBlockElements()[parentNode.name] && editor.settings.pagebreak_split_block) {
						parentNode.type = 3;
						parentNode.value = separatorHtml;
						parentNode.raw = true;
						node.remove();
						continue;
					}

					node.type = 3;
					node.value = separatorHtml;
					node.raw = true;
				}
			}
		});
	});
});

/**
 * Compiled inline version. (Library mode)
 */

/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */
/*globals $code */

(function(exports, undefined) {
	"use strict";

	var modules = {};

	function require(ids, callback) {
		var module, defs = [];

		for (var i = 0; i < ids.length; ++i) {
			module = modules[ids[i]] || resolve(ids[i]);
			if (!module) {
				throw 'module definition dependecy not found: ' + ids[i];
			}

			defs.push(module);
		}

		callback.apply(null, defs);
	}

	function define(id, dependencies, definition) {
		if (typeof id !== 'string') {
			throw 'invalid module definition, module id must be defined and be a string';
		}

		if (dependencies === undefined) {
			throw 'invalid module definition, dependencies must be specified';
		}

		if (definition === undefined) {
			throw 'invalid module definition, definition function must be specified';
		}

		require(dependencies, function() {
			modules[id] = definition.apply(null, arguments);
		});
	}

	function defined(id) {
		return !!modules[id];
	}

	function resolve(id) {
		var target = exports;
		var fragments = id.split(/[.\/]/);

		for (var fi = 0; fi < fragments.length; ++fi) {
			if (!target[fragments[fi]]) {
				return;
			}

			target = target[fragments[fi]];
		}

		return target;
	}

	function expose(ids) {
		var i, target, id, fragments, privateModules;

		for (i = 0; i < ids.length; i++) {
			target = exports;
			id = ids[i];
			fragments = id.split(/[.\/]/);

			for (var fi = 0; fi < fragments.length - 1; ++fi) {
				if (target[fragments[fi]] === undefined) {
					target[fragments[fi]] = {};
				}

				target = target[fragments[fi]];
			}

			target[fragments[fragments.length - 1]] = modules[id];
		}

		// Expose private modules for unit tests
		if (exports.AMDLC_TESTS) {
			privateModules = exports.privateModules || {};

			for (id in modules) {
				privateModules[id] = modules[id];
			}

			for (i = 0; i < ids.length; i++) {
				delete privateModules[ids[i]];
			}

			exports.privateModules = privateModules;
		}
	}

// Included from: js/tinymce/plugins/paste/classes/Utils.js

/**
 * Utils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * This class contails various utility functions for the paste plugin.
 *
 * @class tinymce.pasteplugin.Utils
 */
define("tinymce/pasteplugin/Utils", [
	"tinymce/util/Tools",
	"tinymce/html/DomParser",
	"tinymce/html/Schema"
], function(Tools, DomParser, Schema) {
	function filter(content, items) {
		Tools.each(items, function(v) {
			if (v.constructor == RegExp) {
				content = content.replace(v, '');
			} else {
				content = content.replace(v[0], v[1]);
			}
		});

		return content;
	}

	/**
	 * Gets the innerText of the specified element. It will handle edge cases
	 * and works better than textContent on Gecko.
	 *
	 * @param {String} html HTML string to get text from.
	 * @return {String} String of text with line feeds.
	 */
	function innerText(html) {
		var schema = new Schema(), domParser = new DomParser({}, schema), text = '';
		var shortEndedElements = schema.getShortEndedElements();
		var ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');
		var blockElements = schema.getBlockElements();

		function walk(node) {
			var name = node.name, currentNode = node;

			if (name === 'br') {
				text += '\n';
				return;
			}

			// img/input/hr
			if (shortEndedElements[name]) {
				text += ' ';
			}

			// Ingore script, video contents
			if (ignoreElements[name]) {
				text += ' ';
				return;
			}

			if (node.type == 3) {
				text += node.value;
			}

			// Walk all children
			if (!node.shortEnded) {
				if ((node = node.firstChild)) {
					do {
						walk(node);
					} while ((node = node.next));
				}
			}

			// Add \n or \n\n for blocks or P
			if (blockElements[name] && currentNode.next) {
				text += '\n';

				if (name == 'p') {
					text += '\n';
				}
			}
		}

		html = filter(html, [
			/<!\[[^\]]+\]>/g // Conditional comments
		]);

		walk(domParser.parse(html));

		return text;
	}

	/**
	 * Trims the specified HTML by removing all WebKit fragments, all elements wrapping the body trailing BR elements etc.
	 *
	 * @param {String} html Html string to trim contents on.
	 * @return {String} Html contents that got trimmed.
	 */
	function trimHtml(html) {
		function trimSpaces(all, s1, s2) {
			// WebKit &nbsp; meant to preserve multiple spaces but instead inserted around all inline tags,
			// including the spans with inline styles created on paste
			if (!s1 && !s2) {
				return ' ';
			}

			return '\u00a0';
		}

		html = filter(html, [
			/^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/g, // Remove anything but the contents within the BODY element
			/<!--StartFragment-->|<!--EndFragment-->/g, // Inner fragments (tables from excel on mac)
			[/( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g, trimSpaces],
			/<br class="Apple-interchange-newline">/g,
			/<br>$/i // Trailing BR elements
		]);

		return html;
	}

	// TODO: Should be in some global class
	function createIdGenerator(prefix) {
		var count = 0;

		return function() {
			return prefix + (count++);
		};
	}

	return {
		filter: filter,
		innerText: innerText,
		trimHtml: trimHtml,
		createIdGenerator: createIdGenerator
	};
});

// Included from: js/tinymce/plugins/paste/classes/SmartPaste.js

/**
 * SmartPaste.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Tries to be smart depending on what the user pastes if it looks like an url
 * it will make a link out of the current selection. If it's an image url that looks
 * like an image it will check if it's an image and insert it as an image.
 *
 * @class tinymce.pasteplugin.SmartPaste
 * @private
 */
define("tinymce/pasteplugin/SmartPaste", [
	"tinymce/util/Tools"
], function (Tools) {
	var isAbsoluteUrl = function (url) {
		return /^https?:\/\/[\w\?\-\/+=.&%@~#]+$/i.test(url);
	};

	var isImageUrl = function (url) {
		return isAbsoluteUrl(url) && /.(gif|jpe?g|png)$/.test(url);
	};

	var createImage = function (editor, url, pasteHtml) {
		editor.undoManager.extra(function () {
			pasteHtml(editor, url);
		}, function () {
			editor.insertContent('<img src="' + url + '">');
		});

		return true;
	};

	var createLink = function (editor, url, pasteHtml) {
		editor.undoManager.extra(function () {
			pasteHtml(editor, url);
		}, function () {
			editor.execCommand('mceInsertLink', false, url);
		});

		return true;
	};

	var linkSelection = function (editor, html, pasteHtml) {
		return editor.selection.isCollapsed() === false && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtml) : false;
	};

	var insertImage = function (editor, html, pasteHtml) {
		return isImageUrl(html) ? createImage(editor, html, pasteHtml) : false;
	};

	var pasteHtml = function (editor, html) {
		editor.insertContent(html, {
			merge: editor.settings.paste_merge_formats !== false,
			paste: true
		});

		return true;
	};

	var smartInsertContent = function (editor, html) {
		Tools.each([
			linkSelection,
			insertImage,
			pasteHtml
		], function (action) {
			return action(editor, html, pasteHtml) !== true;
		});
	};

	var insertContent = function (editor, html) {
		if (editor.settings.smart_paste === false) {
			pasteHtml(editor, html);
		} else {
			smartInsertContent(editor, html);
		}
	};

	return {
		isImageUrl: isImageUrl,
		isAbsoluteUrl: isAbsoluteUrl,
		insertContent: insertContent
	};
});

// Included from: js/tinymce/plugins/paste/classes/Clipboard.js

/**
 * Clipboard.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * This class contains logic for getting HTML contents out of the clipboard.
 *
 * We need to make a lot of ugly hacks to get the contents out of the clipboard since
 * the W3C Clipboard API is broken in all browsers that have it: Gecko/WebKit/Blink.
 * We might rewrite this the way those API:s stabilize. Browsers doesn't handle pasting
 * from applications like Word the same way as it does when pasting into a contentEditable area
 * so we need to do lots of extra work to try to get to this clipboard data.
 *
 * Current implementation steps:
 *  1. On keydown with paste keys Ctrl+V or Shift+Insert create
 *     a paste bin element and move focus to that element.
 *  2. Wait for the browser to fire a "paste" event and get the contents out of the paste bin.
 *  3. Check if the paste was successful if true, process the HTML.
 *  (4). If the paste was unsuccessful use IE execCommand, Clipboard API, document.dataTransfer old WebKit API etc.
 *
 * @class tinymce.pasteplugin.Clipboard
 * @private
 */
define("tinymce/pasteplugin/Clipboard", [
	"tinymce/Env",
	"tinymce/dom/RangeUtils",
	"tinymce/util/VK",
	"tinymce/pasteplugin/Utils",
	"tinymce/pasteplugin/SmartPaste",
	"tinymce/util/Delay"
], function(Env, RangeUtils, VK, Utils, SmartPaste, Delay) {
	return function(editor) {
		var self = this, pasteBinElm, lastRng, keyboardPasteTimeStamp = 0, draggingInternally = false;
		var pasteBinDefaultContent = '%MCEPASTEBIN%', keyboardPastePlainTextState;
		var mceInternalUrlPrefix = 'data:text/mce-internal,';
		var uniqueId = Utils.createIdGenerator("mceclip");

		/**
		 * Pastes the specified HTML. This means that the HTML is filtered and then
		 * inserted at the current selection in the editor. It will also fire paste events
		 * for custom user filtering.
		 *
		 * @param {String} html HTML code to paste into the current selection.
		 */
		function pasteHtml(html) {
			var args, dom = editor.dom;

			args = editor.fire('BeforePastePreProcess', {content: html}); // Internal event used by Quirks
			args = editor.fire('PastePreProcess', args);
			html = args.content;

			if (!args.isDefaultPrevented()) {
				// User has bound PastePostProcess events then we need to pass it through a DOM node
				// This is not ideal but we don't want to let the browser mess up the HTML for example
				// some browsers add &nbsp; to P tags etc
				if (editor.hasEventListeners('PastePostProcess') && !args.isDefaultPrevented()) {
					// We need to attach the element to the DOM so Sizzle selectors work on the contents
					var tempBody = dom.add(editor.getBody(), 'div', {style: 'display:none'}, html);
					args = editor.fire('PastePostProcess', {node: tempBody});
					dom.remove(tempBody);
					html = args.node.innerHTML;
				}

				if (!args.isDefaultPrevented()) {
					SmartPaste.insertContent(editor, html);
				}
			}
		}

		/**
		 * Pastes the specified text. This means that the plain text is processed
		 * and converted into BR and P elements. It will fire paste events for custom filtering.
		 *
		 * @param {String} text Text to paste as the current selection location.
		 */
		function pasteText(text) {
			text = editor.dom.encode(text).replace(/\r\n/g, '\n');

			var startBlock = editor.dom.getParent(editor.selection.getStart(), editor.dom.isBlock);

			// Create start block html for example <p attr="value">
			var forcedRootBlockName = editor.settings.forced_root_block;
			var forcedRootBlockStartHtml;
			if (forcedRootBlockName) {
				forcedRootBlockStartHtml = editor.dom.createHTML(forcedRootBlockName, editor.settings.forced_root_block_attrs);
				forcedRootBlockStartHtml = forcedRootBlockStartHtml.substr(0, forcedRootBlockStartHtml.length - 3) + '>';
			}

			if ((startBlock && /^(PRE|DIV)$/.test(startBlock.nodeName)) || !forcedRootBlockName) {
				text = Utils.filter(text, [
					[/\n/g, "<br>"]
				]);
			} else {
				text = Utils.filter(text, [
					[/\n\n/g, "</p>" + forcedRootBlockStartHtml],
					[/^(.*<\/p>)(<p>)$/, forcedRootBlockStartHtml + '$1'],
					[/\n/g, "<br />"]
				]);

				if (text.indexOf('<p>') != -1) {
					text = forcedRootBlockStartHtml + text;
				}
			}

			pasteHtml(text);
		}

		/**
		 * Creates a paste bin element as close as possible to the current caret location and places the focus inside that element
		 * so that when the real paste event occurs the contents gets inserted into this element
		 * instead of the current editor selection element.
		 */
		function createPasteBin() {
			var dom = editor.dom, body = editor.getBody();
			var viewport = editor.dom.getViewPort(editor.getWin()), scrollTop = viewport.y, top = 20;
			var scrollContainer;

			lastRng = editor.selection.getRng();

			if (editor.inline) {
				scrollContainer = editor.selection.getScrollContainer();

				// Can't always rely on scrollTop returning a useful value.
				// It returns 0 if the browser doesn't support scrollTop for the element or is non-scrollable
				if (scrollContainer && scrollContainer.scrollTop > 0) {
					scrollTop = scrollContainer.scrollTop;
				}
			}

			/**
			 * Returns the rect of the current caret if the caret is in an empty block before a
			 * BR we insert a temporary invisible character that we get the rect this way we always get a proper rect.
			 *
			 * TODO: This might be useful in core.
			 */
			function getCaretRect(rng) {
				var rects, textNode, node, container = rng.startContainer;

				rects = rng.getClientRects();
				if (rects.length) {
					return rects[0];
				}

				if (!rng.collapsed || container.nodeType != 1) {
					return;
				}

				node = container.childNodes[lastRng.startOffset];

				// Skip empty whitespace nodes
				while (node && node.nodeType == 3 && !node.data.length) {
					node = node.nextSibling;
				}

				if (!node) {
					return;
				}

				// Check if the location is |<br>
				// TODO: Might need to expand this to say |<table>
				if (node.tagName == 'BR') {
					textNode = dom.doc.createTextNode('\uFEFF');
					node.parentNode.insertBefore(textNode, node);

					rng = dom.createRng();
					rng.setStartBefore(textNode);
					rng.setEndAfter(textNode);

					rects = rng.getClientRects();
					dom.remove(textNode);
				}

				if (rects.length) {
					return rects[0];
				}
			}

			// Calculate top cordinate this is needed to avoid scrolling to top of document
			// We want the paste bin to be as close to the caret as possible to avoid scrolling
			if (lastRng.getClientRects) {
				var rect = getCaretRect(lastRng);

				if (rect) {
					// Client rects gets us closes to the actual
					// caret location in for example a wrapped paragraph block
					top = scrollTop + (rect.top - dom.getPos(body).y);
				} else {
					top = scrollTop;

					// Check if we can find a closer location by checking the range element
					var container = lastRng.startContainer;
					if (container) {
						if (container.nodeType == 3 && container.parentNode != body) {
							container = container.parentNode;
						}

						if (container.nodeType == 1) {
							top = dom.getPos(container, scrollContainer || body).y;
						}
					}
				}
			}

			// Create a pastebin
			pasteBinElm = dom.add(editor.getBody(), 'div', {
				id: "mcepastebin",
				contentEditable: true,
				"data-mce-bogus": "all",
				style: 'position: absolute; top: ' + top + 'px;' +
					'width: 10px; height: 10px; overflow: hidden; opacity: 0'
			}, pasteBinDefaultContent);

			// Move paste bin out of sight since the controlSelection rect gets displayed otherwise on IE and Gecko
			if (Env.ie || Env.gecko) {
				dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) == 'rtl' ? 0xFFFF : -0xFFFF);
			}

			// Prevent focus events from bubbeling fixed FocusManager issues
			dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', function(e) {
				e.stopPropagation();
			});

			pasteBinElm.focus();
			editor.selection.select(pasteBinElm, true);
		}

		/**
		 * Removes the paste bin if it exists.
		 */
		function removePasteBin() {
			if (pasteBinElm) {
				var pasteBinClone;

				// WebKit/Blink might clone the div so
				// lets make sure we remove all clones
				// TODO: Man o man is this ugly. WebKit is the new IE! Remove this if they ever fix it!
				while ((pasteBinClone = editor.dom.get('mcepastebin'))) {
					editor.dom.remove(pasteBinClone);
					editor.dom.unbind(pasteBinClone);
				}

				if (lastRng) {
					editor.selection.setRng(lastRng);
				}
			}

			pasteBinElm = lastRng = null;
		}

		/**
		 * Returns the contents of the paste bin as a HTML string.
		 *
		 * @return {String} Get the contents of the paste bin.
		 */
		function getPasteBinHtml() {
			var html = '', pasteBinClones, i, clone, cloneHtml;

			// Since WebKit/Chrome might clone the paste bin when pasting
			// for example: <img style="float: right"> we need to check if any of them contains some useful html.
			// TODO: Man o man is this ugly. WebKit is the new IE! Remove this if they ever fix it!
			pasteBinClones = editor.dom.select('div[id=mcepastebin]');
			for (i = 0; i < pasteBinClones.length; i++) {
				clone = pasteBinClones[i];

				// Pasting plain text produces pastebins in pastebinds makes sence right!?
				if (clone.firstChild && clone.firstChild.id == 'mcepastebin') {
					clone = clone.firstChild;
				}

				cloneHtml = clone.innerHTML;
				if (html != pasteBinDefaultContent) {
					html += cloneHtml;
				}
			}

			return html;
		}

		/**
		 * Gets various content types out of a datatransfer object.
		 *
		 * @param {DataTransfer} dataTransfer Event fired on paste.
		 * @return {Object} Object with mime types and data for those mime types.
		 */
		function getDataTransferItems(dataTransfer) {
			var items = {};

			if (dataTransfer) {
				// Use old WebKit/IE API
				if (dataTransfer.getData) {
					var legacyText = dataTransfer.getData('Text');
					if (legacyText && legacyText.length > 0) {
						if (legacyText.indexOf(mceInternalUrlPrefix) == -1) {
							items['text/plain'] = legacyText;
						}
					}
				}

				if (dataTransfer.types) {
					for (var i = 0; i < dataTransfer.types.length; i++) {
						var contentType = dataTransfer.types[i];
						items[contentType] = dataTransfer.getData(contentType);
					}
				}
			}

			return items;
		}

		/**
		 * Gets various content types out of the Clipboard API. It will also get the
		 * plain text using older IE and WebKit API:s.
		 *
		 * @param {ClipboardEvent} clipboardEvent Event fired on paste.
		 * @return {Object} Object with mime types and data for those mime types.
		 */
		function getClipboardContent(clipboardEvent) {
			return getDataTransferItems(clipboardEvent.clipboardData || editor.getDoc().dataTransfer);
		}

		function hasHtmlOrText(content) {
			return hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');
		}

		function getBase64FromUri(uri) {
			var idx;

			idx = uri.indexOf(',');
			if (idx !== -1) {
				return uri.substr(idx + 1);
			}

			return null;
		}

		function isValidDataUriImage(settings, imgElm) {
			return settings.images_dataimg_filter ? settings.images_dataimg_filter(imgElm) : true;
		}

		function pasteImage(rng, reader, blob) {
			if (rng) {
				editor.selection.setRng(rng);
				rng = null;
			}

			var dataUri = reader.result;
			var base64 = getBase64FromUri(dataUri);

			var img = new Image();
			img.src = dataUri;

			// TODO: Move the bulk of the cache logic to EditorUpload
			if (isValidDataUriImage(editor.settings, img)) {
				var blobCache = editor.editorUpload.blobCache;
				var blobInfo, existingBlobInfo;

				existingBlobInfo = blobCache.findFirst(function(cachedBlobInfo) {
					return cachedBlobInfo.base64() === base64;
				});

				if (!existingBlobInfo) {
					blobInfo = blobCache.create(uniqueId(), blob, base64);
					blobCache.add(blobInfo);
				} else {
					blobInfo = existingBlobInfo;
				}

				pasteHtml('<img src="' + blobInfo.blobUri() + '">');
			} else {
				pasteHtml('<img src="' + dataUri + '">');
			}
		}

		/**
		 * Checks if the clipboard contains image data if it does it will take that data
		 * and convert it into a data url image and paste that image at the caret location.
		 *
		 * @param  {ClipboardEvent} e Paste/drop event object.
		 * @param  {DOMRange} rng Rng object to move selection to.
		 * @return {Boolean} true/false if the image data was found or not.
		 */
		function pasteImageData(e, rng) {
			var dataTransfer = e.clipboardData || e.dataTransfer;

			function processItems(items) {
				var i, item, reader, hadImage = false;

				if (items) {
					for (i = 0; i < items.length; i++) {
						item = items[i];

						if (/^image\/(jpeg|png|gif|bmp)$/.test(item.type)) {
							var blob = item.getAsFile ? item.getAsFile() : item;

							reader = new FileReader();
							reader.onload = pasteImage.bind(null, rng, reader, blob);
							reader.readAsDataURL(blob);

							e.preventDefault();
							hadImage = true;
						}
					}
				}

				return hadImage;
			}

			if (editor.settings.paste_data_images && dataTransfer) {
				return processItems(dataTransfer.items) || processItems(dataTransfer.files);
			}
		}

		/**
		 * Chrome on Android doesn't support proper clipboard access so we have no choice but to allow the browser default behavior.
		 *
		 * @param {Event} e Paste event object to check if it contains any data.
		 * @return {Boolean} true/false if the clipboard is empty or not.
		 */
		function isBrokenAndroidClipboardEvent(e) {
			var clipboardData = e.clipboardData;

			return navigator.userAgent.indexOf('Android') != -1 && clipboardData && clipboardData.items && clipboardData.items.length === 0;
		}

		function getCaretRangeFromEvent(e) {
			return RangeUtils.getCaretRangeFromPoint(e.clientX, e.clientY, editor.getDoc());
		}

		function hasContentType(clipboardContent, mimeType) {
			return mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
		}

		function isKeyboardPasteEvent(e) {
			return (VK.metaKeyPressed(e) && e.keyCode == 86) || (e.shiftKey && e.keyCode == 45);
		}

		function registerEventHandlers() {
			editor.on('keydown', function(e) {
				function removePasteBinOnKeyUp(e) {
					// Ctrl+V or Shift+Insert
					if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
						removePasteBin();
					}
				}

				// Ctrl+V or Shift+Insert
				if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
					keyboardPastePlainTextState = e.shiftKey && e.keyCode == 86;

					// Edge case on Safari on Mac where it doesn't handle Cmd+Shift+V correctly
					// it fires the keydown but no paste or keyup so we are left with a paste bin
					if (keyboardPastePlainTextState && Env.webkit && navigator.userAgent.indexOf('Version/') != -1) {
						return;
					}

					// Prevent undoManager keydown handler from making an undo level with the pastebin in it
					e.stopImmediatePropagation();

					keyboardPasteTimeStamp = new Date().getTime();

					// IE doesn't support Ctrl+Shift+V and it doesn't even produce a paste event
					// so lets fake a paste event and let IE use the execCommand/dataTransfer methods
					if (Env.ie && keyboardPastePlainTextState) {
						e.preventDefault();
						editor.fire('paste', {ieFake: true});
						return;
					}

					removePasteBin();
					createPasteBin();

					// Remove pastebin if we get a keyup and no paste event
					// For example pasting a file in IE 11 will not produce a paste event
					editor.once('keyup', removePasteBinOnKeyUp);
					editor.once('paste', function() {
						editor.off('keyup', removePasteBinOnKeyUp);
					});
				}
			});

			function insertClipboardContent(clipboardContent, isKeyBoardPaste, plainTextMode) {
				var content;

				// Grab HTML from Clipboard API or paste bin as a fallback
				if (hasContentType(clipboardContent, 'text/html')) {
					content = clipboardContent['text/html'];
				} else {
					content = getPasteBinHtml();

					// If paste bin is empty try using plain text mode
					// since that is better than nothing right
					if (content == pasteBinDefaultContent) {
						plainTextMode = true;
					}
				}

				content = Utils.trimHtml(content);

				// WebKit has a nice bug where it clones the paste bin if you paste from for example notepad
				// so we need to force plain text mode in this case
				if (pasteBinElm && pasteBinElm.firstChild && pasteBinElm.firstChild.id === 'mcepastebin') {
					plainTextMode = true;
				}

				removePasteBin();

				// If we got nothing from clipboard API and pastebin then we could try the last resort: plain/text
				if (!content.length) {
					plainTextMode = true;
				}

				// Grab plain text from Clipboard API or convert existing HTML to plain text
				if (plainTextMode) {
					// Use plain text contents from Clipboard API unless the HTML contains paragraphs then
					// we should convert the HTML to plain text since works better when pasting HTML/Word contents as plain text
					if (hasContentType(clipboardContent, 'text/plain') && content.indexOf('</p>') == -1) {
						content = clipboardContent['text/plain'];
					} else {
						content = Utils.innerText(content);
					}
				}

				// If the content is the paste bin default HTML then it was
				// impossible to get the cliboard data out.
				if (content == pasteBinDefaultContent) {
					if (!isKeyBoardPaste) {
						editor.windowManager.alert('Please use Ctrl+V/Cmd+V keyboard shortcuts to paste contents.');
					}

					return;
				}

				if (plainTextMode) {
					pasteText(content);
				} else {
					pasteHtml(content);
				}
			}

			var getLastRng = function() {
				return lastRng || editor.selection.getRng();
			};

			editor.on('paste', function(e) {
				// Getting content from the Clipboard can take some time
				var clipboardTimer = new Date().getTime();
				var clipboardContent = getClipboardContent(e);
				var clipboardDelay = new Date().getTime() - clipboardTimer;

				var isKeyBoardPaste = (new Date().getTime() - keyboardPasteTimeStamp - clipboardDelay) < 1000;
				var plainTextMode = self.pasteFormat == "text" || keyboardPastePlainTextState;

				keyboardPastePlainTextState = false;

				if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {
					removePasteBin();
					return;
				}

				if (!hasHtmlOrText(clipboardContent) && pasteImageData(e, getLastRng())) {
					removePasteBin();
					return;
				}

				// Not a keyboard paste prevent default paste and try to grab the clipboard contents using different APIs
				if (!isKeyBoardPaste) {
					e.preventDefault();
				}

				// Try IE only method if paste isn't a keyboard paste
				if (Env.ie && (!isKeyBoardPaste || e.ieFake)) {
					createPasteBin();

					editor.dom.bind(pasteBinElm, 'paste', function(e) {
						e.stopPropagation();
					});

					editor.getDoc().execCommand('Paste', false, null);
					clipboardContent["text/html"] = getPasteBinHtml();
				}

				// If clipboard API has HTML then use that directly
				if (hasContentType(clipboardContent, 'text/html')) {
					e.preventDefault();
					insertClipboardContent(clipboardContent, isKeyBoardPaste, plainTextMode);
				} else {
					Delay.setEditorTimeout(editor, function() {
						insertClipboardContent(clipboardContent, isKeyBoardPaste, plainTextMode);
					}, 0);
				}
			});

			editor.on('dragstart dragend', function(e) {
				draggingInternally = e.type == 'dragstart';
			});

			function isPlainTextFileUrl(content) {
				var plainTextContent = content['text/plain'];
				return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;
			}

			editor.on('drop', function(e) {
				var dropContent, rng;

				rng = getCaretRangeFromEvent(e);

				if (e.isDefaultPrevented() || draggingInternally) {
					return;
				}

				dropContent = getDataTransferItems(e.dataTransfer);

				if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(e, rng)) {
					return;
				}

				if (rng && editor.settings.paste_filter_drop !== false) {
					var content = dropContent['mce-internal'] || dropContent['text/html'] || dropContent['text/plain'];

					if (content) {
						e.preventDefault();

						// FF 45 doesn't paint a caret when dragging in text in due to focus call by execCommand
						Delay.setEditorTimeout(editor, function() {
							editor.undoManager.transact(function() {
								if (dropContent['mce-internal']) {
									editor.execCommand('Delete');
								}

								editor.selection.setRng(rng);

								content = Utils.trimHtml(content);

								if (!dropContent['text/html']) {
									pasteText(content);
								} else {
									pasteHtml(content);
								}
							});
						});
					}
				}
			});

			editor.on('dragover dragend', function(e) {
				if (editor.settings.paste_data_images) {
					e.preventDefault();
				}
			});
		}

		self.pasteHtml = pasteHtml;
		self.pasteText = pasteText;
		self.pasteImageData = pasteImageData;

		editor.on('preInit', function() {
			registerEventHandlers();

			// Remove all data images from paste for example from Gecko
			// except internal images like video elements
			editor.parser.addNodeFilter('img', function(nodes, name, args) {
				function isPasteInsert(args) {
					return args.data && args.data.paste === true;
				}

				function remove(node) {
					if (!node.attr('data-mce-object') && src !== Env.transparentSrc) {
						node.remove();
					}
				}

				function isWebKitFakeUrl(src) {
					return src.indexOf("webkit-fake-url") === 0;
				}

				function isDataUri(src) {
					return src.indexOf("data:") === 0;
				}

				if (!editor.settings.paste_data_images && isPasteInsert(args)) {
					var i = nodes.length;

					while (i--) {
						var src = nodes[i].attributes.map.src;

						if (!src) {
							continue;
						}

						// Safari on Mac produces webkit-fake-url see: https://bugs.webkit.org/show_bug.cgi?id=49141
						if (isWebKitFakeUrl(src)) {
							remove(nodes[i]);
						} else if (!editor.settings.allow_html_data_urls && isDataUri(src)) {
							remove(nodes[i]);
						}
					}
				}
			});
		});
	};
});

// Included from: js/tinymce/plugins/paste/classes/WordFilter.js

/**
 * WordFilter.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * This class parses word HTML into proper TinyMCE markup.
 *
 * @class tinymce.pasteplugin.WordFilter
 * @private
 */
define("tinymce/pasteplugin/WordFilter", [
	"tinymce/util/Tools",
	"tinymce/html/DomParser",
	"tinymce/html/Schema",
	"tinymce/html/Serializer",
	"tinymce/html/Node",
	"tinymce/pasteplugin/Utils"
], function(Tools, DomParser, Schema, Serializer, Node, Utils) {
	/**
	 * Checks if the specified content is from any of the following sources: MS Word/Office 365/Google docs.
	 */
	function isWordContent(content) {
		return (
			(/<font face="Times New Roman"|class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument/i).test(content) ||
			(/class="OutlineElement/).test(content) ||
			(/id="?docs\-internal\-guid\-/.test(content))
		);
	}

	/**
	 * Checks if the specified text starts with "1. " or "a. " etc.
	 */
	function isNumericList(text) {
		var found, patterns;

		patterns = [
			/^[IVXLMCD]{1,2}\.[ \u00a0]/,  // Roman upper case
			/^[ivxlmcd]{1,2}\.[ \u00a0]/,  // Roman lower case
			/^[a-z]{1,2}[\.\)][ \u00a0]/,  // Alphabetical a-z
			/^[A-Z]{1,2}[\.\)][ \u00a0]/,  // Alphabetical A-Z
			/^[0-9]+\.[ \u00a0]/,          // Numeric lists
			/^[\u3007\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d]+\.[ \u00a0]/, // Japanese
			/^[\u58f1\u5f10\u53c2\u56db\u4f0d\u516d\u4e03\u516b\u4e5d\u62fe]+\.[ \u00a0]/  // Chinese
		];

		text = text.replace(/^[\u00a0 ]+/, '');

		Tools.each(patterns, function(pattern) {
			if (pattern.test(text)) {
				found = true;
				return false;
			}
		});

		return found;
	}

	function isBulletList(text) {
		return /^[\s\u00a0]*[\u2022\u00b7\u00a7\u25CF]\s*/.test(text);
	}

	function WordFilter(editor) {
		var settings = editor.settings;

		editor.on('BeforePastePreProcess', function(e) {
			var content = e.content, retainStyleProperties, validStyles;

			// Remove google docs internal guid markers
			content = content.replace(/<b[^>]+id="?docs-internal-[^>]*>/gi, '');
			content = content.replace(/<br class="?Apple-interchange-newline"?>/gi, '');

			retainStyleProperties = settings.paste_retain_style_properties;
			if (retainStyleProperties) {
				validStyles = Tools.makeMap(retainStyleProperties.split(/[, ]/));
			}

			/**
			 * Converts fake bullet and numbered lists to real semantic OL/UL.
			 *
			 * @param {tinymce.html.Node} node Root node to convert children of.
			 */
			function convertFakeListsToProperLists(node) {
				var currentListNode, prevListNode, lastLevel = 1;

				function getText(node) {
					var txt = '';

					if (node.type === 3) {
						return node.value;
					}

					if ((node = node.firstChild)) {
						do {
							txt += getText(node);
						} while ((node = node.next));
					}

					return txt;
				}

				function trimListStart(node, regExp) {
					if (node.type === 3) {
						if (regExp.test(node.value)) {
							node.value = node.value.replace(regExp, '');
							return false;
						}
					}

					if ((node = node.firstChild)) {
						do {
							if (!trimListStart(node, regExp)) {
								return false;
							}
						} while ((node = node.next));
					}

					return true;
				}

				function removeIgnoredNodes(node) {
					if (node._listIgnore) {
						node.remove();
						return;
					}

					if ((node = node.firstChild)) {
						do {
							removeIgnoredNodes(node);
						} while ((node = node.next));
					}
				}

				function convertParagraphToLi(paragraphNode, listName, start) {
					var level = paragraphNode._listLevel || lastLevel;

					// Handle list nesting
					if (level != lastLevel) {
						if (level < lastLevel) {
							// Move to parent list
							if (currentListNode) {
								currentListNode = currentListNode.parent.parent;
							}
						} else {
							// Create new list
							prevListNode = currentListNode;
							currentListNode = null;
						}
					}

					if (!currentListNode || currentListNode.name != listName) {
						prevListNode = prevListNode || currentListNode;
						currentListNode = new Node(listName, 1);

						if (start > 1) {
							currentListNode.attr('start', '' + start);
						}

						paragraphNode.wrap(currentListNode);
					} else {
						currentListNode.append(paragraphNode);
					}

					paragraphNode.name = 'li';

					// Append list to previous list if it exists
					if (level > lastLevel && prevListNode) {
						prevListNode.lastChild.append(currentListNode);
					}

					lastLevel = level;

					// Remove start of list item "1. " or "&middot; " etc
					removeIgnoredNodes(paragraphNode);
					trimListStart(paragraphNode, /^\u00a0+/);
					trimListStart(paragraphNode, /^\s*([\u2022\u00b7\u00a7\u25CF]|\w+\.)/);
					trimListStart(paragraphNode, /^\u00a0+/);
				}

				// Build a list of all root level elements before we start
				// altering them in the loop below.
				var elements = [], child = node.firstChild;
				while (typeof child !== 'undefined' && child !== null) {
					elements.push(child);

					child = child.walk();
					if (child !== null) {
						while (typeof child !== 'undefined' && child.parent !== node) {
							child = child.walk();
						}
					}
				}

				for (var i = 0; i < elements.length; i++) {
					node = elements[i];

					if (node.name == 'p' && node.firstChild) {
						// Find first text node in paragraph
						var nodeText = getText(node);

						// Detect unordered lists look for bullets
						if (isBulletList(nodeText)) {
							convertParagraphToLi(node, 'ul');
							continue;
						}

						// Detect ordered lists 1., a. or ixv.
						if (isNumericList(nodeText)) {
							// Parse OL start number
							var matches = /([0-9]+)\./.exec(nodeText);
							var start = 1;
							if (matches) {
								start = parseInt(matches[1], 10);
							}

							convertParagraphToLi(node, 'ol', start);
							continue;
						}

						// Convert paragraphs marked as lists but doesn't look like anything
						if (node._listLevel) {
							convertParagraphToLi(node, 'ul', 1);
							continue;
						}

						currentListNode = null;
					} else {
						// If the root level element isn't a p tag which can be
						// processed by convertParagraphToLi, it interrupts the
						// lists, causing a new list to start instead of having
						// elements from the next list inserted above this tag.
						prevListNode = currentListNode;
						currentListNode = null;
					}
				}
			}

			function filterStyles(node, styleValue) {
				var outputStyles = {}, matches, styles = editor.dom.parseStyle(styleValue);

				Tools.each(styles, function(value, name) {
					// Convert various MS styles to W3C styles
					switch (name) {
						case 'mso-list':
							// Parse out list indent level for lists
							matches = /\w+ \w+([0-9]+)/i.exec(styleValue);
							if (matches) {
								node._listLevel = parseInt(matches[1], 10);
							}

							// Remove these nodes <span style="mso-list:Ignore">o</span>
							// Since the span gets removed we mark the text node and the span
							if (/Ignore/i.test(value) && node.firstChild) {
								node._listIgnore = true;
								node.firstChild._listIgnore = true;
							}

							break;

						case "horiz-align":
							name = "text-align";
							break;

						case "vert-align":
							name = "vertical-align";
							break;

						case "font-color":
						case "mso-foreground":
							name = "color";
							break;

						case "mso-background":
						case "mso-highlight":
							name = "background";
							break;

						case "font-weight":
						case "font-style":
							if (value != "normal") {
								outputStyles[name] = value;
							}
							return;

						case "mso-element":
							// Remove track changes code
							if (/^(comment|comment-list)$/i.test(value)) {
								node.remove();
								return;
							}

							break;
					}

					if (name.indexOf('mso-comment') === 0) {
						node.remove();
						return;
					}

					// Never allow mso- prefixed names
					if (name.indexOf('mso-') === 0) {
						return;
					}

					// Output only valid styles
					if (retainStyleProperties == "all" || (validStyles && validStyles[name])) {
						outputStyles[name] = value;
					}
				});

				// Convert bold style to "b" element
				if (/(bold)/i.test(outputStyles["font-weight"])) {
					delete outputStyles["font-weight"];
					node.wrap(new Node("b", 1));
				}

				// Convert italic style to "i" element
				if (/(italic)/i.test(outputStyles["font-style"])) {
					delete outputStyles["font-style"];
					node.wrap(new Node("i", 1));
				}

				// Serialize the styles and see if there is something left to keep
				outputStyles = editor.dom.serializeStyle(outputStyles, node.name);
				if (outputStyles) {
					return outputStyles;
				}

				return null;
			}

			if (settings.paste_enable_default_filters === false) {
				return;
			}

			// Detect is the contents is Word junk HTML
			if (isWordContent(e.content)) {
				e.wordContent = true; // Mark it for other processors

				// Remove basic Word junk
				content = Utils.filter(content, [
					// Word comments like conditional comments etc
					/<!--[\s\S]+?-->/gi,

					// Remove comments, scripts (e.g., msoShowComment), XML tag, VML content,
					// MS Office namespaced tags, and a few other tags
					/<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi,

					// Convert <s> into <strike> for line-though
					[/<(\/?)s>/gi, "<$1strike>"],

					// Replace nsbp entites to char since it's easier to handle
					[/&nbsp;/gi, "\u00a0"],

					// Convert <span style="mso-spacerun:yes">___</span> to string of alternating
					// breaking/non-breaking spaces of same length
					[/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi,
						function(str, spaces) {
							return (spaces.length > 0) ?
								spaces.replace(/./, " ").slice(Math.floor(spaces.length / 2)).split("").join("\u00a0") : "";
						}
					]
				]);

				var validElements = settings.paste_word_valid_elements;
				if (!validElements) {
					validElements = (
						'-strong/b,-em/i,-u,-span,-p,-ol,-ul,-li,-h1,-h2,-h3,-h4,-h5,-h6,' +
						'-p/div,-a[href|name],sub,sup,strike,br,del,table[width],tr,' +
						'td[colspan|rowspan|width],th[colspan|rowspan|width],thead,tfoot,tbody'
					);
				}

				// Setup strict schema
				var schema = new Schema({
					valid_elements: validElements,
					valid_children: '-li[p]'
				});

				// Add style/class attribute to all element rules since the user might have removed them from
				// paste_word_valid_elements config option and we need to check them for properties
				Tools.each(schema.elements, function(rule) {
					/*eslint dot-notation:0*/
					if (!rule.attributes["class"]) {
						rule.attributes["class"] = {};
						rule.attributesOrder.push("class");
					}

					if (!rule.attributes.style) {
						rule.attributes.style = {};
						rule.attributesOrder.push("style");
					}
				});

				// Parse HTML into DOM structure
				var domParser = new DomParser({}, schema);

				// Filter styles to remove "mso" specific styles and convert some of them
				domParser.addAttributeFilter('style', function(nodes) {
					var i = nodes.length, node;

					while (i--) {
						node = nodes[i];
						node.attr('style', filterStyles(node, node.attr('style')));

						// Remove pointess spans
						if (node.name == 'span' && node.parent && !node.attributes.length) {
							node.unwrap();
						}
					}
				});

				// Check the class attribute for comments or del items and remove those
				domParser.addAttributeFilter('class', function(nodes) {
					var i = nodes.length, node, className;

					while (i--) {
						node = nodes[i];

						className = node.attr('class');
						if (/^(MsoCommentReference|MsoCommentText|msoDel)$/i.test(className)) {
							node.remove();
						}

						node.attr('class', null);
					}
				});

				// Remove all del elements since we don't want the track changes code in the editor
				domParser.addNodeFilter('del', function(nodes) {
					var i = nodes.length;

					while (i--) {
						nodes[i].remove();
					}
				});

				// Keep some of the links and anchors
				domParser.addNodeFilter('a', function(nodes) {
					var i = nodes.length, node, href, name;

					while (i--) {
						node = nodes[i];
						href = node.attr('href');
						name = node.attr('name');

						if (href && href.indexOf('#_msocom_') != -1) {
							node.remove();
							continue;
						}

						if (href && href.indexOf('file://') === 0) {
							href = href.split('#')[1];
							if (href) {
								href = '#' + href;
							}
						}

						if (!href && !name) {
							node.unwrap();
						} else {
							// Remove all named anchors that aren't specific to TOC, Footnotes or Endnotes
							if (name && !/^_?(?:toc|edn|ftn)/i.test(name)) {
								node.unwrap();
								continue;
							}

							node.attr({
								href: href,
								name: name
							});
						}
					}
				});

				// Parse into DOM structure
				var rootNode = domParser.parse(content);

				// Process DOM
				if (settings.paste_convert_word_fake_lists !== false) {
					convertFakeListsToProperLists(rootNode);
				}

				// Serialize DOM back to HTML
				e.content = new Serializer({
					validate: settings.validate
				}, schema).serialize(rootNode);
			}
		});
	}

	WordFilter.isWordContent = isWordContent;

	return WordFilter;
});

// Included from: js/tinymce/plugins/paste/classes/Quirks.js

/**
 * Quirks.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * This class contains various fixes for browsers. These issues can not be feature
 * detected since we have no direct control over the clipboard. However we might be able
 * to remove some of these fixes once the browsers gets updated/fixed.
 *
 * @class tinymce.pasteplugin.Quirks
 * @private
 */
define("tinymce/pasteplugin/Quirks", [
	"tinymce/Env",
	"tinymce/util/Tools",
	"tinymce/pasteplugin/WordFilter",
	"tinymce/pasteplugin/Utils"
], function(Env, Tools, WordFilter, Utils) {
	"use strict";

	return function(editor) {
		function addPreProcessFilter(filterFunc) {
			editor.on('BeforePastePreProcess', function(e) {
				e.content = filterFunc(e.content);
			});
		}

		function addPostProcessFilter(filterFunc) {
			editor.on('PastePostProcess', function(e) {
				filterFunc(e.node);
			});
		}

		/**
		 * Removes BR elements after block elements. IE9 has a nasty bug where it puts a BR element after each
		 * block element when pasting from word. This removes those elements.
		 *
		 * This:
		 *  <p>a</p><br><p>b</p>
		 *
		 * Becomes:
		 *  <p>a</p><p>b</p>
		 */
		function removeExplorerBrElementsAfterBlocks(html) {
			// Only filter word specific content
			if (!WordFilter.isWordContent(html)) {
				return html;
			}

			// Produce block regexp based on the block elements in schema
			var blockElements = [];

			Tools.each(editor.schema.getBlockElements(), function(block, blockName) {
				blockElements.push(blockName);
			});

			var explorerBlocksRegExp = new RegExp(
				'(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*(<\\/?(' + blockElements.join('|') + ')[^>]*>)(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*',
				'g'
			);

			// Remove BR:s from: <BLOCK>X</BLOCK><BR>
			html = Utils.filter(html, [
				[explorerBlocksRegExp, '$1']
			]);

			// IE9 also adds an extra BR element for each soft-linefeed and it also adds a BR for each word wrap break
			html = Utils.filter(html, [
				[/<br><br>/g, '<BR><BR>'], // Replace multiple BR elements with uppercase BR to keep them intact
				[/<br>/g, ' '],            // Replace single br elements with space since they are word wrap BR:s
				[/<BR><BR>/g, '<br>']      // Replace back the double brs but into a single BR
			]);

			return html;
		}

		/**
		 * WebKit has a nasty bug where the all computed styles gets added to style attributes when copy/pasting contents.
		 * This fix solves that by simply removing the whole style attribute.
		 *
		 * The paste_webkit_styles option can be set to specify what to keep:
		 *  paste_webkit_styles: "none" // Keep no styles
		 *  paste_webkit_styles: "all", // Keep all of them
		 *  paste_webkit_styles: "font-weight color" // Keep specific ones
		 *
		 * @param {String} content Content that needs to be processed.
		 * @return {String} Processed contents.
		 */
		function removeWebKitStyles(content) {
			// Passthrough all styles from Word and let the WordFilter handle that junk
			if (WordFilter.isWordContent(content)) {
				return content;
			}

			// Filter away styles that isn't matching the target node
			var webKitStyles = editor.settings.paste_webkit_styles;

			if (editor.settings.paste_remove_styles_if_webkit === false || webKitStyles == "all") {
				return content;
			}

			if (webKitStyles) {
				webKitStyles = webKitStyles.split(/[, ]/);
			}

			// Keep specific styles that doesn't match the current node computed style
			if (webKitStyles) {
				var dom = editor.dom, node = editor.selection.getNode();

				content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, function(all, before, value, after) {
					var inputStyles = dom.parseStyle(value, 'span'), outputStyles = {};

					if (webKitStyles === "none") {
						return before + after;
					}

					for (var i = 0; i < webKitStyles.length; i++) {
						var inputValue = inputStyles[webKitStyles[i]], currentValue = dom.getStyle(node, webKitStyles[i], true);

						if (/color/.test(webKitStyles[i])) {
							inputValue = dom.toHex(inputValue);
							currentValue = dom.toHex(currentValue);
						}

						if (currentValue != inputValue) {
							outputStyles[webKitStyles[i]] = inputValue;
						}
					}

					outputStyles = dom.serializeStyle(outputStyles, 'span');
					if (outputStyles) {
						return before + ' style="' + outputStyles + '"' + after;
					}

					return before + after;
				});
			} else {
				// Remove all external styles
				content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, '$1$3');
			}

			// Keep internal styles
			content = content.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, function(all, before, value, after) {
				return before + ' style="' + value + '"' + after;
			});

			return content;
		}

		function removeUnderlineAndFontInAnchor(root) {
			editor.$('a', root).find('font,u').each(function(i, node) {
				editor.dom.remove(node, true);
			});
		}

		// Sniff browsers and apply fixes since we can't feature detect
		if (Env.webkit) {
			addPreProcessFilter(removeWebKitStyles);
		}

		if (Env.ie) {
			addPreProcessFilter(removeExplorerBrElementsAfterBlocks);
			addPostProcessFilter(removeUnderlineAndFontInAnchor);
		}
	};
});

// Included from: js/tinymce/plugins/paste/classes/Plugin.js

/**
 * Plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * This class contains the tinymce plugin logic for the paste plugin.
 *
 * @class tinymce.pasteplugin.Plugin
 * @private
 */
define("tinymce/pasteplugin/Plugin", [
	"tinymce/PluginManager",
	"tinymce/pasteplugin/Clipboard",
	"tinymce/pasteplugin/WordFilter",
	"tinymce/pasteplugin/Quirks"
], function(PluginManager, Clipboard, WordFilter, Quirks) {
	var userIsInformed;

	PluginManager.add('paste', function(editor) {
		var self = this, clipboard, settings = editor.settings;

		function isUserInformedAboutPlainText() {
			return userIsInformed || editor.settings.paste_plaintext_inform === false;
		}

		function togglePlainTextPaste() {
			if (clipboard.pasteFormat == "text") {
				clipboard.pasteFormat = "html";
				editor.fire('PastePlainTextToggle', {state: false});
			} else {
				clipboard.pasteFormat = "text";
				editor.fire('PastePlainTextToggle', {state: true});

				if (!isUserInformedAboutPlainText()) {
					var message = editor.translate('Paste is now in plain text mode. Contents will now ' +
					'be pasted as plain text until you toggle this option off.');

					editor.notificationManager.open({
						text: message,
						type: 'info'
					});

					userIsInformed = true;
				}
			}

			editor.focus();
		}

		function stateChange() {
			var self = this;

			self.active(clipboard.pasteFormat === 'text');

			editor.on('PastePlainTextToggle', function (e) {
				self.active(e.state);
			});
		}

		// draw back if power version is requested and registered
		if (/(^|[ ,])powerpaste([, ]|$)/.test(settings.plugins) && PluginManager.get('powerpaste')) {
			/*eslint no-console:0 */
			if (typeof console !== "undefined" && console.log) {
				console.log("PowerPaste is incompatible with Paste plugin! Remove 'paste' from the 'plugins' option.");
			}
			return;
		}

		self.clipboard = clipboard = new Clipboard(editor);
		self.quirks = new Quirks(editor);
		self.wordFilter = new WordFilter(editor);

		if (editor.settings.paste_as_text) {
			self.clipboard.pasteFormat = "text";
		}

		if (settings.paste_preprocess) {
			editor.on('PastePreProcess', function(e) {
				settings.paste_preprocess.call(self, self, e);
			});
		}

		if (settings.paste_postprocess) {
			editor.on('PastePostProcess', function(e) {
				settings.paste_postprocess.call(self, self, e);
			});
		}

		editor.addCommand('mceInsertClipboardContent', function(ui, value) {
			if (value.content) {
				self.clipboard.pasteHtml(value.content);
			}

			if (value.text) {
				self.clipboard.pasteText(value.text);
			}
		});

		// Block all drag/drop events
		if (editor.settings.paste_block_drop) {
			editor.on('dragend dragover draggesture dragdrop drop drag', function(e) {
				e.preventDefault();
				e.stopPropagation();
			});
		}

		// Prevent users from dropping data images on Gecko
		if (!editor.settings.paste_data_images) {
			editor.on('drop', function(e) {
				var dataTransfer = e.dataTransfer;

				if (dataTransfer && dataTransfer.files && dataTransfer.files.length > 0) {
					e.preventDefault();
				}
			});
		}

		editor.addCommand('mceTogglePlainTextPaste', togglePlainTextPaste);

		editor.addButton('pastetext', {
			icon: 'pastetext',
			tooltip: 'Paste as text',
			onclick: togglePlainTextPaste,
			onPostRender: stateChange
		});

		editor.addMenuItem('pastetext', {
			text: 'Paste as text',
			selectable: true,
			active: clipboard.pasteFormat,
			onclick: togglePlainTextPaste,
			onPostRender: stateChange
		});
	});
});

expose(["tinymce/pasteplugin/Utils"]);
})(window);
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('preview', function(editor) {
	var settings = editor.settings, sandbox = !tinymce.Env.ie;

	editor.addCommand('mcePreview', function() {
		editor.windowManager.open({
			title: 'Preview',
			width: parseInt(editor.getParam("plugin_preview_width", "650"), 10),
			height: parseInt(editor.getParam("plugin_preview_height", "500"), 10),
			html: '<iframe src="javascript:\'\'" frameborder="0"' + (sandbox ? ' sandbox="allow-scripts"' : '') + '></iframe>',
			buttons: {
				text: 'Close',
				onclick: function() {
					this.parent().parent().close();
				}
			},
			onPostRender: function() {
				var previewHtml, headHtml = '';

				headHtml += '<base href="' + editor.documentBaseURI.getURI() + '">';

				tinymce.each(editor.contentCSS, function(url) {
					headHtml += '<link type="text/css" rel="stylesheet" href="' + editor.documentBaseURI.toAbsolute(url) + '">';
				});

				var bodyId = settings.body_id || 'tinymce';
				if (bodyId.indexOf('=') != -1) {
					bodyId = editor.getParam('body_id', '', 'hash');
					bodyId = bodyId[editor.id] || bodyId;
				}

				var bodyClass = settings.body_class || '';
				if (bodyClass.indexOf('=') != -1) {
					bodyClass = editor.getParam('body_class', '', 'hash');
					bodyClass = bodyClass[editor.id] || '';
				}

				var preventClicksOnLinksScript = (
					'<script>' +
						'document.addEventListener && document.addEventListener("click", function(e) {' +
							'for (var elm = e.target; elm; elm = elm.parentNode) {' +
								'if (elm.nodeName === "A") {' +
									'e.preventDefault();' +
								'}' +
							'}' +
						'}, false);' +
					'</script> '
				);

				var dirAttr = editor.settings.directionality ? ' dir="' + editor.settings.directionality + '"' : '';

				previewHtml = (
					'<!DOCTYPE html>' +
					'<html>' +
					'<head>' +
						headHtml +
					'</head>' +
					'<body id="' + bodyId + '" class="mce-content-body ' + bodyClass + '"' + dirAttr + '>' +
						editor.getContent() +
						preventClicksOnLinksScript +
					'</body>' +
					'</html>'
				);

				if (!sandbox) {
					// IE 6-11 doesn't support data uris on iframes
					// so I guess they will have to be less secure since we can't sandbox on those
					// TODO: Use sandbox if future versions of IE supports iframes with data: uris.
					var doc = this.getEl('body').firstChild.contentWindow.document;
					doc.open();
					doc.write(previewHtml);
					doc.close();
				} else {
					this.getEl('body').firstChild.src = 'data:text/html;charset=utf-8,' + encodeURIComponent(previewHtml);
				}
			}
		});
	});

	editor.addButton('preview', {
		title: 'Preview',
		cmd: 'mcePreview'
	});

	editor.addMenuItem('preview', {
		text: 'Preview',
		cmd: 'mcePreview',
		context: 'view'
	});
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('print', function(editor) {
	editor.addCommand('mcePrint', function() {
		editor.getWin().print();
	});

	editor.addButton('print', {
		title: 'Print',
		cmd: 'mcePrint'
	});

	editor.addShortcut('Meta+P', '', 'mcePrint');

	editor.addMenuItem('print', {
		text: 'Print',
		cmd: 'mcePrint',
		icon: 'print',
		shortcut: 'Meta+P',
		context: 'file'
	});
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('save', function(editor) {
	function save() {
		var formObj;

		formObj = tinymce.DOM.getParent(editor.id, 'form');

		if (editor.getParam("save_enablewhendirty", true) && !editor.isDirty()) {
			return;
		}

		tinymce.triggerSave();

		// Use callback instead
		if (editor.getParam("save_onsavecallback")) {
			editor.execCallback('save_onsavecallback', editor);
			editor.nodeChanged();
			return;
		}

		if (formObj) {
			editor.setDirty(false);

			if (!formObj.onsubmit || formObj.onsubmit()) {
				if (typeof formObj.submit == "function") {
					formObj.submit();
				} else {
					displayErrorMessage(editor.translate("Error: Form submit field collision."));
				}
			}

			editor.nodeChanged();
		} else {
			displayErrorMessage(editor.translate("Error: No form element found."));
		}
	}

	function displayErrorMessage(message) {
		editor.notificationManager.open({
			text: message,
			type: 'error'
		});
	}

	function cancel() {
		var h = tinymce.trim(editor.startContent);

		// Use callback instead
		if (editor.getParam("save_oncancelcallback")) {
			editor.execCallback('save_oncancelcallback', editor);
			return;
		}

		editor.setContent(h);
		editor.undoManager.clear();
		editor.nodeChanged();
	}

	function stateToggle() {
		var self = this;

		editor.on('nodeChange dirty', function() {
			self.disabled(editor.getParam("save_enablewhendirty", true) && !editor.isDirty());
		});
	}

	editor.addCommand('mceSave', save);
	editor.addCommand('mceCancel', cancel);

	editor.addButton('save', {
		icon: 'save',
		text: 'Save',
		cmd: 'mceSave',
		disabled: true,
		onPostRender: stateToggle
	});

	editor.addButton('cancel', {
		text: 'Cancel',
		icon: false,
		cmd: 'mceCancel',
		disabled: true,
		onPostRender: stateToggle
	});

	editor.addShortcut('Meta+S', '', 'mceSave');
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*jshint smarttabs:true, undef:true, unused:true, latedef:true, curly:true, bitwise:true */
/*eslint no-labels:0, no-constant-condition: 0 */
/*global tinymce:true */

(function() {
	function isContentEditableFalse(node) {
		return node && node.nodeType == 1 && node.contentEditable === "false";
	}

	// Based on work developed by: James Padolsey http://james.padolsey.com
	// released under UNLICENSE that is compatible with LGPL
	// TODO: Handle contentEditable edgecase:
	// <p>text<span contentEditable="false">text<span contentEditable="true">text</span>text</span>text</p>
	function findAndReplaceDOMText(regex, node, replacementNode, captureGroup, schema) {
		var m, matches = [], text, count = 0, doc;
		var blockElementsMap, hiddenTextElementsMap, shortEndedElementsMap;

		doc = node.ownerDocument;
		blockElementsMap = schema.getBlockElements(); // H1-H6, P, TD etc
		hiddenTextElementsMap = schema.getWhiteSpaceElements(); // TEXTAREA, PRE, STYLE, SCRIPT
		shortEndedElementsMap = schema.getShortEndedElements(); // BR, IMG, INPUT

		function getMatchIndexes(m, captureGroup) {
			captureGroup = captureGroup || 0;

			if (!m[0]) {
				throw 'findAndReplaceDOMText cannot handle zero-length matches';
			}

			var index = m.index;

			if (captureGroup > 0) {
				var cg = m[captureGroup];

				if (!cg) {
					throw 'Invalid capture group';
				}

				index += m[0].indexOf(cg);
				m[0] = cg;
			}

			return [index, index + m[0].length, [m[0]]];
		}

		function getText(node) {
			var txt;

			if (node.nodeType === 3) {
				return node.data;
			}

			if (hiddenTextElementsMap[node.nodeName] && !blockElementsMap[node.nodeName]) {
				return '';
			}

			txt = '';

			if (isContentEditableFalse(node)) {
				return '\n';
			}

			if (blockElementsMap[node.nodeName] || shortEndedElementsMap[node.nodeName]) {
				txt += '\n';
			}

			if ((node = node.firstChild)) {
				do {
					txt += getText(node);
				} while ((node = node.nextSibling));
			}

			return txt;
		}

		function stepThroughMatches(node, matches, replaceFn) {
			var startNode, endNode, startNodeIndex,
				endNodeIndex, innerNodes = [], atIndex = 0, curNode = node,
				matchLocation = matches.shift(), matchIndex = 0;

			out: while (true) {
				if (blockElementsMap[curNode.nodeName] || shortEndedElementsMap[curNode.nodeName] || isContentEditableFalse(curNode)) {
					atIndex++;
				}

				if (curNode.nodeType === 3) {
					if (!endNode && curNode.length + atIndex >= matchLocation[1]) {
						// We've found the ending
						endNode = curNode;
						endNodeIndex = matchLocation[1] - atIndex;
					} else if (startNode) {
						// Intersecting node
						innerNodes.push(curNode);
					}

					if (!startNode && curNode.length + atIndex > matchLocation[0]) {
						// We've found the match start
						startNode = curNode;
						startNodeIndex = matchLocation[0] - atIndex;
					}

					atIndex += curNode.length;
				}

				if (startNode && endNode) {
					curNode = replaceFn({
						startNode: startNode,
						startNodeIndex: startNodeIndex,
						endNode: endNode,
						endNodeIndex: endNodeIndex,
						innerNodes: innerNodes,
						match: matchLocation[2],
						matchIndex: matchIndex
					});

					// replaceFn has to return the node that replaced the endNode
					// and then we step back so we can continue from the end of the
					// match:
					atIndex -= (endNode.length - endNodeIndex);
					startNode = null;
					endNode = null;
					innerNodes = [];
					matchLocation = matches.shift();
					matchIndex++;

					if (!matchLocation) {
						break; // no more matches
					}
				} else if ((!hiddenTextElementsMap[curNode.nodeName] || blockElementsMap[curNode.nodeName]) && curNode.firstChild) {
					if (!isContentEditableFalse(curNode)) {
						// Move down
						curNode = curNode.firstChild;
						continue;
					}
				} else if (curNode.nextSibling) {
					// Move forward:
					curNode = curNode.nextSibling;
					continue;
				}

				// Move forward or up:
				while (true) {
					if (curNode.nextSibling) {
						curNode = curNode.nextSibling;
						break;
					} else if (curNode.parentNode !== node) {
						curNode = curNode.parentNode;
					} else {
						break out;
					}
				}
			}
		}

		/**
		* Generates the actual replaceFn which splits up text nodes
		* and inserts the replacement element.
		*/
		function genReplacer(nodeName) {
			var makeReplacementNode;

			if (typeof nodeName != 'function') {
				var stencilNode = nodeName.nodeType ? nodeName : doc.createElement(nodeName);

				makeReplacementNode = function(fill, matchIndex) {
					var clone = stencilNode.cloneNode(false);

					clone.setAttribute('data-mce-index', matchIndex);

					if (fill) {
						clone.appendChild(doc.createTextNode(fill));
					}

					return clone;
				};
			} else {
				makeReplacementNode = nodeName;
			}

			return function(range) {
				var before, after, parentNode, startNode = range.startNode,
					endNode = range.endNode, matchIndex = range.matchIndex;

				if (startNode === endNode) {
					var node = startNode;

					parentNode = node.parentNode;
					if (range.startNodeIndex > 0) {
						// Add `before` text node (before the match)
						before = doc.createTextNode(node.data.substring(0, range.startNodeIndex));
						parentNode.insertBefore(before, node);
					}

					// Create the replacement node:
					var el = makeReplacementNode(range.match[0], matchIndex);
					parentNode.insertBefore(el, node);
					if (range.endNodeIndex < node.length) {
						// Add `after` text node (after the match)
						after = doc.createTextNode(node.data.substring(range.endNodeIndex));
						parentNode.insertBefore(after, node);
					}

					node.parentNode.removeChild(node);

					return el;
				}

				// Replace startNode -> [innerNodes...] -> endNode (in that order)
				before = doc.createTextNode(startNode.data.substring(0, range.startNodeIndex));
				after = doc.createTextNode(endNode.data.substring(range.endNodeIndex));
				var elA = makeReplacementNode(startNode.data.substring(range.startNodeIndex), matchIndex);
				var innerEls = [];

				for (var i = 0, l = range.innerNodes.length; i < l; ++i) {
					var innerNode = range.innerNodes[i];
					var innerEl = makeReplacementNode(innerNode.data, matchIndex);
					innerNode.parentNode.replaceChild(innerEl, innerNode);
					innerEls.push(innerEl);
				}

				var elB = makeReplacementNode(endNode.data.substring(0, range.endNodeIndex), matchIndex);

				parentNode = startNode.parentNode;
				parentNode.insertBefore(before, startNode);
				parentNode.insertBefore(elA, startNode);
				parentNode.removeChild(startNode);

				parentNode = endNode.parentNode;
				parentNode.insertBefore(elB, endNode);
				parentNode.insertBefore(after, endNode);
				parentNode.removeChild(endNode);

				return elB;
			};
		}

		text = getText(node);
		if (!text) {
			return;
		}

		if (regex.global) {
			while ((m = regex.exec(text))) {
				matches.push(getMatchIndexes(m, captureGroup));
			}
		} else {
			m = text.match(regex);
			matches.push(getMatchIndexes(m, captureGroup));
		}

		if (matches.length) {
			count = matches.length;
			stepThroughMatches(node, matches, genReplacer(replacementNode));
		}

		return count;
	}

	function Plugin(editor) {
		var self = this, currentIndex = -1;

		function showDialog() {
			var last = {}, selectedText;

			selectedText = tinymce.trim(editor.selection.getContent({format: 'text'}));

			function updateButtonStates() {
				win.statusbar.find('#next').disabled(!findSpansByIndex(currentIndex + 1).length);
				win.statusbar.find('#prev').disabled(!findSpansByIndex(currentIndex - 1).length);
			}

			function notFoundAlert() {
				editor.windowManager.alert('Could not find the specified string.', function() {
					win.find('#find')[0].focus();
				});
			}

			var win = editor.windowManager.open({
				layout: "flex",
				pack: "center",
				align: "center",
				onClose: function() {
					editor.focus();
					self.done();
				},
				onSubmit: function(e) {
					var count, caseState, text, wholeWord;

					e.preventDefault();

					caseState = win.find('#case').checked();
					wholeWord = win.find('#words').checked();

					text = win.find('#find').value();
					if (!text.length) {
						self.done(false);
						win.statusbar.items().slice(1).disabled(true);
						return;
					}

					if (last.text == text && last.caseState == caseState && last.wholeWord == wholeWord) {
						if (findSpansByIndex(currentIndex + 1).length === 0) {
							notFoundAlert();
							return;
						}

						self.next();
						updateButtonStates();
						return;
					}

					count = self.find(text, caseState, wholeWord);
					if (!count) {
						notFoundAlert();
					}

					win.statusbar.items().slice(1).disabled(count === 0);
					updateButtonStates();

					last = {
						text: text,
						caseState: caseState,
						wholeWord: wholeWord
					};
				},
				buttons: [
					{text: "Find", subtype: 'primary', onclick: function() {
						win.submit();
					}},
					{text: "Replace", disabled: true, onclick: function() {
						if (!self.replace(win.find('#replace').value())) {
							win.statusbar.items().slice(1).disabled(true);
							currentIndex = -1;
							last = {};
						}
					}},
					{text: "Replace all", disabled: true, onclick: function() {
						self.replace(win.find('#replace').value(), true, true);
						win.statusbar.items().slice(1).disabled(true);
						last = {};
					}},
					{type: "spacer", flex: 1},
					{text: "Prev", name: 'prev', disabled: true, onclick: function() {
						self.prev();
						updateButtonStates();
					}},
					{text: "Next", name: 'next', disabled: true, onclick: function() {
						self.next();
						updateButtonStates();
					}}
				],
				title: "Find and replace",
				items: {
					type: "form",
					padding: 20,
					labelGap: 30,
					spacing: 10,
					items: [
						{type: 'textbox', name: 'find', size: 40, label: 'Find', value: selectedText},
						{type: 'textbox', name: 'replace', size: 40, label: 'Replace with'},
						{type: 'checkbox', name: 'case', text: 'Match case', label: ' '},
						{type: 'checkbox', name: 'words', text: 'Whole words', label: ' '}
					]
				}
			});
		}

		self.init = function(ed) {
			ed.addMenuItem('searchreplace', {
				text: 'Find and replace',
				shortcut: 'Meta+F',
				onclick: showDialog,
				separator: 'before',
				context: 'edit'
			});

			ed.addButton('searchreplace', {
				tooltip: 'Find and replace',
				shortcut: 'Meta+F',
				onclick: showDialog
			});

			ed.addCommand("SearchReplace", showDialog);
			ed.shortcuts.add('Meta+F', '', showDialog);
		};

		function getElmIndex(elm) {
			var value = elm.getAttribute('data-mce-index');

			if (typeof value == "number") {
				return "" + value;
			}

			return value;
		}

		function markAllMatches(regex) {
			var node, marker;

			marker = editor.dom.create('span', {
				"data-mce-bogus": 1
			});

			marker.className = 'mce-match-marker'; // IE 7 adds class="mce-match-marker" and class=mce-match-marker
			node = editor.getBody();

			self.done(false);

			return findAndReplaceDOMText(regex, node, marker, false, editor.schema);
		}

		function unwrap(node) {
			var parentNode = node.parentNode;

			if (node.firstChild) {
				parentNode.insertBefore(node.firstChild, node);
			}

			node.parentNode.removeChild(node);
		}

		function findSpansByIndex(index) {
			var nodes, spans = [];

			nodes = tinymce.toArray(editor.getBody().getElementsByTagName('span'));
			if (nodes.length) {
				for (var i = 0; i < nodes.length; i++) {
					var nodeIndex = getElmIndex(nodes[i]);

					if (nodeIndex === null || !nodeIndex.length) {
						continue;
					}

					if (nodeIndex === index.toString()) {
						spans.push(nodes[i]);
					}
				}
			}

			return spans;
		}

		function moveSelection(forward) {
			var testIndex = currentIndex, dom = editor.dom;

			forward = forward !== false;

			if (forward) {
				testIndex++;
			} else {
				testIndex--;
			}

			dom.removeClass(findSpansByIndex(currentIndex), 'mce-match-marker-selected');

			var spans = findSpansByIndex(testIndex);
			if (spans.length) {
				dom.addClass(findSpansByIndex(testIndex), 'mce-match-marker-selected');
				editor.selection.scrollIntoView(spans[0]);
				return testIndex;
			}

			return -1;
		}

		function removeNode(node) {
			var dom = editor.dom, parent = node.parentNode;

			dom.remove(node);

			if (dom.isEmpty(parent)) {
				dom.remove(parent);
			}
		}

		self.find = function(text, matchCase, wholeWord) {
			text = text.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
			text = wholeWord ? '\\b' + text + '\\b' : text;

			var count = markAllMatches(new RegExp(text, matchCase ? 'g' : 'gi'));

			if (count) {
				currentIndex = -1;
				currentIndex = moveSelection(true);
			}

			return count;
		};

		self.next = function() {
			var index = moveSelection(true);

			if (index !== -1) {
				currentIndex = index;
			}
		};

		self.prev = function() {
			var index = moveSelection(false);

			if (index !== -1) {
				currentIndex = index;
			}
		};

		function isMatchSpan(node) {
			var matchIndex = getElmIndex(node);

			return matchIndex !== null && matchIndex.length > 0;
		}

		self.replace = function(text, forward, all) {
			var i, nodes, node, matchIndex, currentMatchIndex, nextIndex = currentIndex, hasMore;

			forward = forward !== false;

			node = editor.getBody();
			nodes = tinymce.grep(tinymce.toArray(node.getElementsByTagName('span')), isMatchSpan);
			for (i = 0; i < nodes.length; i++) {
				var nodeIndex = getElmIndex(nodes[i]);

				matchIndex = currentMatchIndex = parseInt(nodeIndex, 10);
				if (all || matchIndex === currentIndex) {
					if (text.length) {
						nodes[i].firstChild.nodeValue = text;
						unwrap(nodes[i]);
					} else {
						removeNode(nodes[i]);
					}

					while (nodes[++i]) {
						matchIndex = parseInt(getElmIndex(nodes[i]), 10);

						if (matchIndex === currentMatchIndex) {
							removeNode(nodes[i]);
						} else {
							i--;
							break;
						}
					}

					if (forward) {
						nextIndex--;
					}
				} else if (currentMatchIndex > currentIndex) {
					nodes[i].setAttribute('data-mce-index', currentMatchIndex - 1);
				}
			}

			editor.undoManager.add();
			currentIndex = nextIndex;

			if (forward) {
				hasMore = findSpansByIndex(nextIndex + 1).length > 0;
				self.next();
			} else {
				hasMore = findSpansByIndex(nextIndex - 1).length > 0;
				self.prev();
			}

			return !all && hasMore;
		};

		self.done = function(keepEditorSelection) {
			var i, nodes, startContainer, endContainer;

			nodes = tinymce.toArray(editor.getBody().getElementsByTagName('span'));
			for (i = 0; i < nodes.length; i++) {
				var nodeIndex = getElmIndex(nodes[i]);

				if (nodeIndex !== null && nodeIndex.length) {
					if (nodeIndex === currentIndex.toString()) {
						if (!startContainer) {
							startContainer = nodes[i].firstChild;
						}

						endContainer = nodes[i].firstChild;
					}

					unwrap(nodes[i]);
				}
			}

			if (startContainer && endContainer) {
				var rng = editor.dom.createRng();
				rng.setStart(startContainer, 0);
				rng.setEnd(endContainer, endContainer.data.length);

				if (keepEditorSelection !== false) {
					editor.selection.setRng(rng);
				}

				return rng;
			}
		};
	}

	tinymce.PluginManager.add('searchreplace', Plugin);
})();

/**
 * Compiled inline version. (Library mode)
 */

/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */
/*globals $code */

(function(exports, undefined) {
	"use strict";

	var modules = {};

	function require(ids, callback) {
		var module, defs = [];

		for (var i = 0; i < ids.length; ++i) {
			module = modules[ids[i]] || resolve(ids[i]);
			if (!module) {
				throw 'module definition dependecy not found: ' + ids[i];
			}

			defs.push(module);
		}

		callback.apply(null, defs);
	}

	function define(id, dependencies, definition) {
		if (typeof id !== 'string') {
			throw 'invalid module definition, module id must be defined and be a string';
		}

		if (dependencies === undefined) {
			throw 'invalid module definition, dependencies must be specified';
		}

		if (definition === undefined) {
			throw 'invalid module definition, definition function must be specified';
		}

		require(dependencies, function() {
			modules[id] = definition.apply(null, arguments);
		});
	}

	function defined(id) {
		return !!modules[id];
	}

	function resolve(id) {
		var target = exports;
		var fragments = id.split(/[.\/]/);

		for (var fi = 0; fi < fragments.length; ++fi) {
			if (!target[fragments[fi]]) {
				return;
			}

			target = target[fragments[fi]];
		}

		return target;
	}

	function expose(ids) {
		var i, target, id, fragments, privateModules;

		for (i = 0; i < ids.length; i++) {
			target = exports;
			id = ids[i];
			fragments = id.split(/[.\/]/);

			for (var fi = 0; fi < fragments.length - 1; ++fi) {
				if (target[fragments[fi]] === undefined) {
					target[fragments[fi]] = {};
				}

				target = target[fragments[fi]];
			}

			target[fragments[fragments.length - 1]] = modules[id];
		}

		// Expose private modules for unit tests
		if (exports.AMDLC_TESTS) {
			privateModules = exports.privateModules || {};

			for (id in modules) {
				privateModules[id] = modules[id];
			}

			for (i = 0; i < ids.length; i++) {
				delete privateModules[ids[i]];
			}

			exports.privateModules = privateModules;
		}
	}

// Included from: js/tinymce/plugins/spellchecker/classes/DomTextMatcher.js

/**
 * DomTextMatcher.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*eslint no-labels:0, no-constant-condition: 0 */

/**
 * This class logic for filtering text and matching words.
 *
 * @class tinymce.spellcheckerplugin.TextFilter
 * @private
 */
define("tinymce/spellcheckerplugin/DomTextMatcher", [], function() {
	function isContentEditableFalse(node) {
		return node && node.nodeType == 1 && node.contentEditable === "false";
	}

	// Based on work developed by: James Padolsey http://james.padolsey.com
	// released under UNLICENSE that is compatible with LGPL
	// TODO: Handle contentEditable edgecase:
	// <p>text<span contentEditable="false">text<span contentEditable="true">text</span>text</span>text</p>
	return function(node, editor) {
		var m, matches = [], text, dom = editor.dom;
		var blockElementsMap, hiddenTextElementsMap, shortEndedElementsMap;

		blockElementsMap = editor.schema.getBlockElements(); // H1-H6, P, TD etc
		hiddenTextElementsMap = editor.schema.getWhiteSpaceElements(); // TEXTAREA, PRE, STYLE, SCRIPT
		shortEndedElementsMap = editor.schema.getShortEndedElements(); // BR, IMG, INPUT

		function createMatch(m, data) {
			if (!m[0]) {
				throw 'findAndReplaceDOMText cannot handle zero-length matches';
			}

			return {
				start: m.index,
				end: m.index + m[0].length,
				text: m[0],
				data: data
			};
		}

		function getText(node) {
			var txt;

			if (node.nodeType === 3) {
				return node.data;
			}

			if (hiddenTextElementsMap[node.nodeName] && !blockElementsMap[node.nodeName]) {
				return '';
			}

			if (isContentEditableFalse(node)) {
				return '\n';
			}

			txt = '';

			if (blockElementsMap[node.nodeName] || shortEndedElementsMap[node.nodeName]) {
				txt += '\n';
			}

			if ((node = node.firstChild)) {
				do {
					txt += getText(node);
				} while ((node = node.nextSibling));
			}

			return txt;
		}

		function stepThroughMatches(node, matches, replaceFn) {
			var startNode, endNode, startNodeIndex,
				endNodeIndex, innerNodes = [], atIndex = 0, curNode = node,
				matchLocation, matchIndex = 0;

			matches = matches.slice(0);
			matches.sort(function(a, b) {
				return a.start - b.start;
			});

			matchLocation = matches.shift();

			out: while (true) {
				if (blockElementsMap[curNode.nodeName] || shortEndedElementsMap[curNode.nodeName] || isContentEditableFalse(curNode)) {
					atIndex++;
				}

				if (curNode.nodeType === 3) {
					if (!endNode && curNode.length + atIndex >= matchLocation.end) {
						// We've found the ending
						endNode = curNode;
						endNodeIndex = matchLocation.end - atIndex;
					} else if (startNode) {
						// Intersecting node
						innerNodes.push(curNode);
					}

					if (!startNode && curNode.length + atIndex > matchLocation.start) {
						// We've found the match start
						startNode = curNode;
						startNodeIndex = matchLocation.start - atIndex;
					}

					atIndex += curNode.length;
				}

				if (startNode && endNode) {
					curNode = replaceFn({
						startNode: startNode,
						startNodeIndex: startNodeIndex,
						endNode: endNode,
						endNodeIndex: endNodeIndex,
						innerNodes: innerNodes,
						match: matchLocation.text,
						matchIndex: matchIndex
					});

					// replaceFn has to return the node that replaced the endNode
					// and then we step back so we can continue from the end of the
					// match:
					atIndex -= (endNode.length - endNodeIndex);
					startNode = null;
					endNode = null;
					innerNodes = [];
					matchLocation = matches.shift();
					matchIndex++;

					if (!matchLocation) {
						break; // no more matches
					}
				} else if ((!hiddenTextElementsMap[curNode.nodeName] || blockElementsMap[curNode.nodeName]) && curNode.firstChild) {
					if (!isContentEditableFalse(curNode)) {
						// Move down
						curNode = curNode.firstChild;
						continue;
					}
				} else if (curNode.nextSibling) {
					// Move forward:
					curNode = curNode.nextSibling;
					continue;
				}

				// Move forward or up:
				while (true) {
					if (curNode.nextSibling) {
						curNode = curNode.nextSibling;
						break;
					} else if (curNode.parentNode !== node) {
						curNode = curNode.parentNode;
					} else {
						break out;
					}
				}
			}
		}

		/**
		* Generates the actual replaceFn which splits up text nodes
		* and inserts the replacement element.
		*/
		function genReplacer(callback) {
			function makeReplacementNode(fill, matchIndex) {
				var match = matches[matchIndex];

				if (!match.stencil) {
					match.stencil = callback(match);
				}

				var clone = match.stencil.cloneNode(false);
				clone.setAttribute('data-mce-index', matchIndex);

				if (fill) {
					clone.appendChild(dom.doc.createTextNode(fill));
				}

				return clone;
			}

			return function(range) {
				var before, after, parentNode, startNode = range.startNode,
					endNode = range.endNode, matchIndex = range.matchIndex,
					doc = dom.doc;

				if (startNode === endNode) {
					var node = startNode;

					parentNode = node.parentNode;
					if (range.startNodeIndex > 0) {
						// Add "before" text node (before the match)
						before = doc.createTextNode(node.data.substring(0, range.startNodeIndex));
						parentNode.insertBefore(before, node);
					}

					// Create the replacement node:
					var el = makeReplacementNode(range.match, matchIndex);
					parentNode.insertBefore(el, node);
					if (range.endNodeIndex < node.length) {
						// Add "after" text node (after the match)
						after = doc.createTextNode(node.data.substring(range.endNodeIndex));
						parentNode.insertBefore(after, node);
					}

					node.parentNode.removeChild(node);

					return el;
				}

				// Replace startNode -> [innerNodes...] -> endNode (in that order)
				before = doc.createTextNode(startNode.data.substring(0, range.startNodeIndex));
				after = doc.createTextNode(endNode.data.substring(range.endNodeIndex));
				var elA = makeReplacementNode(startNode.data.substring(range.startNodeIndex), matchIndex);
				var innerEls = [];

				for (var i = 0, l = range.innerNodes.length; i < l; ++i) {
					var innerNode = range.innerNodes[i];
					var innerEl = makeReplacementNode(innerNode.data, matchIndex);
					innerNode.parentNode.replaceChild(innerEl, innerNode);
					innerEls.push(innerEl);
				}

				var elB = makeReplacementNode(endNode.data.substring(0, range.endNodeIndex), matchIndex);

				parentNode = startNode.parentNode;
				parentNode.insertBefore(before, startNode);
				parentNode.insertBefore(elA, startNode);
				parentNode.removeChild(startNode);

				parentNode = endNode.parentNode;
				parentNode.insertBefore(elB, endNode);
				parentNode.insertBefore(after, endNode);
				parentNode.removeChild(endNode);

				return elB;
			};
		}

		function unwrapElement(element) {
			var parentNode = element.parentNode;
			parentNode.insertBefore(element.firstChild, element);
			element.parentNode.removeChild(element);
		}

		function getWrappersByIndex(index) {
			var elements = node.getElementsByTagName('*'), wrappers = [];

			index = typeof index == "number" ? "" + index : null;

			for (var i = 0; i < elements.length; i++) {
				var element = elements[i], dataIndex = element.getAttribute('data-mce-index');

				if (dataIndex !== null && dataIndex.length) {
					if (dataIndex === index || index === null) {
						wrappers.push(element);
					}
				}
			}

			return wrappers;
		}

		/**
		 * Returns the index of a specific match object or -1 if it isn't found.
		 *
		 * @param  {Match} match Text match object.
		 * @return {Number} Index of match or -1 if it isn't found.
		 */
		function indexOf(match) {
			var i = matches.length;
			while (i--) {
				if (matches[i] === match) {
					return i;
				}
			}

			return -1;
		}

		/**
		 * Filters the matches. If the callback returns true it stays if not it gets removed.
		 *
		 * @param {Function} callback Callback to execute for each match.
		 * @return {DomTextMatcher} Current DomTextMatcher instance.
		 */
		function filter(callback) {
			var filteredMatches = [];

			each(function(match, i) {
				if (callback(match, i)) {
					filteredMatches.push(match);
				}
			});

			matches = filteredMatches;

			/*jshint validthis:true*/
			return this;
		}

		/**
		 * Executes the specified callback for each match.
		 *
		 * @param {Function} callback  Callback to execute for each match.
		 * @return {DomTextMatcher} Current DomTextMatcher instance.
		 */
		function each(callback) {
			for (var i = 0, l = matches.length; i < l; i++) {
				if (callback(matches[i], i) === false) {
					break;
				}
			}

			/*jshint validthis:true*/
			return this;
		}

		/**
		 * Wraps the current matches with nodes created by the specified callback.
		 * Multiple clones of these matches might occur on matches that are on multiple nodex.
		 *
		 * @param {Function} callback Callback to execute in order to create elements for matches.
		 * @return {DomTextMatcher} Current DomTextMatcher instance.
		 */
		function wrap(callback) {
			if (matches.length) {
				stepThroughMatches(node, matches, genReplacer(callback));
			}

			/*jshint validthis:true*/
			return this;
		}

		/**
		 * Finds the specified regexp and adds them to the matches collection.
		 *
		 * @param {RegExp} regex Global regexp to search the current node by.
		 * @param {Object} [data] Optional custom data element for the match.
		 * @return {DomTextMatcher} Current DomTextMatcher instance.
		 */
		function find(regex, data) {
			if (text && regex.global) {
				while ((m = regex.exec(text))) {
					matches.push(createMatch(m, data));
				}
			}

			return this;
		}

		/**
		 * Unwraps the specified match object or all matches if unspecified.
		 *
		 * @param {Object} [match] Optional match object.
		 * @return {DomTextMatcher} Current DomTextMatcher instance.
		 */
		function unwrap(match) {
			var i, elements = getWrappersByIndex(match ? indexOf(match) : null);

			i = elements.length;
			while (i--) {
				unwrapElement(elements[i]);
			}

			return this;
		}

		/**
		 * Returns a match object by the specified DOM element.
		 *
		 * @param {DOMElement} element Element to return match object for.
		 * @return {Object} Match object for the specified element.
		 */
		function matchFromElement(element) {
			return matches[element.getAttribute('data-mce-index')];
		}

		/**
		 * Returns a DOM element from the specified match element. This will be the first element if it's split
		 * on multiple nodes.
		 *
		 * @param {Object} match Match element to get first element of.
		 * @return {DOMElement} DOM element for the specified match object.
		 */
		function elementFromMatch(match) {
			return getWrappersByIndex(indexOf(match))[0];
		}

		/**
		 * Adds match the specified range for example a grammar line.
		 *
		 * @param {Number} start Start offset.
		 * @param {Number} length Length of the text.
		 * @param {Object} data Custom data object for match.
		 * @return {DomTextMatcher} Current DomTextMatcher instance.
		 */
		function add(start, length, data) {
			matches.push({
				start: start,
				end: start + length,
				text: text.substr(start, length),
				data: data
			});

			return this;
		}

		/**
		 * Returns a DOM range for the specified match.
		 *
		 * @param  {Object} match Match object to get range for.
		 * @return {DOMRange} DOM Range for the specified match.
		 */
		function rangeFromMatch(match) {
			var wrappers = getWrappersByIndex(indexOf(match));

			var rng = editor.dom.createRng();
			rng.setStartBefore(wrappers[0]);
			rng.setEndAfter(wrappers[wrappers.length - 1]);

			return rng;
		}

		/**
		 * Replaces the specified match with the specified text.
		 *
		 * @param {Object} match Match object to replace.
		 * @param {String} text Text to replace the match with.
		 * @return {DOMRange} DOM range produced after the replace.
		 */
		function replace(match, text) {
			var rng = rangeFromMatch(match);

			rng.deleteContents();

			if (text.length > 0) {
				rng.insertNode(editor.dom.doc.createTextNode(text));
			}

			return rng;
		}

		/**
		 * Resets the DomTextMatcher instance. This will remove any wrapped nodes and remove any matches.
		 *
		 * @return {[type]} [description]
		 */
		function reset() {
			matches.splice(0, matches.length);
			unwrap();

			return this;
		}

		text = getText(node);

		return {
			text: text,
			matches: matches,
			each: each,
			filter: filter,
			reset: reset,
			matchFromElement: matchFromElement,
			elementFromMatch: elementFromMatch,
			find: find,
			add: add,
			wrap: wrap,
			unwrap: unwrap,
			replace: replace,
			rangeFromMatch: rangeFromMatch,
			indexOf: indexOf
		};
	};
});

// Included from: js/tinymce/plugins/spellchecker/classes/Plugin.js

/**
 * Plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*jshint camelcase:false */

/**
 * This class contains all core logic for the spellchecker plugin.
 *
 * @class tinymce.spellcheckerplugin.Plugin
 * @private
 */
define("tinymce/spellcheckerplugin/Plugin", [
	"tinymce/spellcheckerplugin/DomTextMatcher",
	"tinymce/PluginManager",
	"tinymce/util/Tools",
	"tinymce/ui/Menu",
	"tinymce/dom/DOMUtils",
	"tinymce/util/XHR",
	"tinymce/util/URI",
	"tinymce/util/JSON"
], function(DomTextMatcher, PluginManager, Tools, Menu, DOMUtils, XHR, URI, JSON) {
	PluginManager.add('spellchecker', function(editor, url) {
		var languageMenuItems, self = this, lastSuggestions, started, suggestionsMenu, settings = editor.settings;
		var hasDictionarySupport;

		function getTextMatcher() {
			if (!self.textMatcher) {
				self.textMatcher = new DomTextMatcher(editor.getBody(), editor);
			}

			return self.textMatcher;
		}

		function buildMenuItems(listName, languageValues) {
			var items = [];

			Tools.each(languageValues, function(languageValue) {
				items.push({
					selectable: true,
					text: languageValue.name,
					data: languageValue.value
				});
			});

			return items;
		}

		// draw back if power version is requested and registered
		if (/(^|[ ,])tinymcespellchecker([, ]|$)/.test(settings.plugins) && PluginManager.get('tinymcespellchecker')) {
			/*eslint no-console:0 */
			if (typeof console !== "undefined" && console.log) {
				console.log(
					"Spell Checker Pro is incompatible with Spell Checker plugin! " +
					"Remove 'spellchecker' from the 'plugins' option."
				);
			}
			return;
		}

		var languagesString = settings.spellchecker_languages ||
			'English=en,Danish=da,Dutch=nl,Finnish=fi,French=fr_FR,' +
			'German=de,Italian=it,Polish=pl,Portuguese=pt_BR,' +
			'Spanish=es,Swedish=sv';

		languageMenuItems = buildMenuItems('Language',
			Tools.map(languagesString.split(','), function(langPair) {
				langPair = langPair.split('=');

				return {
					name: langPair[0],
					value: langPair[1]
				};
			})
		);

		function isEmpty(obj) {
			/*jshint unused:false*/
			/*eslint no-unused-vars:0 */
			for (var name in obj) {
				return false;
			}

			return true;
		}

		function showSuggestions(word, spans) {
			var items = [], suggestions = lastSuggestions[word];

			Tools.each(suggestions, function(suggestion) {
				items.push({
					text: suggestion,
					onclick: function() {
						editor.insertContent(editor.dom.encode(suggestion));
						editor.dom.remove(spans);
						checkIfFinished();
					}
				});
			});

			items.push({text: '-'});

			if (hasDictionarySupport) {
				items.push({text: 'Add to Dictionary', onclick: function() {
					addToDictionary(word, spans);
				}});
			}

			items.push.apply(items, [
				{text: 'Ignore', onclick: function() {
					ignoreWord(word, spans);
				}},

				{text: 'Ignore all', onclick: function() {
					ignoreWord(word, spans, true);
				}}
			]);

			// Render menu
			suggestionsMenu = new Menu({
				items: items,
				context: 'contextmenu',
				onautohide: function(e) {
					if (e.target.className.indexOf('spellchecker') != -1) {
						e.preventDefault();
					}
				},
				onhide: function() {
					suggestionsMenu.remove();
					suggestionsMenu = null;
				}
			});

			suggestionsMenu.renderTo(document.body);

			// Position menu
			var pos = DOMUtils.DOM.getPos(editor.getContentAreaContainer());
			var targetPos = editor.dom.getPos(spans[0]);
			var root = editor.dom.getRoot();

			// Adjust targetPos for scrolling in the editor
			if (root.nodeName == 'BODY') {
				targetPos.x -= root.ownerDocument.documentElement.scrollLeft || root.scrollLeft;
				targetPos.y -= root.ownerDocument.documentElement.scrollTop || root.scrollTop;
			} else {
				targetPos.x -= root.scrollLeft;
				targetPos.y -= root.scrollTop;
			}

			pos.x += targetPos.x;
			pos.y += targetPos.y;

			suggestionsMenu.moveTo(pos.x, pos.y + spans[0].offsetHeight);
		}

		function getWordCharPattern() {
			// Regexp for finding word specific characters this will split words by
			// spaces, quotes, copy right characters etc. It's escaped with unicode characters
			// to make it easier to output scripts on servers using different encodings
			// so if you add any characters outside the 128 byte range make sure to escape it
			return editor.getParam('spellchecker_wordchar_pattern') || new RegExp("[^" +
				"\\s!\"#$%&()*+,-./:;<=>?@[\\]^_{|}`" +
				"\u00a7\u00a9\u00ab\u00ae\u00b1\u00b6\u00b7\u00b8\u00bb" +
				"\u00bc\u00bd\u00be\u00bf\u00d7\u00f7\u00a4\u201d\u201c\u201e\u00a0\u2002\u2003\u2009" +
			"]+", "g");
		}

		function defaultSpellcheckCallback(method, text, doneCallback, errorCallback) {
			var data = {method: method, lang: settings.spellchecker_language}, postData = '';

			data[method == "addToDictionary" ? "word" : "text"] = text;

			Tools.each(data, function(value, key) {
				if (postData) {
					postData += '&';
				}

				postData += key + '=' + encodeURIComponent(value);
			});

			XHR.send({
				url: new URI(url).toAbsolute(settings.spellchecker_rpc_url),
				type: "post",
				content_type: 'application/x-www-form-urlencoded',
				data: postData,
				success: function(result) {
					result = JSON.parse(result);

					if (!result) {
						var message = editor.translate("Server response wasn't proper JSON.");
						errorCallback(message);
					} else if (result.error) {
						errorCallback(result.error);
					} else {
						doneCallback(result);
					}
				},
				error: function() {
					var message = editor.translate("The spelling service was not found: (") +
							settings.spellchecker_rpc_url +
							editor.translate(")");
					errorCallback(message);
				}
			});
		}

		function sendRpcCall(name, data, successCallback, errorCallback) {
			var spellCheckCallback = settings.spellchecker_callback || defaultSpellcheckCallback;
			spellCheckCallback.call(self, name, data, successCallback, errorCallback);
		}

		function spellcheck() {
			if (finish()) {
				return;
			}

			function errorCallback(message) {
				editor.notificationManager.open({text: message, type: 'error'});
				editor.setProgressState(false);
				finish();
			}

			editor.setProgressState(true);
			sendRpcCall("spellcheck", getTextMatcher().text, markErrors, errorCallback);
			editor.focus();
		}

		function checkIfFinished() {
			if (!editor.dom.select('span.mce-spellchecker-word').length) {
				finish();
			}
		}

		function addToDictionary(word, spans) {
			editor.setProgressState(true);

			sendRpcCall("addToDictionary", word, function() {
				editor.setProgressState(false);
				editor.dom.remove(spans, true);
				checkIfFinished();
			}, function(message) {
				editor.notificationManager.open({text: message, type: 'error'});
				editor.setProgressState(false);
			});
		}

		function ignoreWord(word, spans, all) {
			editor.selection.collapse();

			if (all) {
				Tools.each(editor.dom.select('span.mce-spellchecker-word'), function(span) {
					if (span.getAttribute('data-mce-word') == word) {
						editor.dom.remove(span, true);
					}
				});
			} else {
				editor.dom.remove(spans, true);
			}

			checkIfFinished();
		}

		function finish() {
			getTextMatcher().reset();
			self.textMatcher = null;

			if (started) {
				started = false;
				editor.fire('SpellcheckEnd');
				return true;
			}
		}

		function getElmIndex(elm) {
			var value = elm.getAttribute('data-mce-index');

			if (typeof value == "number") {
				return "" + value;
			}

			return value;
		}

		function findSpansByIndex(index) {
			var nodes, spans = [];

			nodes = Tools.toArray(editor.getBody().getElementsByTagName('span'));
			if (nodes.length) {
				for (var i = 0; i < nodes.length; i++) {
					var nodeIndex = getElmIndex(nodes[i]);

					if (nodeIndex === null || !nodeIndex.length) {
						continue;
					}

					if (nodeIndex === index.toString()) {
						spans.push(nodes[i]);
					}
				}
			}

			return spans;
		}

		editor.on('click', function(e) {
			var target = e.target;

			if (target.className == "mce-spellchecker-word") {
				e.preventDefault();

				var spans = findSpansByIndex(getElmIndex(target));

				if (spans.length > 0) {
					var rng = editor.dom.createRng();
					rng.setStartBefore(spans[0]);
					rng.setEndAfter(spans[spans.length - 1]);
					editor.selection.setRng(rng);
					showSuggestions(target.getAttribute('data-mce-word'), spans);
				}
			}
		});

		editor.addMenuItem('spellchecker', {
			text: 'Spellcheck',
			context: 'tools',
			onclick: spellcheck,
			selectable: true,
			onPostRender: function() {
				var self = this;

				self.active(started);

				editor.on('SpellcheckStart SpellcheckEnd', function() {
					self.active(started);
				});
			}
		});

		function updateSelection(e) {
			var selectedLanguage = settings.spellchecker_language;

			e.control.items().each(function(ctrl) {
				ctrl.active(ctrl.settings.data === selectedLanguage);
			});
		}

		/**
		 * Find the specified words and marks them. It will also show suggestions for those words.
		 *
		 * @example
		 * editor.plugins.spellchecker.markErrors({
		 *     dictionary: true,
		 *     words: {
		 *         "word1": ["suggestion 1", "Suggestion 2"]
		 *     }
		 * });
		 * @param {Object} data Data object containing the words with suggestions.
		 */
		function markErrors(data) {
			var suggestions;

			if (data.words) {
				hasDictionarySupport = !!data.dictionary;
				suggestions = data.words;
			} else {
				// Fallback to old format
				suggestions = data;
			}

			editor.setProgressState(false);

			if (isEmpty(suggestions)) {
				var message = editor.translate('No misspellings found.');
				editor.notificationManager.open({text: message, type: 'info'});
				started = false;
				return;
			}

			lastSuggestions = suggestions;

			getTextMatcher().find(getWordCharPattern()).filter(function(match) {
				return !!suggestions[match.text];
			}).wrap(function(match) {
				return editor.dom.create('span', {
					"class": 'mce-spellchecker-word',
					"data-mce-bogus": 1,
					"data-mce-word": match.text
				});
			});

			started = true;
			editor.fire('SpellcheckStart');
		}

		var buttonArgs = {
			tooltip: 'Spellcheck',
			onclick: spellcheck,
			onPostRender: function() {
				var self = this;

				editor.on('SpellcheckStart SpellcheckEnd', function() {
					self.active(started);
				});
			}
		};

		if (languageMenuItems.length > 1) {
			buttonArgs.type = 'splitbutton';
			buttonArgs.menu = languageMenuItems;
			buttonArgs.onshow = updateSelection;
			buttonArgs.onselect = function(e) {
				settings.spellchecker_language = e.control.settings.data;
			};
		}

		editor.addButton('spellchecker', buttonArgs);
		editor.addCommand('mceSpellCheck', spellcheck);

		editor.on('remove', function() {
			if (suggestionsMenu) {
				suggestionsMenu.remove();
				suggestionsMenu = null;
			}
		});

		editor.on('change', checkIfFinished);

		this.getTextMatcher = getTextMatcher;
		this.getWordCharPattern = getWordCharPattern;
		this.markErrors = markErrors;
		this.getLanguage = function() {
			return settings.spellchecker_language;
		};

		// Set default spellchecker language if it's not specified
		settings.spellchecker_language = settings.spellchecker_language || settings.language || 'en';
	});
});

expose(["tinymce/spellcheckerplugin/DomTextMatcher"]);
})(window);
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('tabfocus', function(editor) {
	var DOM = tinymce.DOM, each = tinymce.each, explode = tinymce.explode;

	function tabCancel(e) {
		if (e.keyCode === 9 && !e.ctrlKey && !e.altKey && !e.metaKey) {
			e.preventDefault();
		}
	}

	function tabHandler(e) {
		var x, el, v, i;

		if (e.keyCode !== 9 || e.ctrlKey || e.altKey || e.metaKey || e.isDefaultPrevented()) {
			return;
		}

		function find(direction) {
			el = DOM.select(':input:enabled,*[tabindex]:not(iframe)');

			function canSelectRecursive(e) {
				return e.nodeName === "BODY" || (e.type != 'hidden' &&
					e.style.display != "none" &&
					e.style.visibility != "hidden" && canSelectRecursive(e.parentNode));
			}

			function canSelect(el) {
				return /INPUT|TEXTAREA|BUTTON/.test(el.tagName) && tinymce.get(e.id) && el.tabIndex != -1 && canSelectRecursive(el);
			}

			each(el, function(e, i) {
				if (e.id == editor.id) {
					x = i;
					return false;
				}
			});
			if (direction > 0) {
				for (i = x + 1; i < el.length; i++) {
					if (canSelect(el[i])) {
						return el[i];
					}
				}
			} else {
				for (i = x - 1; i >= 0; i--) {
					if (canSelect(el[i])) {
						return el[i];
					}
				}
			}

			return null;
		}

		v = explode(editor.getParam('tab_focus', editor.getParam('tabfocus_elements', ':prev,:next')));

		if (v.length == 1) {
			v[1] = v[0];
			v[0] = ':prev';
		}

		// Find element to focus
		if (e.shiftKey) {
			if (v[0] == ':prev') {
				el = find(-1);
			} else {
				el = DOM.get(v[0]);
			}
		} else {
			if (v[1] == ':next') {
				el = find(1);
			} else {
				el = DOM.get(v[1]);
			}
		}

		if (el) {
			var focusEditor = tinymce.get(el.id || el.name);

			if (el.id && focusEditor) {
				focusEditor.focus();
			} else {
				tinymce.util.Delay.setTimeout(function() {
					if (!tinymce.Env.webkit) {
						window.focus();
					}

					el.focus();
				}, 10);
			}

			e.preventDefault();
		}
	}

	editor.on('init', function() {
		if (editor.inline) {
			// Remove default tabIndex in inline mode
			tinymce.DOM.setAttrib(editor.getBody(), 'tabIndex', null);
		}

		editor.on('keyup', tabCancel);

		if (tinymce.Env.gecko) {
			editor.on('keypress keydown', tabHandler);
		} else {
			editor.on('keydown', tabHandler);
		}
	});
});

/**
 * Compiled inline version. (Library mode)
 */

/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */
/*globals $code */

(function(exports, undefined) {
	"use strict";

	var modules = {};

	function require(ids, callback) {
		var module, defs = [];

		for (var i = 0; i < ids.length; ++i) {
			module = modules[ids[i]] || resolve(ids[i]);
			if (!module) {
				throw 'module definition dependecy not found: ' + ids[i];
			}

			defs.push(module);
		}

		callback.apply(null, defs);
	}

	function define(id, dependencies, definition) {
		if (typeof id !== 'string') {
			throw 'invalid module definition, module id must be defined and be a string';
		}

		if (dependencies === undefined) {
			throw 'invalid module definition, dependencies must be specified';
		}

		if (definition === undefined) {
			throw 'invalid module definition, definition function must be specified';
		}

		require(dependencies, function() {
			modules[id] = definition.apply(null, arguments);
		});
	}

	function defined(id) {
		return !!modules[id];
	}

	function resolve(id) {
		var target = exports;
		var fragments = id.split(/[.\/]/);

		for (var fi = 0; fi < fragments.length; ++fi) {
			if (!target[fragments[fi]]) {
				return;
			}

			target = target[fragments[fi]];
		}

		return target;
	}

	function expose(ids) {
		var i, target, id, fragments, privateModules;

		for (i = 0; i < ids.length; i++) {
			target = exports;
			id = ids[i];
			fragments = id.split(/[.\/]/);

			for (var fi = 0; fi < fragments.length - 1; ++fi) {
				if (target[fragments[fi]] === undefined) {
					target[fragments[fi]] = {};
				}

				target = target[fragments[fi]];
			}

			target[fragments[fragments.length - 1]] = modules[id];
		}

		// Expose private modules for unit tests
		if (exports.AMDLC_TESTS) {
			privateModules = exports.privateModules || {};

			for (id in modules) {
				privateModules[id] = modules[id];
			}

			for (i = 0; i < ids.length; i++) {
				delete privateModules[ids[i]];
			}

			exports.privateModules = privateModules;
		}
	}

// Included from: js/tinymce/plugins/table/classes/Utils.js

/**
 * Utils.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Various utility functions.
 *
 * @class tinymce.tableplugin.Utils
 * @private
 */
define("tinymce/tableplugin/Utils", [
	"tinymce/Env"
], function(Env) {
	var setSpanVal = function (name) {
		return function (td, val) {
			if (td) {
				val = parseInt(val, 10);

				if (val === 1 || val === 0) {
					td.removeAttribute(name, 1);
				} else {
					td.setAttribute(name, val, 1);
				}
			}
		};
	};

	var getSpanVal = function (name) {
		return function (td) {
			return parseInt(td.getAttribute(name) || 1, 10);
		};
	};

	function paddCell(cell) {
		if (!Env.ie || Env.ie > 9) {
			if (!cell.hasChildNodes()) {
				cell.innerHTML = '<br data-mce-bogus="1" />';
			}
		}
	}

	return {
		setColSpan: setSpanVal('colSpan'),
		setRowSpan: setSpanVal('rowspan'),
		getColSpan: getSpanVal('colSpan'),
		getRowSpan: getSpanVal('rowSpan'),
		setSpanVal: function (td, name, value) {
			setSpanVal(name)(td, value);
		},
		getSpanVal: function (td, name) {
			return getSpanVal(name)(td);
		},
		paddCell: paddCell
	};
});

// Included from: js/tinymce/plugins/table/classes/SplitCols.js

/**
 * SplitCols.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * Contains logic for handling splitting of merged rows.
 *
 * @class tinymce.tableplugin.SplitCols
 * @private
 */
define("tinymce/tableplugin/SplitCols", [
	"tinymce/util/Tools",
	"tinymce/tableplugin/Utils"
], function(Tools, Utils) {
	var getCellAt = function (grid, x, y) {
		return grid[y] ? grid[y][x] : null;
	};

	var getCellElmAt = function (grid, x, y) {
		var cell = getCellAt(grid, x, y);
		return cell ? cell.elm : null;
	};

	var countHoles = function (grid, x, y, delta) {
		var y2, cell, count = 0, elm = getCellElmAt(grid, x, y);

		for (y2 = y; delta > 0 ? y2 < grid.length : y2 >= 0; y2 += delta) {
			cell = getCellAt(grid, x, y2);
			if (elm !== cell.elm) {
				break;
			}

			count++;
		}

		return count;
	};

	var findRealElm = function (grid, x, y) {
		var cell, row = grid[y];

		for (var x2 = x; x2 < row.length; x2++) {
			cell = row[x2];
			if (cell.real) {
				return cell.elm;
			}
		}

		return null;
	};

	var getRowSplitInfo = function (grid, y) {
		var cell, result = [], row = grid[y];

		for (var x = 0; x < row.length; x++) {
			cell = row[x];
			result.push({
				elm: cell.elm,
				above: countHoles(grid, x, y, -1) - 1,
				below: countHoles(grid, x, y, 1) - 1
			});

			x += Utils.getColSpan(cell.elm) - 1;
		}

		return result;
	};

	var createCell = function (info, rowSpan) {
		var doc = info.elm.ownerDocument;
		var newCell = doc.createElement('td');

		Utils.setColSpan(newCell, Utils.getColSpan(info.elm));
		Utils.setRowSpan(newCell, rowSpan);
		Utils.paddCell(newCell);

		return newCell;
	};

	var insertOrAppendCell = function (grid, newCell, x, y) {
		var realCellElm = findRealElm(grid, x + 1, y);

		if (!realCellElm) {
			realCellElm = findRealElm(grid, 0, y);
			realCellElm.parentNode.appendChild(newCell);
		} else {
			realCellElm.parentNode.insertBefore(newCell, realCellElm);
		}
	};

	var splitAbove = function (grid, info, x, y) {
		if (info.above !== 0) {
			Utils.setRowSpan(info.elm, info.above);
			var cell = createCell(info, info.below + 1);
			insertOrAppendCell(grid, cell, x, y);
			return cell;
		}

		return null;
	};

	var splitBelow = function (grid, info, x, y) {
		if (info.below !== 0) {
			Utils.setRowSpan(info.elm, info.above + 1);
			var cell = createCell(info, info.below);
			insertOrAppendCell(grid, cell, x, y + 1);
			return cell;
		}

		return null;
	};

	var splitAt = function (grid, x, y, before) {
		var rowInfos = getRowSplitInfo(grid, y);
		var rowElm = getCellElmAt(grid, x, y).parentNode;
		var cells = [];

		Tools.each(rowInfos, function (info, x) {
			var cell = before ? splitAbove(grid, info, x, y) : splitBelow(grid, info, x, y);
			if (cell !== null) {
				cells.push(cells);
			}
		});

		return {
			cells: cells,
			row: rowElm
		};
	};

	return {
		splitAt: splitAt
	};
});

// Included from: js/tinymce/plugins/table/classes/TableGrid.js

/**
 * TableGrid.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * This class creates a grid out of a table element. This
 * makes it a whole lot easier to handle complex tables with
 * col/row spans.
 *
 * @class tinymce.tableplugin.TableGrid
 * @private
 */
define("tinymce/tableplugin/TableGrid", [
	"tinymce/util/Tools",
	"tinymce/Env",
	"tinymce/tableplugin/Utils",
	"tinymce/tableplugin/SplitCols"
], function(Tools, Env, Utils, SplitCols) {
	var each = Tools.each, getSpanVal = Utils.getSpanVal, setSpanVal = Utils.setSpanVal;

	return function(editor, table, selectedCell) {
		var grid, gridWidth, startPos, endPos, selection = editor.selection, dom = selection.dom;

		function removeCellSelection() {
			editor.$('td[data-mce-selected],th[data-mce-selected]').removeAttr('data-mce-selected');
		}

		function isEditorBody(node) {
			return node === editor.getBody();
		}

		function getChildrenByName(node, names) {
			if (!node) {
				return [];
			}

			names = Tools.map(names.split(','), function(name) {
				return name.toLowerCase();
			});

			return Tools.grep(node.childNodes, function(node) {
				return Tools.inArray(names, node.nodeName.toLowerCase()) !== -1;
			});
		}

		function buildGrid() {
			var startY = 0;

			grid = [];
			gridWidth = 0;

			each(['thead', 'tbody', 'tfoot'], function(part) {
				var partElm = getChildrenByName(table, part)[0];
				var rows = getChildrenByName(partElm, 'tr');

				each(rows, function(tr, y) {
					y += startY;

					each(getChildrenByName(tr, 'td,th'), function(td, x) {
						var x2, y2, rowspan, colspan;

						// Skip over existing cells produced by rowspan
						if (grid[y]) {
							while (grid[y][x]) {
								x++;
							}
						}

						// Get col/rowspan from cell
						rowspan = getSpanVal(td, 'rowspan');
						colspan = getSpanVal(td, 'colspan');

						// Fill out rowspan/colspan right and down
						for (y2 = y; y2 < y + rowspan; y2++) {
							if (!grid[y2]) {
								grid[y2] = [];
							}

							for (x2 = x; x2 < x + colspan; x2++) {
								grid[y2][x2] = {
									part: part,
									real: y2 == y && x2 == x,
									elm: td,
									rowspan: rowspan,
									colspan: colspan
								};
							}
						}

						gridWidth = Math.max(gridWidth, x + 1);
					});
				});

				startY += rows.length;
			});
		}

		function fireNewRow(node) {
			editor.fire('newrow', {
				node: node
			});

			return node;
		}

		function fireNewCell(node) {
			editor.fire('newcell', {
				node: node
			});

			return node;
		}

		function cloneNode(node, children) {
			node = node.cloneNode(children);
			node.removeAttribute('id');

			return node;
		}

		function getCell(x, y) {
			var row;

			row = grid[y];
			if (row) {
				return row[x];
			}
		}

		function getRow(grid, y) {
			return grid[y] ? grid[y] : null;
		}

		function getColumn(grid, x) {
			var out = [];

			for (var y = 0; y < grid.length; y++) {
				out.push(getCell(x, y));
			}

			return out;
		}

		function isCellSelected(cell) {
			return cell && (!!dom.getAttrib(cell.elm, 'data-mce-selected') || cell == selectedCell);
		}

		function getSelectedRows() {
			var rows = [];

			each(table.rows, function(row) {
				each(row.cells, function(cell) {
					if (dom.getAttrib(cell, 'data-mce-selected') || (selectedCell && cell == selectedCell.elm)) {
						rows.push(row);
						return false;
					}
				});
			});

			return rows;
		}

		function countSelectedCols() {
			var cols = 0;

			each(grid, function(row) {
				each(row, function(cell) {
					if (isCellSelected(cell)) {
						cols++;
					}
				});
				if (cols) {
					return false;
				}
			});

			return cols;
		}

		function deleteTable() {
			var rng = dom.createRng();

			if (isEditorBody(table)) {
				return;
			}

			rng.setStartAfter(table);
			rng.setEndAfter(table);

			selection.setRng(rng);

			dom.remove(table);
		}

		function cloneCell(cell) {
			var formatNode, cloneFormats = {};

			if (editor.settings.table_clone_elements !== false) {
				cloneFormats = Tools.makeMap(
					(editor.settings.table_clone_elements || 'strong em b i span font h1 h2 h3 h4 h5 h6 p div').toUpperCase(),
					/[ ,]/
				);
			}

			// Clone formats
			Tools.walk(cell, function(node) {
				var curNode;

				if (node.nodeType == 3) {
					each(dom.getParents(node.parentNode, null, cell).reverse(), function(node) {
						if (!cloneFormats[node.nodeName]) {
							return;
						}

						node = cloneNode(node, false);

						if (!formatNode) {
							formatNode = curNode = node;
						} else if (curNode) {
							curNode.appendChild(node);
						}

						curNode = node;
					});

					// Add something to the inner node
					if (curNode) {
						curNode.innerHTML = Env.ie && Env.ie < 10 ? '&nbsp;' : '<br data-mce-bogus="1" />';
					}

					return false;
				}
			}, 'childNodes');

			cell = cloneNode(cell, false);
			fireNewCell(cell);

			setSpanVal(cell, 'rowSpan', 1);
			setSpanVal(cell, 'colSpan', 1);

			if (formatNode) {
				cell.appendChild(formatNode);
			} else {
				Utils.paddCell(cell);
			}

			return cell;
		}

		function cleanup() {
			var rng = dom.createRng(), row;

			// Empty rows
			each(dom.select('tr', table), function(tr) {
				if (tr.cells.length === 0) {
					dom.remove(tr);
				}
			});

			// Empty table
			if (dom.select('tr', table).length === 0) {
				rng.setStartBefore(table);
				rng.setEndBefore(table);
				selection.setRng(rng);
				dom.remove(table);
				return;
			}

			// Empty header/body/footer
			each(dom.select('thead,tbody,tfoot', table), function(part) {
				if (part.rows.length === 0) {
					dom.remove(part);
				}
			});

			// Restore selection to start position if it still exists
			buildGrid();

			// If we have a valid startPos object
			if (startPos) {
				// Restore the selection to the closest table position
				row = grid[Math.min(grid.length - 1, startPos.y)];
				if (row) {
					selection.select(row[Math.min(row.length - 1, startPos.x)].elm, true);
					selection.collapse(true);
				}
			}
		}

		function fillLeftDown(x, y, rows, cols) {
			var tr, x2, r, c, cell;

			tr = grid[y][x].elm.parentNode;
			for (r = 1; r <= rows; r++) {
				tr = dom.getNext(tr, 'tr');

				if (tr) {
					// Loop left to find real cell
					for (x2 = x; x2 >= 0; x2--) {
						cell = grid[y + r][x2].elm;

						if (cell.parentNode == tr) {
							// Append clones after
							for (c = 1; c <= cols; c++) {
								dom.insertAfter(cloneCell(cell), cell);
							}

							break;
						}
					}

					if (x2 == -1) {
						// Insert nodes before first cell
						for (c = 1; c <= cols; c++) {
							tr.insertBefore(cloneCell(tr.cells[0]), tr.cells[0]);
						}
					}
				}
			}
		}

		function split() {
			each(grid, function(row, y) {
				each(row, function(cell, x) {
					var colSpan, rowSpan, i;

					if (isCellSelected(cell)) {
						cell = cell.elm;
						colSpan = getSpanVal(cell, 'colspan');
						rowSpan = getSpanVal(cell, 'rowspan');

						if (colSpan > 1 || rowSpan > 1) {
							setSpanVal(cell, 'rowSpan', 1);
							setSpanVal(cell, 'colSpan', 1);

							// Insert cells right
							for (i = 0; i < colSpan - 1; i++) {
								dom.insertAfter(cloneCell(cell), cell);
							}

							fillLeftDown(x, y, rowSpan - 1, colSpan);
						}
					}
				});
			});
		}

		function findItemsOutsideOfRange(items, start, end) {
			var out = [];

			for (var i = 0; i < items.length; i++) {
				if (i < start || i > end) {
					out.push(items[i]);
				}
			}

			return out;
		}

		function getFakeCells(cells) {
			return Tools.grep(cells, function (cell) {
				return cell.real === false;
			});
		}

		function getUniqueElms(cells) {
			var elms = [];

			for (var i = 0; i < cells.length; i++) {
				var elm = cells[i].elm;
				if (elms[elms.length - 1] !== elm) {
					elms.push(elm);
				}
			}

			return elms;
		}

		function reduceRowSpans(grid, startX, startY, endX, endY) {
			var count = 0;

			if (endY - startY < 1) {
				return 0;
			}

			for (var y = startY + 1; y <= endY; y++) {
				var allCells = findItemsOutsideOfRange(getRow(grid, y), startX, endX);
				var fakeCells = getFakeCells(allCells);

				if (allCells.length === fakeCells.length) {
					Tools.each(getUniqueElms(fakeCells), function (elm) {
						Utils.setRowSpan(elm, Utils.getRowSpan(elm) - 1);
					});

					count++;
				}
			}

			return count;
		}

		function reduceColSpans(grid, startX, startY, endX, endY) {
			var count = 0;

			if (endX - startX < 1) {
				return 0;
			}

			for (var x = startX + 1; x <= endX; x++) {
				var allCells = findItemsOutsideOfRange(getColumn(grid, x), startY, endY);
				var fakeCells = getFakeCells(allCells);

				if (allCells.length === fakeCells.length) {
					Tools.each(getUniqueElms(fakeCells), function (elm) {
						Utils.setColSpan(elm, Utils.getColSpan(elm) - 1);
					});

					count++;
				}
			}

			return count;
		}

		function merge(cell, cols, rows) {
			var pos, startX, startY, endX, endY, x, y, startCell, endCell, children, count, reducedRows, reducedCols;

			// Use specified cell and cols/rows
			if (cell) {
				pos = getPos(cell);
				startX = pos.x;
				startY = pos.y;
				endX = startX + (cols - 1);
				endY = startY + (rows - 1);
			} else {
				startPos = endPos = null;

				// Calculate start/end pos by checking for selected cells in grid works better with context menu
				each(grid, function(row, y) {
					each(row, function(cell, x) {
						if (isCellSelected(cell)) {
							if (!startPos) {
								startPos = {x: x, y: y};
							}

							endPos = {x: x, y: y};
						}
					});
				});

				// Use selection, but make sure startPos is valid before accessing
				if (startPos) {
					startX = startPos.x;
					startY = startPos.y;
					endX = endPos.x;
					endY = endPos.y;
				}
			}

			// Find start/end cells
			startCell = getCell(startX, startY);
			endCell = getCell(endX, endY);

			// Check if the cells exists and if they are of the same part for example tbody = tbody
			if (startCell && endCell && startCell.part == endCell.part) {
				// Split and rebuild grid
				split();
				buildGrid();

				reducedRows = reduceRowSpans(grid, startX, startY, endX, endY);
				reducedCols = reduceColSpans(grid, startX, startY, endX, endY);

				// Set row/col span to start cell
				startCell = getCell(startX, startY).elm;
				var colSpan = (endX - startX - reducedCols) + 1;
				var rowSpan = (endY - startY - reducedRows) + 1;

				// All cells in table selected then just make it a table with one cell
				if (colSpan === gridWidth && rowSpan === grid.length) {
					colSpan = 1;
					rowSpan = 1;
				}

				// Multiple whole rows selected then just make it one rowSpan
				if (colSpan === gridWidth && rowSpan > 1) {
					rowSpan = 1;
				}

				setSpanVal(startCell, 'colSpan', colSpan);
				setSpanVal(startCell, 'rowSpan', rowSpan);

				// Remove other cells and add it's contents to the start cell
				for (y = startY; y <= endY; y++) {
					for (x = startX; x <= endX; x++) {
						if (!grid[y] || !grid[y][x]) {
							continue;
						}

						cell = grid[y][x].elm;

						/*jshint loopfunc:true */
						/*eslint no-loop-func:0 */
						if (cell != startCell) {
							// Move children to startCell
							children = Tools.grep(cell.childNodes);
							each(children, function(node) {
								startCell.appendChild(node);
							});

							// Remove bogus nodes if there is children in the target cell
							if (children.length) {
								children = Tools.grep(startCell.childNodes);
								count = 0;
								each(children, function(node) {
									if (node.nodeName == 'BR' && count++ < children.length - 1) {
										startCell.removeChild(node);
									}
								});
							}

							dom.remove(cell);
						}
					}
				}

				// Remove empty rows etc and restore caret location
				cleanup();
			}
		}

		function insertRow(before) {
			var posY, cell, lastCell, x, rowElm, newRow, newCell, otherCell, rowSpan, spanValue;

			// Find first/last row
			each(grid, function(row, y) {
				each(row, function(cell) {
					if (isCellSelected(cell)) {
						cell = cell.elm;
						rowElm = cell.parentNode;
						newRow = fireNewRow(cloneNode(rowElm, false));
						posY = y;

						if (before) {
							return false;
						}
					}
				});

				if (before) {
					return posY === undefined;
				}
			});

			// If posY is undefined there is nothing for us to do here...just return to avoid crashing below
			if (posY === undefined) {
				return;
			}

			for (x = 0, spanValue = 0; x < grid[0].length; x += spanValue) {
				// Cell not found could be because of an invalid table structure
				if (!grid[posY][x]) {
					continue;
				}

				cell = grid[posY][x].elm;
				spanValue = getSpanVal(cell, 'colspan');

				if (cell != lastCell) {
					if (!before) {
						rowSpan = getSpanVal(cell, 'rowspan');
						if (rowSpan > 1) {
							setSpanVal(cell, 'rowSpan', rowSpan + 1);
							continue;
						}
					} else {
						// Check if cell above can be expanded
						if (posY > 0 && grid[posY - 1][x]) {
							otherCell = grid[posY - 1][x].elm;
							rowSpan = getSpanVal(otherCell, 'rowSpan');
							if (rowSpan > 1) {
								setSpanVal(otherCell, 'rowSpan', rowSpan + 1);
								continue;
							}
						}
					}

					// Insert new cell into new row
					newCell = cloneCell(cell);
					setSpanVal(newCell, 'colSpan', cell.colSpan);

					newRow.appendChild(newCell);

					lastCell = cell;
				}
			}

			if (newRow.hasChildNodes()) {
				if (!before) {
					dom.insertAfter(newRow, rowElm);
				} else {
					rowElm.parentNode.insertBefore(newRow, rowElm);
				}
			}
		}

		function insertRows(before, num) {
			num = num || getSelectedRows().length || 1;
			for (var i = 0; i < num; i++) {
				insertRow(before);
			}
		}

		function insertCol(before) {
			var posX, lastCell;

			// Find first/last column
			each(grid, function(row) {
				each(row, function(cell, x) {
					if (isCellSelected(cell)) {
						posX = x;

						if (before) {
							return false;
						}
					}
				});

				if (before) {
					return posX === undefined;
				}
			});

			each(grid, function(row, y) {
				var cell, rowSpan, colSpan;

				if (!row[posX]) {
					return;
				}

				cell = row[posX].elm;
				if (cell != lastCell) {
					colSpan = getSpanVal(cell, 'colspan');
					rowSpan = getSpanVal(cell, 'rowspan');

					if (colSpan == 1) {
						if (!before) {
							dom.insertAfter(cloneCell(cell), cell);
							fillLeftDown(posX, y, rowSpan - 1, colSpan);
						} else {
							cell.parentNode.insertBefore(cloneCell(cell), cell);
							fillLeftDown(posX, y, rowSpan - 1, colSpan);
						}
					} else {
						setSpanVal(cell, 'colSpan', cell.colSpan + 1);
					}

					lastCell = cell;
				}
			});
		}

		function insertCols(before, num) {
			num = num || countSelectedCols() || 1;
			for (var i = 0; i < num; i++) {
				insertCol(before);
			}
		}

		function getSelectedCells(grid) {
			return Tools.grep(getAllCells(grid), isCellSelected);
		}

		function getAllCells(grid) {
			var cells = [];

			each(grid, function(row) {
				each(row, function(cell) {
					cells.push(cell);
				});
			});

			return cells;
		}

		function deleteCols() {
			var cols = [];

			if (isEditorBody(table)) {
				if (grid[0].length == 1) {
					return;
				}

				if (getSelectedCells(grid).length == getAllCells(grid).length) {
					return;
				}
			}

			// Get selected column indexes
			each(grid, function(row) {
				each(row, function(cell, x) {
					if (isCellSelected(cell) && Tools.inArray(cols, x) === -1) {
						each(grid, function(row) {
							var cell = row[x].elm, colSpan;

							colSpan = getSpanVal(cell, 'colSpan');

							if (colSpan > 1) {
								setSpanVal(cell, 'colSpan', colSpan - 1);
							} else {
								dom.remove(cell);
							}
						});

						cols.push(x);
					}
				});
			});

			cleanup();
		}

		function deleteRows() {
			var rows;

			function deleteRow(tr) {
				var pos, lastCell;

				// Move down row spanned cells
				each(tr.cells, function(cell) {
					var rowSpan = getSpanVal(cell, 'rowSpan');

					if (rowSpan > 1) {
						setSpanVal(cell, 'rowSpan', rowSpan - 1);
						pos = getPos(cell);
						fillLeftDown(pos.x, pos.y, 1, 1);
					}
				});

				// Delete cells
				pos = getPos(tr.cells[0]);
				each(grid[pos.y], function(cell) {
					var rowSpan;

					cell = cell.elm;

					if (cell != lastCell) {
						rowSpan = getSpanVal(cell, 'rowSpan');

						if (rowSpan <= 1) {
							dom.remove(cell);
						} else {
							setSpanVal(cell, 'rowSpan', rowSpan - 1);
						}

						lastCell = cell;
					}
				});
			}

			// Get selected rows and move selection out of scope
			rows = getSelectedRows();

			if (isEditorBody(table) && rows.length == table.rows.length) {
				return;
			}

			// Delete all selected rows
			each(rows.reverse(), function(tr) {
				deleteRow(tr);
			});

			cleanup();
		}

		function cutRows() {
			var rows = getSelectedRows();

			if (isEditorBody(table) && rows.length == table.rows.length) {
				return;
			}

			dom.remove(rows);
			cleanup();

			return rows;
		}

		function copyRows() {
			var rows = getSelectedRows();

			each(rows, function(row, i) {
				rows[i] = cloneNode(row, true);
			});

			return rows;
		}

		function pasteRows(rows, before) {
			var splitResult, targetRow, newRows;

			// Nothing to paste
			if (!rows) {
				return;
			}

			splitResult = SplitCols.splitAt(grid, startPos.x, startPos.y, before);
			targetRow = splitResult.row;
			Tools.each(splitResult.cells, fireNewCell);

			newRows = Tools.map(rows, function (row) {
				return row.cloneNode(true);
			});

			if (!before) {
				newRows.reverse();
			}

			each(newRows, function(row) {
				var i, cellCount = row.cells.length, cell;

				fireNewRow(row);

				// Remove col/rowspans
				for (i = 0; i < cellCount; i++) {
					cell = row.cells[i];

					fireNewCell(cell);
					setSpanVal(cell, 'colSpan', 1);
					setSpanVal(cell, 'rowSpan', 1);
				}

				// Needs more cells
				for (i = cellCount; i < gridWidth; i++) {
					row.appendChild(fireNewCell(cloneCell(row.cells[cellCount - 1])));
				}

				// Needs less cells
				for (i = gridWidth; i < cellCount; i++) {
					dom.remove(row.cells[i]);
				}

				// Add before/after
				if (before) {
					targetRow.parentNode.insertBefore(row, targetRow);
				} else {
					dom.insertAfter(row, targetRow);
				}
			});

			removeCellSelection();
		}

		function getPos(target) {
			var pos;

			each(grid, function(row, y) {
				each(row, function(cell, x) {
					if (cell.elm == target) {
						pos = {x: x, y: y};
						return false;
					}
				});

				return !pos;
			});

			return pos;
		}

		function setStartCell(cell) {
			startPos = getPos(cell);
		}

		function findEndPos() {
			var maxX, maxY;

			maxX = maxY = 0;

			each(grid, function(row, y) {
				each(row, function(cell, x) {
					var colSpan, rowSpan;

					if (isCellSelected(cell)) {
						cell = grid[y][x];

						if (x > maxX) {
							maxX = x;
						}

						if (y > maxY) {
							maxY = y;
						}

						if (cell.real) {
							colSpan = cell.colspan - 1;
							rowSpan = cell.rowspan - 1;

							if (colSpan) {
								if (x + colSpan > maxX) {
									maxX = x + colSpan;
								}
							}

							if (rowSpan) {
								if (y + rowSpan > maxY) {
									maxY = y + rowSpan;
								}
							}
						}
					}
				});
			});

			return {x: maxX, y: maxY};
		}

		function setEndCell(cell) {
			var startX, startY, endX, endY, maxX, maxY, colSpan, rowSpan, x, y;

			endPos = getPos(cell);

			if (startPos && endPos) {
				// Get start/end positions
				startX = Math.min(startPos.x, endPos.x);
				startY = Math.min(startPos.y, endPos.y);
				endX = Math.max(startPos.x, endPos.x);
				endY = Math.max(startPos.y, endPos.y);

				// Expand end position to include spans
				maxX = endX;
				maxY = endY;

				// This logic tried to expand the selection to always be a rectangle
				// Expand startX
				/*for (y = startY; y <= maxY; y++) {
					cell = grid[y][startX];

					if (!cell.real) {
						newX = startX - (cell.colspan - 1);
						if (newX < startX && newX >= 0) {
							startX = newX;
						}
					}
				}

				// Expand startY
				for (x = startX; x <= maxX; x++) {
					cell = grid[startY][x];

					if (!cell.real) {
						newY = startY - (cell.rowspan - 1);
						if (newY < startY && newY >= 0) {
							startY = newY;
						}
					}
				}*/

				// Find max X, Y
				for (y = startY; y <= endY; y++) {
					for (x = startX; x <= endX; x++) {
						cell = grid[y][x];

						if (cell.real) {
							colSpan = cell.colspan - 1;
							rowSpan = cell.rowspan - 1;

							if (colSpan) {
								if (x + colSpan > maxX) {
									maxX = x + colSpan;
								}
							}

							if (rowSpan) {
								if (y + rowSpan > maxY) {
									maxY = y + rowSpan;
								}
							}
						}
					}
				}

				removeCellSelection();

				// Add new selection
				for (y = startY; y <= maxY; y++) {
					for (x = startX; x <= maxX; x++) {
						if (grid[y][x]) {
							dom.setAttrib(grid[y][x].elm, 'data-mce-selected', '1');
						}
					}
				}
			}
		}

		function moveRelIdx(cellElm, delta) {
			var pos, index, cell;

			pos = getPos(cellElm);
			index = pos.y * gridWidth + pos.x;

			do {
				index += delta;
				cell = getCell(index % gridWidth, Math.floor(index / gridWidth));

				if (!cell) {
					break;
				}

				if (cell.elm != cellElm) {
					selection.select(cell.elm, true);

					if (dom.isEmpty(cell.elm)) {
						selection.collapse(true);
					}

					return true;
				}
			} while (cell.elm == cellElm);

			return false;
		}

		function splitCols(before) {
			if (startPos) {
				var splitResult = SplitCols.splitAt(grid, startPos.x, startPos.y, before);
				Tools.each(splitResult.cells, fireNewCell);
			}
		}

		table = table || dom.getParent(selection.getStart(true), 'table');

		buildGrid();

		selectedCell = selectedCell || dom.getParent(selection.getStart(true), 'th,td');

		if (selectedCell) {
			startPos = getPos(selectedCell);
			endPos = findEndPos();
			selectedCell = getCell(startPos.x, startPos.y);
		}

		Tools.extend(this, {
			deleteTable: deleteTable,
			split: split,
			merge: merge,
			insertRow: insertRow,
			insertRows: insertRows,
			insertCol: insertCol,
			insertCols: insertCols,
			splitCols: splitCols,
			deleteCols: deleteCols,
			deleteRows: deleteRows,
			cutRows: cutRows,
			copyRows: copyRows,
			pasteRows: pasteRows,
			getPos: getPos,
			setStartCell: setStartCell,
			setEndCell: setEndCell,
			moveRelIdx: moveRelIdx,
			refresh: buildGrid
		});
	};
});

// Included from: js/tinymce/plugins/table/classes/Quirks.js

/**
 * Quirks.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * This class includes fixes for various browser quirks.
 *
 * @class tinymce.tableplugin.Quirks
 * @private
 */
define("tinymce/tableplugin/Quirks", [
	"tinymce/util/VK",
	"tinymce/util/Delay",
	"tinymce/Env",
	"tinymce/util/Tools",
	"tinymce/tableplugin/Utils"
], function(VK, Delay, Env, Tools, Utils) {
	var each = Tools.each, getSpanVal = Utils.getSpanVal;

	return function(editor) {
		/**
		 * Fixed caret movement around tables on WebKit.
		 */
		function moveWebKitSelection() {
			function eventHandler(e) {
				var key = e.keyCode;

				function handle(upBool, sourceNode) {
					var siblingDirection = upBool ? 'previousSibling' : 'nextSibling';
					var currentRow = editor.dom.getParent(sourceNode, 'tr');
					var siblingRow = currentRow[siblingDirection];

					if (siblingRow) {
						moveCursorToRow(editor, sourceNode, siblingRow, upBool);
						e.preventDefault();
						return true;
					}

					var tableNode = editor.dom.getParent(currentRow, 'table');
					var middleNode = currentRow.parentNode;
					var parentNodeName = middleNode.nodeName.toLowerCase();
					if (parentNodeName === 'tbody' || parentNodeName === (upBool ? 'tfoot' : 'thead')) {
						var targetParent = getTargetParent(upBool, tableNode, middleNode, 'tbody');
						if (targetParent !== null) {
							return moveToRowInTarget(upBool, targetParent, sourceNode);
						}
					}

					return escapeTable(upBool, currentRow, siblingDirection, tableNode);
				}

				function getTargetParent(upBool, topNode, secondNode, nodeName) {
					var tbodies = editor.dom.select('>' + nodeName, topNode);
					var position = tbodies.indexOf(secondNode);
					if (upBool && position === 0 || !upBool && position === tbodies.length - 1) {
						return getFirstHeadOrFoot(upBool, topNode);
					} else if (position === -1) {
						var topOrBottom = secondNode.tagName.toLowerCase() === 'thead' ? 0 : tbodies.length - 1;
						return tbodies[topOrBottom];
					}

					return tbodies[position + (upBool ? -1 : 1)];
				}

				function getFirstHeadOrFoot(upBool, parent) {
					var tagName = upBool ? 'thead' : 'tfoot';
					var headOrFoot = editor.dom.select('>' + tagName, parent);
					return headOrFoot.length !== 0 ? headOrFoot[0] : null;
				}

				function moveToRowInTarget(upBool, targetParent, sourceNode) {
					var targetRow = getChildForDirection(targetParent, upBool);

					if (targetRow) {
						moveCursorToRow(editor, sourceNode, targetRow, upBool);
					}

					e.preventDefault();
					return true;
				}

				function escapeTable(upBool, currentRow, siblingDirection, table) {
					var tableSibling = table[siblingDirection];

					if (tableSibling) {
						moveCursorToStartOfElement(tableSibling);
						return true;
					}

					var parentCell = editor.dom.getParent(table, 'td,th');
					if (parentCell) {
						return handle(upBool, parentCell, e);
					}

					var backUpSibling = getChildForDirection(currentRow, !upBool);
					moveCursorToStartOfElement(backUpSibling);
					e.preventDefault();
					return false;
				}

				function getChildForDirection(parent, up) {
					var child = parent && parent[up ? 'lastChild' : 'firstChild'];
					// BR is not a valid table child to return in this case we return the table cell
					return child && child.nodeName === 'BR' ? editor.dom.getParent(child, 'td,th') : child;
				}

				function moveCursorToStartOfElement(n) {
					editor.selection.setCursorLocation(n, 0);
				}

				function isVerticalMovement() {
					return key == VK.UP || key == VK.DOWN;
				}

				function isInTable(editor) {
					var node = editor.selection.getNode();
					var currentRow = editor.dom.getParent(node, 'tr');
					return currentRow !== null;
				}

				function columnIndex(column) {
					var colIndex = 0;
					var c = column;
					while (c.previousSibling) {
						c = c.previousSibling;
						colIndex = colIndex + getSpanVal(c, "colspan");
					}
					return colIndex;
				}

				function findColumn(rowElement, columnIndex) {
					var c = 0, r = 0;

					each(rowElement.children, function(cell, i) {
						c = c + getSpanVal(cell, "colspan");
						r = i;
						if (c > columnIndex) {
							return false;
						}
					});
					return r;
				}

				function moveCursorToRow(ed, node, row, upBool) {
					var srcColumnIndex = columnIndex(editor.dom.getParent(node, 'td,th'));
					var tgtColumnIndex = findColumn(row, srcColumnIndex);
					var tgtNode = row.childNodes[tgtColumnIndex];
					var rowCellTarget = getChildForDirection(tgtNode, upBool);
					moveCursorToStartOfElement(rowCellTarget || tgtNode);
				}

				function shouldFixCaret(preBrowserNode) {
					var newNode = editor.selection.getNode();
					var newParent = editor.dom.getParent(newNode, 'td,th');
					var oldParent = editor.dom.getParent(preBrowserNode, 'td,th');

					return newParent && newParent !== oldParent && checkSameParentTable(newParent, oldParent);
				}

				function checkSameParentTable(nodeOne, NodeTwo) {
					return editor.dom.getParent(nodeOne, 'TABLE') === editor.dom.getParent(NodeTwo, 'TABLE');
				}

				if (isVerticalMovement() && isInTable(editor)) {
					var preBrowserNode = editor.selection.getNode();
					Delay.setEditorTimeout(editor, function() {
						if (shouldFixCaret(preBrowserNode)) {
							handle(!e.shiftKey && key === VK.UP, preBrowserNode, e);
						}
					}, 0);
				}
			}

			editor.on('KeyDown', function(e) {
				eventHandler(e);
			});
		}

		function fixBeforeTableCaretBug() {
			// Checks if the selection/caret is at the start of the specified block element
			function isAtStart(rng, par) {
				var doc = par.ownerDocument, rng2 = doc.createRange(), elm;

				rng2.setStartBefore(par);
				rng2.setEnd(rng.endContainer, rng.endOffset);

				elm = doc.createElement('body');
				elm.appendChild(rng2.cloneContents());

				// Check for text characters of other elements that should be treated as content
				return elm.innerHTML.replace(/<(br|img|object|embed|input|textarea)[^>]*>/gi, '-').replace(/<[^>]+>/g, '').length === 0;
			}

			// Fixes an bug where it's impossible to place the caret before a table in Gecko
			// this fix solves it by detecting when the caret is at the beginning of such a table
			// and then manually moves the caret infront of the table
			editor.on('KeyDown', function(e) {
				var rng, table, dom = editor.dom;

				// On gecko it's not possible to place the caret before a table
				if (e.keyCode == 37 || e.keyCode == 38) {
					rng = editor.selection.getRng();
					table = dom.getParent(rng.startContainer, 'table');

					if (table && editor.getBody().firstChild == table) {
						if (isAtStart(rng, table)) {
							rng = dom.createRng();

							rng.setStartBefore(table);
							rng.setEndBefore(table);

							editor.selection.setRng(rng);

							e.preventDefault();
						}
					}
				}
			});
		}

		// Fixes an issue on Gecko where it's impossible to place the caret behind a table
		// This fix will force a paragraph element after the table but only when the forced_root_block setting is enabled
		function fixTableCaretPos() {
			editor.on('KeyDown SetContent VisualAid', function() {
				var last;

				// Skip empty text nodes from the end
				for (last = editor.getBody().lastChild; last; last = last.previousSibling) {
					if (last.nodeType == 3) {
						if (last.nodeValue.length > 0) {
							break;
						}
					} else if (last.nodeType == 1 && (last.tagName == 'BR' || !last.getAttribute('data-mce-bogus'))) {
						break;
					}
				}

				if (last && last.nodeName == 'TABLE') {
					if (editor.settings.forced_root_block) {
						editor.dom.add(
							editor.getBody(),
							editor.settings.forced_root_block,
							editor.settings.forced_root_block_attrs,
							Env.ie && Env.ie < 10 ? '&nbsp;' : '<br data-mce-bogus="1" />'
						);
					} else {
						editor.dom.add(editor.getBody(), 'br', {'data-mce-bogus': '1'});
					}
				}
			});

			editor.on('PreProcess', function(o) {
				var last = o.node.lastChild;

				if (last && (last.nodeName == "BR" || (last.childNodes.length == 1 &&
					(last.firstChild.nodeName == 'BR' || last.firstChild.nodeValue == '\u00a0'))) &&
					last.previousSibling && last.previousSibling.nodeName == "TABLE") {
					editor.dom.remove(last);
				}
			});
		}

		// this nasty hack is here to work around some WebKit selection bugs.
		function fixTableCellSelection() {
			function tableCellSelected(ed, rng, n, currentCell) {
				// The decision of when a table cell is selected is somewhat involved.  The fact that this code is
				// required is actually a pointer to the root cause of this bug. A cell is selected when the start
				// and end offsets are 0, the start container is a text, and the selection node is either a TR (most cases)
				// or the parent of the table (in the case of the selection containing the last cell of a table).
				var TEXT_NODE = 3, table = ed.dom.getParent(rng.startContainer, 'TABLE');
				var tableParent, allOfCellSelected, tableCellSelection;

				if (table) {
					tableParent = table.parentNode;
				}

				allOfCellSelected = rng.startContainer.nodeType == TEXT_NODE &&
					rng.startOffset === 0 &&
					rng.endOffset === 0 &&
					currentCell &&
					(n.nodeName == "TR" || n == tableParent);

				tableCellSelection = (n.nodeName == "TD" || n.nodeName == "TH") && !currentCell;

				return allOfCellSelected || tableCellSelection;
			}

			function fixSelection() {
				var rng = editor.selection.getRng();
				var n = editor.selection.getNode();
				var currentCell = editor.dom.getParent(rng.startContainer, 'TD,TH');

				if (!tableCellSelected(editor, rng, n, currentCell)) {
					return;
				}

				if (!currentCell) {
					currentCell = n;
				}

				// Get the very last node inside the table cell
				var end = currentCell.lastChild;
				while (end.lastChild) {
					end = end.lastChild;
				}

				// Select the entire table cell. Nothing outside of the table cell should be selected.
				if (end.nodeType == 3) {
					rng.setEnd(end, end.data.length);
					editor.selection.setRng(rng);
				}
			}

			editor.on('KeyDown', function() {
				fixSelection();
			});

			editor.on('MouseDown', function(e) {
				if (e.button != 2) {
					fixSelection();
				}
			});
		}

		/**
		 * Delete table if all cells are selected.
		 */
		function deleteTable() {
			function placeCaretInCell(cell) {
				editor.selection.select(cell, true);
				editor.selection.collapse(true);
			}

			function clearCell(cell) {
				editor.$(cell).empty();
				Utils.paddCell(cell);
			}

			editor.on('keydown', function(e) {
				if ((e.keyCode == VK.DELETE || e.keyCode == VK.BACKSPACE) && !e.isDefaultPrevented()) {
					var table, tableCells, selectedTableCells, cell;

					table = editor.dom.getParent(editor.selection.getStart(), 'table');
					if (table) {
						tableCells = editor.dom.select('td,th', table);
						selectedTableCells = Tools.grep(tableCells, function(cell) {
							return !!editor.dom.getAttrib(cell, 'data-mce-selected');
						});

						if (selectedTableCells.length === 0) {
							// If caret is within an empty table cell then empty it for real
							cell = editor.dom.getParent(editor.selection.getStart(), 'td,th');
							if (editor.selection.isCollapsed() && cell && editor.dom.isEmpty(cell)) {
								e.preventDefault();
								clearCell(cell);
								placeCaretInCell(cell);
							}

							return;
						}

						e.preventDefault();

						editor.undoManager.transact(function() {
							if (tableCells.length == selectedTableCells.length) {
								editor.execCommand('mceTableDelete');
							} else {
								Tools.each(selectedTableCells, clearCell);
								placeCaretInCell(selectedTableCells[0]);
							}
						});
					}
				}
			});
		}

		/**
		 * When caption is empty and we continue to delete, caption gets deleted along with the contents.
		 * So, we take over delete operation (both forward and backward) and once caption is empty, we do
		 * prevent it from disappearing.
		 */
		function handleDeleteInCaption() {
			var isTableCaptionNode = function(node) {
				return node && node.nodeName == 'CAPTION' && node.parentNode.nodeName == 'TABLE';
			};

			var restoreCaretPlaceholder = function(node, insertCaret) {
				var rng = editor.selection.getRng();
				var caretNode = node.ownerDocument.createTextNode('\u00a0');

				// we could always append it, but caretNode somehow gets appended before caret,
				// rather then after it, effectively preventing backspace deletion
				if (rng.startOffset) {
					node.insertBefore(caretNode, node.firstChild);
				} else {
					node.appendChild(caretNode);
				}

				if (insertCaret) {
					// put the caret into the placeholder
					editor.selection.select(caretNode, true);
					editor.selection.collapse(true);
				}
			};

			var deleteBtnPressed = function(e) {
				return (e.keyCode == VK.DELETE || e.keyCode == VK.BACKSPACE) && !e.isDefaultPrevented();
			};

			var getSingleChildNode = function(node) {
				return node.firstChild === node.lastChild && node.firstChild;
			};

			var isTextNode = function(node) {
				return node && node.nodeType === 3;
			};

			var getSingleChr = function(node) {
				var childNode = getSingleChildNode(node);
				return isTextNode(childNode) && childNode.data.length === 1 ? childNode.data : null;
			};

			var hasNoCaretPlaceholder = function(node) {
				var childNode = getSingleChildNode(node);
				var chr = getSingleChr(node);
				return childNode && !isTextNode(childNode) || chr && !isNBSP(chr);
			};

			var isEmptyNode = function(node) {
				return editor.dom.isEmpty(node) || isNBSP(getSingleChr(node));
			};

			var isNBSP = function(chr) {
				return chr === '\u00a0';
			};

			editor.on('keydown', function(e) {
				if (!deleteBtnPressed(e)) {
					return;
				}

				var container = editor.dom.getParent(editor.selection.getStart(), 'caption');
				if (!isTableCaptionNode(container)) {
					return;
				}

				// in IE caption collapses if caret placeholder is deleted (and it is very much possible)
				if (Env.ie) {
					if (!editor.selection.isCollapsed()) {
						// if the whole contents are selected, caret placeholder will be deleted too
						// and we take over delete operation here to restore it if this happens
						editor.undoManager.transact(function () {
							editor.execCommand('Delete');

							if (isEmptyNode(container)) {
								// caret springs off from the caption (to the first td), we need to bring it back as well
								restoreCaretPlaceholder(container, true);
							}
						});

						e.preventDefault();
					} else if (hasNoCaretPlaceholder(container)) {
						// if caret placeholder got accidentally deleted and caption will collapse
						// after this operation, we need to put placeholder back
						restoreCaretPlaceholder(container);
					}
				}

				// TODO:
				// 1. in Chrome it is easily possible to select beyond the boundaries of the caption,
				// currently this results in removal of the contents with the whole caption as well;
				// 2. we could take over delete operation to address this, but then we will need to adjust
				// the selection, otherwise delete operation will remove first row of the table too;
				// 3. current behaviour is logical, so it has sense to leave it like that, until a better
				// solution

				if (isEmptyNode(container)) {
					e.preventDefault();
				}
			});
		}


		deleteTable();
		handleDeleteInCaption();

		if (Env.webkit) {
			moveWebKitSelection();
			fixTableCellSelection();
		}

		if (Env.gecko) {
			fixBeforeTableCaretBug();
			fixTableCaretPos();
		}

		if (Env.ie > 9) {
			fixBeforeTableCaretBug();
			fixTableCaretPos();
		}
	};
});

// Included from: js/tinymce/plugins/table/classes/CellSelection.js

/**
 * CellSelection.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * This class handles table cell selection by faking it using a css class that gets applied
 * to cells when dragging the mouse from one cell to another.
 *
 * @class tinymce.tableplugin.CellSelection
 * @private
 */
define("tinymce/tableplugin/CellSelection", [
	"tinymce/tableplugin/TableGrid",
	"tinymce/dom/TreeWalker",
	"tinymce/util/Tools"
], function(TableGrid, TreeWalker, Tools) {
	return function(editor, selectionChange) {
		var dom = editor.dom, tableGrid, startCell, startTable, lastMouseOverTarget, hasCellSelection = true, resizing, dragging;

		function clear(force) {
			// Restore selection possibilities
			editor.getBody().style.webkitUserSelect = '';

			if (force || hasCellSelection) {
				editor.$('td[data-mce-selected],th[data-mce-selected]').removeAttr('data-mce-selected');
				hasCellSelection = false;
			}
		}

		var endSelection = function () {
			startCell = tableGrid = startTable = lastMouseOverTarget = null;
			selectionChange(false);
		};

		function isCellInTable(table, cell) {
			if (!table || !cell) {
				return false;
			}

			return table === dom.getParent(cell, 'table');
		}

		function cellSelectionHandler(e) {
			var sel, target = e.target, currentCell;

			if (resizing || dragging) {
				return;
			}

			// Fake mouse enter by keeping track of last mouse over
			if (target === lastMouseOverTarget) {
				return;
			}

			lastMouseOverTarget = target;

			if (startTable && startCell) {
				currentCell = dom.getParent(target, 'td,th');

				if (!isCellInTable(startTable, currentCell)) {
					currentCell = dom.getParent(startTable, 'td,th');
				}

				// Selection inside first cell is normal until we have expanted
				if (startCell === currentCell && !hasCellSelection) {
					return;
				}

				selectionChange(true);

				if (isCellInTable(startTable, currentCell)) {
					e.preventDefault();

					if (!tableGrid) {
						tableGrid = new TableGrid(editor, startTable, startCell);
						editor.getBody().style.webkitUserSelect = 'none';
					}

					tableGrid.setEndCell(currentCell);
					hasCellSelection = true;

					// Remove current selection
					sel = editor.selection.getSel();

					try {
						if (sel.removeAllRanges) {
							sel.removeAllRanges();
						} else {
							sel.empty();
						}
					} catch (ex) {
						// IE9 might throw errors here
					}
				}
			}
		}

		editor.on('SelectionChange', function(e) {
			if (hasCellSelection) {
				e.stopImmediatePropagation();
			}
		}, true);

		// Add cell selection logic
		editor.on('MouseDown', function(e) {
			if (e.button != 2 && !resizing && !dragging) {
				clear();

				startCell = dom.getParent(e.target, 'td,th');
				startTable = dom.getParent(startCell, 'table');
			}
		});

		editor.on('mouseover', cellSelectionHandler);

		editor.on('remove', function() {
			dom.unbind(editor.getDoc(), 'mouseover', cellSelectionHandler);
			clear();
		});

		editor.on('MouseUp', function() {
			var rng, sel = editor.selection, selectedCells, walker, node, lastNode;

			function setPoint(node, start) {
				var walker = new TreeWalker(node, node);

				do {
					// Text node
					if (node.nodeType == 3 && Tools.trim(node.nodeValue).length !== 0) {
						if (start) {
							rng.setStart(node, 0);
						} else {
							rng.setEnd(node, node.nodeValue.length);
						}

						return;
					}

					// BR element
					if (node.nodeName == 'BR') {
						if (start) {
							rng.setStartBefore(node);
						} else {
							rng.setEndBefore(node);
						}

						return;
					}
				} while ((node = (start ? walker.next() : walker.prev())));
			}

			// Move selection to startCell
			if (startCell) {
				if (tableGrid) {
					editor.getBody().style.webkitUserSelect = '';
				}

				// Try to expand text selection as much as we can only Gecko supports cell selection
				selectedCells = dom.select('td[data-mce-selected],th[data-mce-selected]');
				if (selectedCells.length > 0) {
					rng = dom.createRng();
					node = selectedCells[0];
					rng.setStartBefore(node);
					rng.setEndAfter(node);

					setPoint(node, 1);
					walker = new TreeWalker(node, dom.getParent(selectedCells[0], 'table'));

					do {
						if (node.nodeName == 'TD' || node.nodeName == 'TH') {
							if (!dom.getAttrib(node, 'data-mce-selected')) {
								break;
							}

							lastNode = node;
						}
					} while ((node = walker.next()));

					setPoint(lastNode);

					sel.setRng(rng);
				}

				editor.nodeChanged();
				endSelection();
			}
		});

		editor.on('KeyUp Drop SetContent', function(e) {
			clear(e.type == 'setcontent');
			endSelection();
			resizing = false;
		});

		editor.on('ObjectResizeStart ObjectResized', function(e) {
			resizing = e.type != 'objectresized';
		});

		editor.on('dragstart', function () {
			dragging = true;
		});

		editor.on('drop dragend', function () {
			dragging = false;
		});

		return {
			clear: clear
		};
	};
});

// Included from: js/tinymce/plugins/table/classes/Dialogs.js

/**
 * Dialogs.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*eslint dot-notation:0*/

/**
 * ...
 *
 * @class tinymce.tableplugin.Dialogs
 * @private
 */
define("tinymce/tableplugin/Dialogs", [
	"tinymce/util/Tools",
	"tinymce/Env"
], function(Tools, Env) {
	var each = Tools.each;

	return function(editor) {
		var self = this;

		function createColorPickAction() {
			var colorPickerCallback = editor.settings.color_picker_callback;

			if (colorPickerCallback) {
				return function() {
					var self = this;

					colorPickerCallback.call(
						editor,
						function(value) {
							self.value(value).fire('change');
						},
						self.value()
					);
				};
			}
		}

		function createStyleForm(dom) {
			return {
				title: 'Advanced',
				type: 'form',
				defaults: {
					onchange: function() {
						updateStyle(dom, this.parents().reverse()[0], this.name() == "style");
					}
				},
				items: [
					{
						label: 'Style',
						name: 'style',
						type: 'textbox'
					},

					{
						type: 'form',
						padding: 0,
						formItemDefaults: {
							layout: 'grid',
							alignH: ['start', 'right']
						},
						defaults: {
							size: 7
						},
						items: [
							{
								label: 'Border color',
								type: 'colorbox',
								name: 'borderColor',
								onaction: createColorPickAction()
							},

							{
								label: 'Background color',
								type: 'colorbox',
								name: 'backgroundColor',
								onaction: createColorPickAction()
							}
						]
					}
				]
			};
		}

		function removePxSuffix(size) {
			return size ? size.replace(/px$/, '') : "";
		}

		function addSizeSuffix(size) {
			if (/^[0-9]+$/.test(size)) {
				size += "px";
			}

			return size;
		}

		function unApplyAlign(elm) {
			each('left center right'.split(' '), function(name) {
				editor.formatter.remove('align' + name, {}, elm);
			});
		}

		function unApplyVAlign(elm) {
			each('top middle bottom'.split(' '), function(name) {
				editor.formatter.remove('valign' + name, {}, elm);
			});
		}

		function buildListItems(inputList, itemCallback, startItems) {
			function appendItems(values, output) {
				output = output || [];

				Tools.each(values, function(item) {
					var menuItem = {text: item.text || item.title};

					if (item.menu) {
						menuItem.menu = appendItems(item.menu);
					} else {
						menuItem.value = item.value;

						if (itemCallback) {
							itemCallback(menuItem);
						}
					}

					output.push(menuItem);
				});

				return output;
			}

			return appendItems(inputList, startItems || []);
		}

		function updateStyle(dom, win, isStyleCtrl) {
			var data = win.toJSON();
			var css = dom.parseStyle(data.style);

			if (isStyleCtrl) {
				win.find('#borderColor').value(css["border-color"] || '')[0].fire('change');
				win.find('#backgroundColor').value(css["background-color"] || '')[0].fire('change');
			} else {
				css["border-color"] = data.borderColor;
				css["background-color"] = data.backgroundColor;
			}

			win.find('#style').value(dom.serializeStyle(dom.parseStyle(dom.serializeStyle(css))));
		}

		function appendStylesToData(dom, data, elm) {
			var css = dom.parseStyle(dom.getAttrib(elm, 'style'));

			if (css["border-color"]) {
				data.borderColor = css["border-color"];
			}

			if (css["background-color"]) {
				data.backgroundColor = css["background-color"];
			}

			data.style = dom.serializeStyle(css);
		}

		function mergeStyles(dom, elm, styles) {
			var css = dom.parseStyle(dom.getAttrib(elm, 'style'));

			each(styles, function(style) {
				css[style.name] = style.value;
			});

			dom.setAttrib(elm, 'style', dom.serializeStyle(dom.parseStyle(dom.serializeStyle(css))));
		}

		self.tableProps = function() {
			self.table(true);
		};

		self.table = function(isProps) {
			var dom = editor.dom, tableElm, colsCtrl, rowsCtrl, classListCtrl, data = {}, generalTableForm, stylesToMerge;

			function onSubmitTableForm() {

				//Explore the layers of the table till we find the first layer of tds or ths
				function styleTDTH(elm, name, value) {
					if (elm.tagName === "TD" || elm.tagName === "TH") {
						dom.setStyle(elm, name, value);
					} else {
						if (elm.children) {
							for (var i = 0; i < elm.children.length; i++) {
								styleTDTH(elm.children[i], name, value);
							}
						}
					}
				}

				var captionElm;

				updateStyle(dom, this);
				data = Tools.extend(data, this.toJSON());

				if (data["class"] === false) {
					delete data["class"];
				}

				editor.undoManager.transact(function() {
					if (!tableElm) {
						tableElm = editor.plugins.table.insertTable(data.cols || 1, data.rows || 1);
					}

					editor.dom.setAttribs(tableElm, {
						style: data.style,
						'class': data['class']
					});

					if (editor.settings.table_style_by_css) {
						stylesToMerge = [];
						stylesToMerge.push({name: 'border', value: data.border});
						stylesToMerge.push({name: 'border-spacing', value: addSizeSuffix(data.cellspacing)});
						mergeStyles(dom, tableElm, stylesToMerge);
						dom.setAttribs(tableElm, {
							'data-mce-border-color': data.borderColor,
							'data-mce-cell-padding': data.cellpadding,
							'data-mce-border': data.border
						});
						if (tableElm.children) {
							for (var i = 0; i < tableElm.children.length; i++) {
								styleTDTH(tableElm.children[i], 'border', data.border);
								styleTDTH(tableElm.children[i], 'padding', addSizeSuffix(data.cellpadding));
							}
						}
					} else {
						editor.dom.setAttribs(tableElm, {
							border: data.border,
							cellpadding: data.cellpadding,
							cellspacing: data.cellspacing
						});
					}

					if (dom.getAttrib(tableElm, 'width') && !editor.settings.table_style_by_css) {
						dom.setAttrib(tableElm, 'width', removePxSuffix(data.width));
					} else {
						dom.setStyle(tableElm, 'width', addSizeSuffix(data.width));
					}

					dom.setStyle(tableElm, 'height', addSizeSuffix(data.height));

					// Toggle caption on/off
					captionElm = dom.select('caption', tableElm)[0];

					if (captionElm && !data.caption) {
						dom.remove(captionElm);
					}

					if (!captionElm && data.caption) {
						captionElm = dom.create('caption');
						captionElm.innerHTML = !Env.ie ? '<br data-mce-bogus="1"/>' : '\u00a0';
						tableElm.insertBefore(captionElm, tableElm.firstChild);
					}
					unApplyAlign(tableElm);
					if (data.align) {
						editor.formatter.apply('align' + data.align, {}, tableElm);
					}

					editor.focus();
					editor.addVisual();
				});
			}

			function getTDTHOverallStyle(elm, name) {
				var cells = editor.dom.select("td,th", elm), firstChildStyle;

				function checkChildren(firstChildStyle, elms) {

					for (var i = 0; i < elms.length; i++) {
						var currentStyle = dom.getStyle(elms[i], name);
						if (typeof firstChildStyle === "undefined") {
							firstChildStyle = currentStyle;
						}
						if (firstChildStyle != currentStyle) {
							return "";
						}
					}

					return firstChildStyle;

				}

				firstChildStyle = checkChildren(firstChildStyle, cells);

				return firstChildStyle;
			}

			if (isProps === true) {
				tableElm = dom.getParent(editor.selection.getStart(), 'table');

				if (tableElm) {
					data = {
						width: removePxSuffix(dom.getStyle(tableElm, 'width') || dom.getAttrib(tableElm, 'width')),
						height: removePxSuffix(dom.getStyle(tableElm, 'height') || dom.getAttrib(tableElm, 'height')),
						cellspacing: removePxSuffix(dom.getStyle(tableElm, 'border-spacing') ||
							dom.getAttrib(tableElm, 'cellspacing')),
						cellpadding: dom.getAttrib(tableElm, 'data-mce-cell-padding') || dom.getAttrib(tableElm, 'cellpadding') ||
							getTDTHOverallStyle(tableElm, 'padding'),
						border: dom.getAttrib(tableElm, 'data-mce-border') || dom.getAttrib(tableElm, 'border') ||
							getTDTHOverallStyle(tableElm, 'border'),
						borderColor: dom.getAttrib(tableElm, 'data-mce-border-color'),
						caption: !!dom.select('caption', tableElm)[0],
						'class': dom.getAttrib(tableElm, 'class')
					};

					each('left center right'.split(' '), function(name) {
						if (editor.formatter.matchNode(tableElm, 'align' + name)) {
							data.align = name;
						}
					});
				}
			} else {
				colsCtrl = {label: 'Cols', name: 'cols'};
				rowsCtrl = {label: 'Rows', name: 'rows'};
			}

			if (editor.settings.table_class_list) {
				if (data["class"]) {
					data["class"] = data["class"].replace(/\s*mce\-item\-table\s*/g, '');
				}

				classListCtrl = {
					name: 'class',
					type: 'listbox',
					label: 'Class',
					values: buildListItems(
						editor.settings.table_class_list,
						function(item) {
							if (item.value) {
								item.textStyle = function() {
									return editor.formatter.getCssText({block: 'table', classes: [item.value]});
								};
							}
						}
					)
				};
			}

			generalTableForm = {
				type: 'form',
				layout: 'flex',
				direction: 'column',
				labelGapCalc: 'children',
				padding: 0,
				items: [
					{
						type: 'form',
						labelGapCalc: false,
						padding: 0,
						layout: 'grid',
						columns: 2,
						defaults: {
							type: 'textbox',
							maxWidth: 50
						},
						items: (editor.settings.table_appearance_options !== false) ? [
							colsCtrl,
							rowsCtrl,
							{label: 'Width', name: 'width'},
							{label: 'Height', name: 'height'},
							{label: 'Cell spacing', name: 'cellspacing'},
							{label: 'Cell padding', name: 'cellpadding'},
							{label: 'Border', name: 'border'},
							{label: 'Caption', name: 'caption', type: 'checkbox'}
						] : [
							colsCtrl,
							rowsCtrl,
							{label: 'Width', name: 'width'},
							{label: 'Height', name: 'height'}
						]
					},

					{
						label: 'Alignment',
						name: 'align',
						type: 'listbox',
						text: 'None',
						values: [
							{text: 'None', value: ''},
							{text: 'Left', value: 'left'},
							{text: 'Center', value: 'center'},
							{text: 'Right', value: 'right'}
						]
					},

					classListCtrl
				]
			};

			if (editor.settings.table_advtab !== false) {
				appendStylesToData(dom, data, tableElm);

				editor.windowManager.open({
					title: "Table properties",
					data: data,
					bodyType: 'tabpanel',
					body: [
						{
							title: 'General',
							type: 'form',
							items: generalTableForm
						},
						createStyleForm(dom)
					],

					onsubmit: onSubmitTableForm
				});
			} else {
				editor.windowManager.open({
					title: "Table properties",
					data: data,
					body: generalTableForm,
					onsubmit: onSubmitTableForm
				});
			}
		};

		self.merge = function(grid, cell) {
			editor.windowManager.open({
				title: "Merge cells",
				body: [
					{label: 'Cols', name: 'cols', type: 'textbox', value: '1', size: 10},
					{label: 'Rows', name: 'rows', type: 'textbox', value: '1', size: 10}
				],
				onsubmit: function() {
					var data = this.toJSON();

					editor.undoManager.transact(function() {
						grid.merge(cell, data.cols, data.rows);
					});
				}
			});
		};

		self.cell = function() {
			var dom = editor.dom, cellElm, data, classListCtrl, cells = [];

			function setAttrib(elm, name, value) {
				if (cells.length === 1 || value) {
					dom.setAttrib(elm, name, value);
				}
			}

			function setStyle(elm, name, value) {
				if (cells.length === 1 || value) {
					dom.setStyle(elm, name, value);
				}
			}

			function onSubmitCellForm() {
				updateStyle(dom, this);
				data = Tools.extend(data, this.toJSON());

				editor.undoManager.transact(function() {
					each(cells, function(cellElm) {
						setAttrib(cellElm, 'scope', data.scope);
						setAttrib(cellElm, 'style', data.style);
						setAttrib(cellElm, 'class', data['class']);
						setStyle(cellElm, 'width', addSizeSuffix(data.width));
						setStyle(cellElm, 'height', addSizeSuffix(data.height));

						// Switch cell type
						if (data.type && cellElm.nodeName.toLowerCase() !== data.type) {
							cellElm = dom.rename(cellElm, data.type);
						}

						// Remove alignment
						if (cells.length === 1) {
							unApplyAlign(cellElm);
							unApplyVAlign(cellElm);
						}

						// Apply alignment
						if (data.align) {
							editor.formatter.apply('align' + data.align, {}, cellElm);
						}

						// Apply vertical alignment
						if (data.valign) {
							editor.formatter.apply('valign' + data.valign, {}, cellElm);
						}
					});

					editor.focus();
				});
			}

			// Get selected cells or the current cell
			cells = editor.dom.select('td[data-mce-selected],th[data-mce-selected]');
			cellElm = editor.dom.getParent(editor.selection.getStart(), 'td,th');
			if (!cells.length && cellElm) {
				cells.push(cellElm);
			}

			cellElm = cellElm || cells[0];

			if (!cellElm) {
				// If this element is null, return now to avoid crashing.
				return;
			}

			if (cells.length > 1) {
				data = {
					width: '',
					height: '',
					scope: '',
					'class': '',
					align: '',
					style: '',
					type: cellElm.nodeName.toLowerCase()
				};
			} else {
				data = {
					width: removePxSuffix(dom.getStyle(cellElm, 'width') || dom.getAttrib(cellElm, 'width')),
					height: removePxSuffix(dom.getStyle(cellElm, 'height') || dom.getAttrib(cellElm, 'height')),
					scope: dom.getAttrib(cellElm, 'scope'),
					'class': dom.getAttrib(cellElm, 'class')
				};

				data.type = cellElm.nodeName.toLowerCase();

				each('left center right'.split(' '), function(name) {
					if (editor.formatter.matchNode(cellElm, 'align' + name)) {
						data.align = name;
					}
				});

				each('top middle bottom'.split(' '), function(name) {
					if (editor.formatter.matchNode(cellElm, 'valign' + name)) {
						data.valign = name;
					}
				});

				appendStylesToData(dom, data, cellElm);
			}

			if (editor.settings.table_cell_class_list) {
				classListCtrl = {
					name: 'class',
					type: 'listbox',
					label: 'Class',
					values: buildListItems(
						editor.settings.table_cell_class_list,
						function(item) {
							if (item.value) {
								item.textStyle = function() {
									return editor.formatter.getCssText({block: 'td', classes: [item.value]});
								};
							}
						}
					)
				};
			}

			var generalCellForm = {
				type: 'form',
				layout: 'flex',
				direction: 'column',
				labelGapCalc: 'children',
				padding: 0,
				items: [
					{
						type: 'form',
						layout: 'grid',
						columns: 2,
						labelGapCalc: false,
						padding: 0,
						defaults: {
							type: 'textbox',
							maxWidth: 50
						},
						items: [
							{label: 'Width', name: 'width'},
							{label: 'Height', name: 'height'},
							{
								label: 'Cell type',
								name: 'type',
								type: 'listbox',
								text: 'None',
								minWidth: 90,
								maxWidth: null,
								values: [
									{text: 'Cell', value: 'td'},
									{text: 'Header cell', value: 'th'}
								]
							},
							{
								label: 'Scope',
								name: 'scope',
								type: 'listbox',
								text: 'None',
								minWidth: 90,
								maxWidth: null,
								values: [
									{text: 'None', value: ''},
									{text: 'Row', value: 'row'},
									{text: 'Column', value: 'col'},
									{text: 'Row group', value: 'rowgroup'},
									{text: 'Column group', value: 'colgroup'}
								]
							},
							{
								label: 'H Align',
								name: 'align',
								type: 'listbox',
								text: 'None',
								minWidth: 90,
								maxWidth: null,
								values: [
									{text: 'None', value: ''},
									{text: 'Left', value: 'left'},
									{text: 'Center', value: 'center'},
									{text: 'Right', value: 'right'}
								]
							},
							{
								label: 'V Align',
								name: 'valign',
								type: 'listbox',
								text: 'None',
								minWidth: 90,
								maxWidth: null,
								values: [
									{text: 'None', value: ''},
									{text: 'Top', value: 'top'},
									{text: 'Middle', value: 'middle'},
									{text: 'Bottom', value: 'bottom'}
								]
							}
						]
					},

					classListCtrl
				]
			};

			if (editor.settings.table_cell_advtab !== false) {
				editor.windowManager.open({
					title: "Cell properties",
					bodyType: 'tabpanel',
					data: data,
					body: [
						{
							title: 'General',
							type: 'form',
							items: generalCellForm
						},

						createStyleForm(dom)
					],

					onsubmit: onSubmitCellForm
				});
			} else {
				editor.windowManager.open({
					title: "Cell properties",
					data: data,
					body: generalCellForm,
					onsubmit: onSubmitCellForm
				});
			}
		};

		self.row = function() {
			var dom = editor.dom, tableElm, cellElm, rowElm, classListCtrl, data, rows = [], generalRowForm;

			function setAttrib(elm, name, value) {
				if (rows.length === 1 || value) {
					dom.setAttrib(elm, name, value);
				}
			}

			function setStyle(elm, name, value) {
				if (rows.length === 1 || value) {
					dom.setStyle(elm, name, value);
				}
			}

			function onSubmitRowForm() {
				var tableElm, oldParentElm, parentElm;

				updateStyle(dom, this);
				data = Tools.extend(data, this.toJSON());

				editor.undoManager.transact(function() {
					var toType = data.type;

					each(rows, function(rowElm) {
						setAttrib(rowElm, 'scope', data.scope);
						setAttrib(rowElm, 'style', data.style);
						setAttrib(rowElm, 'class', data['class']);
						setStyle(rowElm, 'height', addSizeSuffix(data.height));

						if (toType !== rowElm.parentNode.nodeName.toLowerCase()) {
							tableElm = dom.getParent(rowElm, 'table');

							oldParentElm = rowElm.parentNode;
							parentElm = dom.select(toType, tableElm)[0];
							if (!parentElm) {
								parentElm = dom.create(toType);
								if (tableElm.firstChild) {
									tableElm.insertBefore(parentElm, tableElm.firstChild);
								} else {
									tableElm.appendChild(parentElm);
								}
							}

							parentElm.appendChild(rowElm);

							if (!oldParentElm.hasChildNodes()) {
								dom.remove(oldParentElm);
							}
						}

						// Apply/remove alignment
						if (rows.length === 1) {
							unApplyAlign(rowElm);
						}

						if (data.align) {
							editor.formatter.apply('align' + data.align, {}, rowElm);
						}
					});

					editor.focus();
				});
			}

			tableElm = editor.dom.getParent(editor.selection.getStart(), 'table');
			cellElm = editor.dom.getParent(editor.selection.getStart(), 'td,th');

			each(tableElm.rows, function(row) {
				each(row.cells, function(cell) {
					if (dom.getAttrib(cell, 'data-mce-selected') || cell == cellElm) {
						rows.push(row);
						return false;
					}
				});
			});

			rowElm = rows[0];
			if (!rowElm) {
				// If this element is null, return now to avoid crashing.
				return;
			}

			if (rows.length > 1) {
				data = {
					height: '',
					scope: '',
					'class': '',
					align: '',
					type: rowElm.parentNode.nodeName.toLowerCase()
				};
			} else {
				data = {
					height: removePxSuffix(dom.getStyle(rowElm, 'height') || dom.getAttrib(rowElm, 'height')),
					scope: dom.getAttrib(rowElm, 'scope'),
					'class': dom.getAttrib(rowElm, 'class')
				};

				data.type = rowElm.parentNode.nodeName.toLowerCase();

				each('left center right'.split(' '), function(name) {
					if (editor.formatter.matchNode(rowElm, 'align' + name)) {
						data.align = name;
					}
				});

				appendStylesToData(dom, data, rowElm);
			}

			if (editor.settings.table_row_class_list) {
				classListCtrl = {
					name: 'class',
					type: 'listbox',
					label: 'Class',
					values: buildListItems(
						editor.settings.table_row_class_list,
						function(item) {
							if (item.value) {
								item.textStyle = function() {
									return editor.formatter.getCssText({block: 'tr', classes: [item.value]});
								};
							}
						}
					)
				};
			}

			generalRowForm = {
				type: 'form',
				columns: 2,
				padding: 0,
				defaults: {
					type: 'textbox'
				},
				items: [
					{
						type: 'listbox',
						name: 'type',
						label: 'Row type',
						text: 'Header',
						maxWidth: null,
						values: [
							{text: 'Header', value: 'thead'},
							{text: 'Body', value: 'tbody'},
							{text: 'Footer', value: 'tfoot'}
						]
					},
					{
						type: 'listbox',
						name: 'align',
						label: 'Alignment',
						text: 'None',
						maxWidth: null,
						values: [
							{text: 'None', value: ''},
							{text: 'Left', value: 'left'},
							{text: 'Center', value: 'center'},
							{text: 'Right', value: 'right'}
						]
					},
					{label: 'Height', name: 'height'},
					classListCtrl
				]
			};

			if (editor.settings.table_row_advtab !== false) {
				editor.windowManager.open({
					title: "Row properties",
					data: data,
					bodyType: 'tabpanel',
					body: [
						{
							title: 'General',
							type: 'form',
							items: generalRowForm
						},
						createStyleForm(dom)
					],

					onsubmit: onSubmitRowForm
				});
			} else {
				editor.windowManager.open({
					title: "Row properties",
					data: data,
					body: generalRowForm,
					onsubmit: onSubmitRowForm
				});
			}
		};
	};
});

// Included from: js/tinymce/plugins/table/classes/ResizeBars.js

/**
 * ResizeBars.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * This class handles table column and row resizing by adding divs over the columns and rows of the table.
 * These divs are then manipulated using mouse events to resize the underlying table.
 *
 * @class tinymce.tableplugin.ResizeBars
 * @private
 */
define("tinymce/tableplugin/ResizeBars", [
	"tinymce/util/Tools",
	"tinymce/util/VK"
], function(Tools, VK) {
	var hoverTable;

	return function(editor) {
		var RESIZE_BAR_CLASS = 'mce-resize-bar',
			RESIZE_BAR_ROW_CLASS = 'mce-resize-bar-row',
			RESIZE_BAR_ROW_CURSOR_STYLE = 'row-resize',
			RESIZE_BAR_ROW_DATA_ATTRIBUTE = 'data-row',
			RESIZE_BAR_ROW_DATA_INITIAL_TOP_ATTRIBUTE = 'data-initial-top',
			RESIZE_BAR_COL_CLASS = 'mce-resize-bar-col',
			RESIZE_BAR_COL_CURSOR_STYLE = 'col-resize',
			RESIZE_BAR_COL_DATA_ATTRIBUTE = 'data-col',
			RESIZE_BAR_COL_DATA_INITIAL_LEFT_ATTRIBUTE = 'data-initial-left',
			RESIZE_BAR_THICKNESS = 4,
			RESIZE_MINIMUM_WIDTH = 10,
			RESIZE_MINIMUM_HEIGHT = 10,
			RESIZE_BAR_DRAGGING_CLASS = 'mce-resize-bar-dragging';

		var percentageBasedSizeRegex = new RegExp(/(\d+(\.\d+)?%)/),
			pixelBasedSizeRegex = new RegExp(/px|em/);

		var delayDrop, dragging, blockerElement, dragBar, lastX, lastY;

		// Get the absolute position's top edge.
		function getTopEdge(index, row) {
			return {
				index: index,
				y: editor.dom.getPos(row).y
			};
		}

		// Get the absolute position's bottom edge.
		function getBottomEdge(index, row) {
			return {
				index: index,
				y: editor.dom.getPos(row).y + row.offsetHeight
			};
		}

		// Get the absolute position's left edge.
		function getLeftEdge(index, cell) {
			return {
				index: index,
				x: editor.dom.getPos(cell).x
			};
		}

		// Get the absolute position's right edge.
		function getRightEdge(index, cell) {
			return {
				index: index,
				x: editor.dom.getPos(cell).x + cell.offsetWidth
			};
		}

		function isRtl() {
			var dir = editor.getBody().dir;
			return dir === 'rtl';
		}

		function isInline() {
			return editor.inline;
		}

		function getBody() {
			return isInline ? editor.getBody().ownerDocument.body : editor.getBody();
		}

		function getInnerEdge(index, cell) {
			return isRtl() ? getRightEdge(index, cell) : getLeftEdge(index, cell);
		}

		function getOuterEdge(index, cell) {
			return isRtl() ? getLeftEdge(index, cell) : getRightEdge(index, cell);
		}

		function getPercentageWidthFallback(element, table) {
			return getComputedStyleSize(element, 'width') / getComputedStyleSize(table, 'width') * 100;
		}

		function getComputedStyleSize(element, property) {
			var widthString = editor.dom.getStyle(element, property, true);
			var width = parseInt(widthString, 10);
			return width;
		}

		function getCurrentTablePercentWidth(table) {
			var tableWidth = getComputedStyleSize(table, 'width');
			var tableParentWidth = getComputedStyleSize(table.parentElement, 'width');
			return tableWidth / tableParentWidth * 100;
		}

		function getCellPercentDelta(table, delta) {
			var tableWidth = getComputedStyleSize(table, 'width');
			return delta / tableWidth * 100;
		}

		function getTablePercentDelta(table, delta) {
			var tableParentWidth = getComputedStyleSize(table.parentElement, 'width');
			return delta / tableParentWidth * 100;
		}

		// Find the left/right (ltr/rtl) or top side locations of the cells to measure.
		// This is the location of the borders we need to draw over.
		function findPositions(getInner, getOuter, thingsToMeasure) {
			var tablePositions = [];

			// Skip the first item in the array = no left (LTR), right (RTL) or top bars
			for (var i = 1; i < thingsToMeasure.length; i++) {
				// Get the element from the details
				var item = thingsToMeasure[i].element;

				// We need to zero index this again
				tablePositions.push(getInner(i - 1, item));
			}

			var lastTableLineToMake = thingsToMeasure[thingsToMeasure.length - 1];
			tablePositions.push(getOuter(thingsToMeasure.length - 1, lastTableLineToMake.element));

			return tablePositions;
		}

		// Clear the bars.
		function clearBars() {
			var bars = editor.dom.select('.' + RESIZE_BAR_CLASS, getBody());
			Tools.each(bars, function(bar) {
				editor.dom.remove(bar);
			});
		}

		// Refresh the bars.
		function refreshBars(tableElement) {
			clearBars();
			drawBars(tableElement);
		}

		// Generates a resize bar object for the editor to add.
		function generateBar(classToAdd, cursor, left, top, height, width, indexAttr, index) {
			var bar = {
				'data-mce-bogus': 'all',
				'class': RESIZE_BAR_CLASS + ' ' + classToAdd,
				'unselectable': 'on',
				'data-mce-resize': false,
				style: 'cursor: ' + cursor + '; ' +
					'margin: 0; ' +
					'padding: 0; ' +
					'position: absolute; ' +
					'left: ' + left + 'px; ' +
					'top: ' + top + 'px; ' +
					'height: ' + height + 'px; ' +
					'width: ' + width + 'px; '
			};

			bar[indexAttr] = index;

			return bar;
		}

		// Draw the row bars over the row borders.
		function drawRows(rowPositions, tableWidth, tablePosition) {
			Tools.each(rowPositions, function(rowPosition) {
				var left = tablePosition.x,
					top = rowPosition.y - RESIZE_BAR_THICKNESS / 2,
					height = RESIZE_BAR_THICKNESS,
					width = tableWidth;

				editor.dom.add(getBody(), 'div',
					generateBar(RESIZE_BAR_ROW_CLASS, RESIZE_BAR_ROW_CURSOR_STYLE,
						left, top, height, width, RESIZE_BAR_ROW_DATA_ATTRIBUTE, rowPosition.index));
			});
		}

		// Draw the column bars over the column borders.
		function drawCols(cellPositions, tableHeight, tablePosition) {
			Tools.each(cellPositions, function(cellPosition) {
				var left = cellPosition.x - RESIZE_BAR_THICKNESS / 2,
					top = tablePosition.y,
					height = tableHeight,
					width = RESIZE_BAR_THICKNESS;

				editor.dom.add(getBody(), 'div',
					generateBar(RESIZE_BAR_COL_CLASS, RESIZE_BAR_COL_CURSOR_STYLE,
						left, top, height, width, RESIZE_BAR_COL_DATA_ATTRIBUTE, cellPosition.index));
			});
		}

		// Get a matrix of the cells in each row and the rows in the table.
		function getTableDetails(table) {
			return Tools.map(table.rows, function(row) {

				var cells = Tools.map(row.cells, function(cell) {

					var rowspan = cell.hasAttribute('rowspan') ? parseInt(cell.getAttribute('rowspan'), 10) : 1;
					var colspan = cell.hasAttribute('colspan') ? parseInt(cell.getAttribute('colspan'), 10) : 1;

					return {
						element: cell,
						rowspan: rowspan,
						colspan: colspan
					};
				});

				return {
					element: row,
					cells: cells
				};

			});

		}

		// Get a grid model of the table.
		function getTableGrid(tableDetails) {
			function key(rowIndex, colIndex) {
				return rowIndex + ',' + colIndex;
			}

			function getAt(rowIndex, colIndex) {
				return access[key(rowIndex, colIndex)];
			}

			function getAllCells() {
				var allCells = [];
				Tools.each(rows, function(row) {
					allCells = allCells.concat(row.cells);
				});
				return allCells;
			}

			function getAllRows() {
				return rows;
			}

			var access = {};
			var rows = [];

			var maxRows = 0;
			var maxCols = 0;

			Tools.each(tableDetails, function(row, rowIndex) {
				var currentRow = [];

				Tools.each(row.cells, function(cell) {

					var start = 0;

					while (access[key(rowIndex, start)] !== undefined) {
						start++;
					}

					var current = {
						element: cell.element,
						colspan: cell.colspan,
						rowspan: cell.rowspan,
						rowIndex: rowIndex,
						colIndex: start
					};

					for (var i = 0; i < cell.colspan; i++) {
						for (var j = 0; j < cell.rowspan; j++) {
							var cr = rowIndex + j;
							var cc = start + i;
							access[key(cr, cc)] = current;
							maxRows = Math.max(maxRows, cr + 1);
							maxCols = Math.max(maxCols, cc + 1);
						}
					}

					currentRow.push(current);
				});

				rows.push({
					element: row.element,
					cells: currentRow
				});
			});

			return {
				grid: {
					maxRows: maxRows,
					maxCols: maxCols
				},
				getAt: getAt,
				getAllCells: getAllCells,
				getAllRows: getAllRows
			};
		}

		function range(start, end) {
			var r = [];

			for (var i = start; i < end; i++) {
				r.push(i);
			}

			return r;
		}

		// Attempt to get a representative single block for this column.
		// If we can't find a single block, all blocks in this row/column are spanned
		// and we'll need to fallback to getting the first cell in the row/column.
		function decide(getBlock, isSingle, getFallback) {
			var inBlock = getBlock();
			var singleInBlock;

			for (var i = 0; i < inBlock.length; i++) {
				if (isSingle(inBlock[i])) {
					singleInBlock = inBlock[i];
				}
			}
			return singleInBlock ? singleInBlock : getFallback();
		}

		// Attempt to get representative blocks for the width of each column.
		function getColumnBlocks(tableGrid) {
			var cols = range(0, tableGrid.grid.maxCols);
			var rows = range(0, tableGrid.grid.maxRows);

			return Tools.map(cols, function(col) {
				function getBlock() {
					var details = [];
					for (var i = 0; i < rows.length; i++) {
						var detail = tableGrid.getAt(i, col);
						if (detail && detail.colIndex === col) {
							details.push(detail);
						}
					}

					return details;
				}

				function isSingle(detail) {
					return detail.colspan === 1;
				}

				function getFallback() {
					var item;

					for (var i = 0; i < rows.length; i++) {
						item = tableGrid.getAt(i, col);
						if (item) {
							return item;
						}
					}

					return null;
				}

				return decide(getBlock, isSingle, getFallback);
			});
		}

		// Attempt to get representative blocks for the height of each row.
		function getRowBlocks(tableGrid) {
			var cols = range(0, tableGrid.grid.maxCols);
			var rows = range(0, tableGrid.grid.maxRows);

			return Tools.map(rows, function(row) {
				function getBlock() {
					var details = [];
					for (var i = 0; i < cols.length; i++) {
						var detail = tableGrid.getAt(row, i);
						if (detail && detail.rowIndex === row) {
							details.push(detail);
						}
					}
					return details;
				}

				function isSingle(detail) {
					return detail.rowspan === 1;
				}

				function getFallback() {
					return tableGrid.getAt(row, 0);
				}

				return decide(getBlock, isSingle, getFallback);
			});
		}

		// Draw resize bars over the left/right (ltr/rtl) or top side locations of the cells to measure.
		// This is the location of the borders we need to draw over.
		function drawBars(table) {
			var tableDetails = getTableDetails(table);
			var tableGrid = getTableGrid(tableDetails);
			var rows = getRowBlocks(tableGrid);
			var cols = getColumnBlocks(tableGrid);

			var tablePosition = editor.dom.getPos(table);
			var rowPositions = rows.length > 0 ? findPositions(getTopEdge, getBottomEdge, rows) : [];
			var colPositions = cols.length > 0 ? findPositions(getInnerEdge, getOuterEdge, cols) : [];

			drawRows(rowPositions, table.offsetWidth, tablePosition);
			drawCols(colPositions, table.offsetHeight, tablePosition);
		}

		// Attempt to deduce the width/height of a column/row that has more than one cell spanned.
		function deduceSize(deducables, index, isPercentageBased, table) {
			if (index < 0 || index >= deducables.length - 1) {
				return "";
			}

			var current = deducables[index];

			if (current) {
				current = {
					value: current,
					delta: 0
				};
			} else {
				var reversedUpToIndex = deducables.slice(0, index).reverse();
				for (var i = 0; i < reversedUpToIndex.length; i++) {
					if (reversedUpToIndex[i]) {
						current = {
							value: reversedUpToIndex[i],
							delta: i + 1
						};
					}
				}
			}

			var next = deducables[index + 1];

			if (next) {
				next = {
					value: next,
					delta: 1
				};
			} else {
				var rest = deducables.slice(index + 1);
				for (var j = 0; j < rest.length; j++) {
					if (rest[j]) {
						next = {
							value: rest[j],
							delta: j + 1
						};
					}
				}
			}

			var extras = next.delta - current.delta;
			var pixelWidth = Math.abs(next.value - current.value) / extras;
			return isPercentageBased ? pixelWidth / getComputedStyleSize(table, 'width') * 100 : pixelWidth;
		}

		function getStyleOrAttrib(element, property) {
			var sizeString = editor.dom.getStyle(element, property);
			if (!sizeString) {
				sizeString = editor.dom.getAttrib(element, property);
			}
			if (!sizeString) {
				sizeString = editor.dom.getStyle(element, property, true);
			}
			return sizeString;
		}

		function getWidth(element, isPercentageBased, table) {
			var widthString = getStyleOrAttrib(element, 'width');

			var widthNumber = parseInt(widthString, 10);

			var getWidthFallback = isPercentageBased ? getPercentageWidthFallback(element, table) : getComputedStyleSize(element, 'width');

			// If this is percentage based table, but this cell isn't percentage based.
			// Or if this is a pixel based table, but this cell isn't pixel based.
			if (isPercentageBased && !isPercentageBasedSize(widthString) ||
			!isPercentageBased && !isPixelBasedSize(widthString)) {
				// set the widthnumber to 0
				widthNumber = 0;
			}

			return !isNaN(widthNumber) && widthNumber > 0 ?
				widthNumber : getWidthFallback;
		}

		// Attempt to get the css width from column representative cells.
		function getWidths(tableGrid, isPercentageBased, table) {

			var cols = getColumnBlocks(tableGrid);

			var backups = Tools.map(cols, function(col) {
				return getInnerEdge(col.colIndex, col.element).x;
			});

			var widths = [];

			for (var i = 0; i < cols.length; i++) {
				var span = cols[i].element.hasAttribute('colspan') ? parseInt(cols[i].element.getAttribute('colspan'), 10) : 1;
				// Deduce if the column has colspan of more than 1
				var width = span > 1 ? deduceSize(backups, i) : getWidth(cols[i].element, isPercentageBased, table);
				// If everything's failed and we still don't have a width
				width = width ? width : RESIZE_MINIMUM_WIDTH;
				widths.push(width);
			}

			return widths;
		}

		// Attempt to get the pixel height from a cell.
		function getPixelHeight(element) {

			var heightString = getStyleOrAttrib(element, 'height');

			var heightNumber = parseInt(heightString, 10);

			if (isPercentageBasedSize(heightString)) {
				heightNumber = 0;
			}

			return !isNaN(heightNumber) && heightNumber > 0 ?
							heightNumber : getComputedStyleSize(element, 'height');
		}

		// Attempt to get the css height from row representative cells.
		function getPixelHeights(tableGrid) {

			var rows = getRowBlocks(tableGrid);

			var backups = Tools.map(rows, function(row) {
				return getTopEdge(row.rowIndex, row.element).y;
			});

			var heights = [];

			for (var i = 0; i < rows.length; i++) {
				var span = rows[i].element.hasAttribute('rowspan') ? parseInt(rows[i].element.getAttribute('rowspan'), 10) : 1;

				var height = span > 1 ? deduceSize(backups, i) : getPixelHeight(rows[i].element);

				height = height ? height : RESIZE_MINIMUM_HEIGHT;
				heights.push(height);
			}

			return heights;
		}

		// Determine how much each column's css width will need to change.
		// Sizes = result = pixels widths OR percentage based widths
		function determineDeltas(sizes, column, step, min, isPercentageBased) {

			var result = sizes.slice(0);

			function generateZeros(array) {
				return Tools.map(array, function() {
					return 0;
				});
			}

			function onOneColumn() {
				var deltas;
				if (isPercentageBased) {
					// If we have one column in a percent based table, that column should be 100% of the width of the table.
					deltas = [100 - result[0]];
				} else {
					var newNext = Math.max(min, result[0] + step);
					deltas = [newNext - result[0]];
				}
				return deltas;
			}

			function onLeftOrMiddle(index, next) {

				var startZeros = generateZeros(result.slice(0, index));
				var endZeros = generateZeros(result.slice(next + 1));
				var deltas;

				if (step >= 0) {
					var newNext = Math.max(min, result[next] - step);
					deltas = startZeros.concat([step, newNext - result[next]]).concat(endZeros);
				} else {
					var newThis = Math.max(min, result[index] + step);
					var diffx = result[index] - newThis;
					deltas = startZeros.concat([newThis - result[index], diffx]).concat(endZeros);
				}

				return deltas;
			}

			function onRight(previous, index) {
				var startZeros = generateZeros(result.slice(0, index));
				var deltas;

				if (step >= 0) {
					deltas = startZeros.concat([step]);
				} else {
					var size = Math.max(min, result[index] + step);
					deltas = startZeros.concat([size - result[index]]);
				}

				return deltas;

			}

			var deltas;

			if (sizes.length === 0) { // No Columns
				deltas = [];
			} else if (sizes.length === 1) { // One Column
				deltas = onOneColumn();
			} else if (column === 0) { // Left Column
				deltas = onLeftOrMiddle(0, 1);
			} else if (column > 0 && column < sizes.length - 1) { // Middle Column
				deltas = onLeftOrMiddle(column, column + 1);
			} else if (column === sizes.length - 1) { // Right Column
				deltas = onRight(column - 1, column);
			} else {
				deltas = [];
			}

			return deltas;
		}

		function total(start, end, measures) {
			var r = 0;
			for (var i = start; i < end; i++) {
				r += measures[i];
			}
			return r;
		}

		// Combine cell's css widths to determine widths of colspan'd cells.
		function recalculateWidths(tableGrid, widths) {
			var allCells = tableGrid.getAllCells();
			return Tools.map(allCells, function(cell) {
				var width = total(cell.colIndex, cell.colIndex + cell.colspan, widths);
				return {
					element: cell.element,
					width: width,
					colspan: cell.colspan
				};
			});
		}

		// Combine cell's css heights to determine heights of rowspan'd cells.
		function recalculateCellHeights(tableGrid, heights) {
			var allCells = tableGrid.getAllCells();
			return Tools.map(allCells, function(cell) {
				var height = total(cell.rowIndex, cell.rowIndex + cell.rowspan, heights);
				return {
					element: cell.element,
					height: height,
					rowspan: cell.rowspan
				};
			});
		}

		// Calculate row heights.
		function recalculateRowHeights(tableGrid, heights) {
			var allRows = tableGrid.getAllRows();
			return Tools.map(allRows, function(row, i) {
				return {
					element: row.element,
					height: heights[i]
				};
			});
		}

		function isPercentageBasedSize(size) {
			return percentageBasedSizeRegex.test(size);
		}

		function isPixelBasedSize(size) {
			return pixelBasedSizeRegex.test(size);
		}

		// Adjust the width of the column of table at index, with delta.
		function adjustWidth(table, delta, index) {
			var tableDetails = getTableDetails(table);
			var tableGrid = getTableGrid(tableDetails);

			function setSizes(newSizes, styleExtension) {
				Tools.each(newSizes, function(cell) {
					editor.dom.setStyle(cell.element, 'width', cell.width + styleExtension);
					editor.dom.setAttrib(cell.element, 'width', null);
				});
			}

			function getNewTablePercentWidth() {
				return index < tableGrid.grid.maxCols - 1 ? getCurrentTablePercentWidth(table) :
					getCurrentTablePercentWidth(table) + getTablePercentDelta(table, delta);
			}

			function getNewTablePixelWidth() {
				return index < tableGrid.grid.maxCols - 1 ? getComputedStyleSize(table, 'width') :
					getComputedStyleSize(table, 'width') + delta;
			}

			function setTableSize(newTableWidth, styleExtension, isPercentBased) {
				if (index == tableGrid.grid.maxCols - 1 || !isPercentBased) {
					editor.dom.setStyle(table, 'width', newTableWidth + styleExtension);
					editor.dom.setAttrib(table, 'width', null);
				}
			}

			var percentageBased = isPercentageBasedSize(table.width) ||
				isPercentageBasedSize(table.style.width);

			var widths = getWidths(tableGrid, percentageBased, table);

			var step = percentageBased ? getCellPercentDelta(table, delta) : delta;
			// TODO: change the min for percentage maybe?
			var deltas = determineDeltas(widths, index, step, RESIZE_MINIMUM_WIDTH, percentageBased, table);
			var newWidths = [];

			for (var i = 0; i < deltas.length; i++) {
				newWidths.push(deltas[i] + widths[i]);
			}

			var newSizes = recalculateWidths(tableGrid, newWidths);
			var styleExtension = percentageBased ? '%' : 'px';
			var newTableWidth = percentageBased ? getNewTablePercentWidth() :
				getNewTablePixelWidth();

			editor.undoManager.transact(function() {
				setSizes(newSizes, styleExtension);
				setTableSize(newTableWidth, styleExtension, percentageBased);
			});
		}

		// Adjust the height of the row of table at index, with delta.
		function adjustHeight(table, delta, index) {
			var tableDetails = getTableDetails(table);
			var tableGrid = getTableGrid(tableDetails);

			var heights = getPixelHeights(tableGrid);

			var newHeights = [], newTotalHeight = 0;

			for (var i = 0; i < heights.length; i++) {
				newHeights.push(i === index ? delta + heights[i] : heights[i]);
				newTotalHeight += newTotalHeight[i];
			}

			var newCellSizes = recalculateCellHeights(tableGrid, newHeights);
			var newRowSizes = recalculateRowHeights(tableGrid, newHeights);

			editor.undoManager.transact(function() {

				Tools.each(newRowSizes, function(row) {
					editor.dom.setStyle(row.element, 'height', row.height + 'px');
					editor.dom.setAttrib(row.element, 'height', null);
				});

				Tools.each(newCellSizes, function(cell) {
					editor.dom.setStyle(cell.element, 'height', cell.height + 'px');
					editor.dom.setAttrib(cell.element, 'height', null);
				});

				editor.dom.setStyle(table, 'height', newTotalHeight + 'px');
				editor.dom.setAttrib(table, 'height', null);
			});
		}

		function scheduleDelayedDropEvent() {
			delayDrop = setTimeout(function() {
				drop();
			}, 200);
		}

		function cancelDelayedDropEvent() {
			clearTimeout(delayDrop);
		}

		function getBlockerElement() {
			var blocker = document.createElement('div');

			blocker.setAttribute('style', 'margin: 0; ' +
						'padding: 0; ' +
						'position: fixed; ' +
						'left: 0px; ' +
						'top: 0px; ' +
						'height: 100%; ' +
						'width: 100%;');
			blocker.setAttribute('data-mce-bogus', 'all');

			return blocker;
		}

		function bindBlockerEvents(blocker, dragHandler) {
			editor.dom.bind(blocker, 'mouseup', function() {
				drop();
			});

			editor.dom.bind(blocker, 'mousemove', function(e) {
				cancelDelayedDropEvent();

				if (dragging) {
					dragHandler(e);
				}
			});

			editor.dom.bind(blocker, 'mouseout', function() {
				scheduleDelayedDropEvent();
			});

		}

		function drop() {
			editor.dom.remove(blockerElement);

			if (dragging) {
				editor.dom.removeClass(dragBar, RESIZE_BAR_DRAGGING_CLASS);
				dragging = false;

				var index, delta;

				if (isCol(dragBar)) {
					var initialLeft = parseInt(editor.dom.getAttrib(dragBar, RESIZE_BAR_COL_DATA_INITIAL_LEFT_ATTRIBUTE), 10);
					var newLeft = editor.dom.getPos(dragBar).x;
					index = parseInt(editor.dom.getAttrib(dragBar, RESIZE_BAR_COL_DATA_ATTRIBUTE), 10);
					delta = isRtl() ? initialLeft - newLeft : newLeft - initialLeft;
					if (Math.abs(delta) >= 1) {			// simple click with no real resize (<1px) must not add CSS properties
						adjustWidth(hoverTable, delta, index);
					}
				} else if (isRow(dragBar)) {
					var initialTop = parseInt(editor.dom.getAttrib(dragBar, RESIZE_BAR_ROW_DATA_INITIAL_TOP_ATTRIBUTE), 10);
					var newTop = editor.dom.getPos(dragBar).y;
					index = parseInt(editor.dom.getAttrib(dragBar, RESIZE_BAR_ROW_DATA_ATTRIBUTE), 10);
					delta = newTop - initialTop;
					if (Math.abs(delta) >= 1) {			// simple click with no real resize (<1px) must not add CSS properties
						adjustHeight(hoverTable, delta, index);
					}
				}
				refreshBars(hoverTable);
				editor.nodeChanged();
			}
		}

		function setupBaseDrag(bar, dragHandler) {
			blockerElement = blockerElement ? blockerElement : getBlockerElement();
			dragging = true;
			editor.dom.addClass(bar, RESIZE_BAR_DRAGGING_CLASS);
			dragBar = bar;
			bindBlockerEvents(blockerElement, dragHandler);
			editor.dom.add(getBody(), blockerElement);
		}

		function isCol(target) {
			return editor.dom.hasClass(target, RESIZE_BAR_COL_CLASS);
		}

		function isRow(target) {
			return editor.dom.hasClass(target, RESIZE_BAR_ROW_CLASS);
		}

		function colDragHandler(event) {
			lastX = lastX !== undefined ? lastX : event.clientX; // we need a firstX
			var deltaX = event.clientX - lastX;
			lastX = event.clientX;
			var oldLeft = editor.dom.getPos(dragBar).x;
			editor.dom.setStyle(dragBar, 'left', oldLeft + deltaX + 'px');
		}

		function rowDragHandler(event) {
			lastY = lastY !== undefined ? lastY : event.clientY;
			var deltaY = event.clientY - lastY;
			lastY = event.clientY;
			var oldTop = editor.dom.getPos(dragBar).y;
			editor.dom.setStyle(dragBar, 'top', oldTop + deltaY + 'px');
		}

		function setupColDrag(bar) {
			lastX = undefined;
			setupBaseDrag(bar, colDragHandler);
		}

		function setupRowDrag(bar) {
			lastY = undefined;
			setupBaseDrag(bar, rowDragHandler);
		}

		function mouseDownHandler(e) {
			var target = e.target, body = editor.getBody();

			// Since this code is working on global events we need to work on a global hoverTable state
			// and make sure that the state is correct according to the events fired
			if (!editor.$.contains(body, hoverTable) && hoverTable !== body) {
				return;
			}

			if (isCol(target)) {
				e.preventDefault();
				var initialLeft = editor.dom.getPos(target).x;
				editor.dom.setAttrib(target, RESIZE_BAR_COL_DATA_INITIAL_LEFT_ATTRIBUTE, initialLeft);
				setupColDrag(target);
			} else if (isRow(target)) {
				e.preventDefault();
				var initialTop = editor.dom.getPos(target).y;
				editor.dom.setAttrib(target, RESIZE_BAR_ROW_DATA_INITIAL_TOP_ATTRIBUTE, initialTop);
				setupRowDrag(target);
			} else {
				clearBars();
			}
		}

		editor.on('init', function() {
			// Needs to be like this for inline mode, editor.on does not bind to elements in the document body otherwise
			editor.dom.bind(getBody(), 'mousedown', mouseDownHandler);
		});

		// If we're updating the table width via the old mechanic, we need to update the constituent cells' widths/heights too.
		editor.on('ObjectResized', function(e) {
			var table = e.target;
			if (table.nodeName === 'TABLE') {
				var newCellSizes = [];
				Tools.each(table.rows, function(row) {
					Tools.each(row.cells, function(cell) {
						var width = editor.dom.getStyle(cell, 'width', true);
						newCellSizes.push({
							cell: cell,
							width: width
						});
					});
				});
				Tools.each(newCellSizes, function(newCellSize) {
					editor.dom.setStyle(newCellSize.cell, 'width', newCellSize.width);
					editor.dom.setAttrib(newCellSize.cell, 'width', null);
				});
			}
		});

		editor.on('mouseover', function(e) {
			if (!dragging) {
				var tableElement = editor.dom.getParent(e.target, 'table');

				if (e.target.nodeName === 'TABLE' || tableElement) {
					hoverTable = tableElement;
					refreshBars(tableElement);
				}
			}
		});

		// Prevents the user from moving the caret inside the resize bars on Chrome
		// Only does it on arrow keys since clearBars might be an epxensive operation
		// since it's querying the DOM
		editor.on('keydown', function(e) {
			switch (e.keyCode) {
				case VK.LEFT:
				case VK.RIGHT:
				case VK.UP:
				case VK.DOWN:
					clearBars();
					break;
			}
		});

		editor.on('remove', function() {
			clearBars();
			editor.dom.unbind(getBody(), 'mousedown', mouseDownHandler);
		});

		return {
			adjustWidth: adjustWidth,
			adjustHeight: adjustHeight,
			clearBars: clearBars,
			drawBars: drawBars,
			determineDeltas: determineDeltas,
			getTableGrid: getTableGrid,
			getTableDetails: getTableDetails,
			getWidths: getWidths,
			getPixelHeights: getPixelHeights,
			isPercentageBasedSize: isPercentageBasedSize,
			isPixelBasedSize: isPixelBasedSize,
			recalculateWidths: recalculateWidths,
			recalculateCellHeights: recalculateCellHeights,
			recalculateRowHeights: recalculateRowHeights
		};
	};
});

// Included from: js/tinymce/plugins/table/classes/Plugin.js

/**
 * Plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/**
 * This class contains all core logic for the table plugin.
 *
 * @class tinymce.tableplugin.Plugin
 * @private
 */
define("tinymce/tableplugin/Plugin", [
	"tinymce/tableplugin/TableGrid",
	"tinymce/tableplugin/Quirks",
	"tinymce/tableplugin/CellSelection",
	"tinymce/tableplugin/Dialogs",
	"tinymce/tableplugin/ResizeBars",
	"tinymce/util/Tools",
	"tinymce/dom/TreeWalker",
	"tinymce/Env",
	"tinymce/PluginManager"
], function(TableGrid, Quirks, CellSelection, Dialogs, ResizeBars, Tools, TreeWalker, Env, PluginManager) {
	var each = Tools.each;

	function Plugin(editor) {
		var clipboardRows, self = this, dialogs = new Dialogs(editor), resizeBars;

		if (editor.settings.object_resizing && editor.settings.table_resize_bars !== false &&
			(editor.settings.object_resizing === true || editor.settings.object_resizing === 'table')) {
			resizeBars = ResizeBars(editor);
		}

		function cmd(command) {
			return function() {
				editor.execCommand(command);
			};
		}

		function insertTable(cols, rows) {
			var y, x, html, tableElm;

			html = '<table id="__mce"><tbody>';

			for (y = 0; y < rows; y++) {
				html += '<tr>';

				for (x = 0; x < cols; x++) {
					html += '<td>' + (Env.ie && Env.ie < 10 ? '&nbsp;' : '<br>') + '</td>';
				}

				html += '</tr>';
			}

			html += '</tbody></table>';

			editor.undoManager.transact(function() {
				editor.insertContent(html);

				tableElm = editor.dom.get('__mce');
				editor.dom.setAttrib(tableElm, 'id', null);

				editor.$('tr', tableElm).each(function(index, row) {
					editor.fire('newrow', {
						node: row
					});

					editor.$('th,td', row).each(function(index, cell) {
						editor.fire('newcell', {
							node: cell
						});
					});
				});

				editor.dom.setAttribs(tableElm, editor.settings.table_default_attributes || {});
				editor.dom.setStyles(tableElm, editor.settings.table_default_styles || {});
			});

			return tableElm;
		}

		function handleDisabledState(ctrl, selector, sameParts) {
			function bindStateListener() {
				var selectedElm, selectedCells, parts = {}, sum = 0, state;

				selectedCells = editor.dom.select('td[data-mce-selected],th[data-mce-selected]');
				selectedElm = selectedCells[0];
				if (!selectedElm) {
					selectedElm = editor.selection.getStart();
				}

				// Make sure that we don't have a selection inside thead and tbody at the same time
				if (sameParts && selectedCells.length > 0) {
					each(selectedCells, function(cell) {
						return parts[cell.parentNode.parentNode.nodeName] = 1;
					});

					each(parts, function(value) {
						sum += value;
					});

					state = sum !== 1;
				} else {
					state = !editor.dom.getParent(selectedElm, selector);
				}

				ctrl.disabled(state);

				editor.selection.selectorChanged(selector, function(state) {
					ctrl.disabled(!state);
				});
			}

			if (editor.initialized) {
				bindStateListener();
			} else {
				editor.on('init', bindStateListener);
			}
		}

		function postRender() {
			/*jshint validthis:true*/
			handleDisabledState(this, 'table');
		}

		function postRenderCell() {
			/*jshint validthis:true*/
			handleDisabledState(this, 'td,th');
		}

		function postRenderMergeCell() {
			/*jshint validthis:true*/
			handleDisabledState(this, 'td,th', true);
		}

		function generateTableGrid() {
			var html = '';

			html = '<table role="grid" class="mce-grid mce-grid-border" aria-readonly="true">';

			for (var y = 0; y < 10; y++) {
				html += '<tr>';

				for (var x = 0; x < 10; x++) {
					html += '<td role="gridcell" tabindex="-1"><a id="mcegrid' + (y * 10 + x) + '" href="#" ' +
						'data-mce-x="' + x + '" data-mce-y="' + y + '"></a></td>';
				}

				html += '</tr>';
			}

			html += '</table>';

			html += '<div class="mce-text-center" role="presentation">1 x 1</div>';

			return html;
		}

		function selectGrid(tx, ty, control) {
			var table = control.getEl().getElementsByTagName('table')[0];
			var x, y, focusCell, cell, active;
			var rtl = control.isRtl() || control.parent().rel == 'tl-tr';

			table.nextSibling.innerHTML = (tx + 1) + ' x ' + (ty + 1);

			if (rtl) {
				tx = 9 - tx;
			}

			for (y = 0; y < 10; y++) {
				for (x = 0; x < 10; x++) {
					cell = table.rows[y].childNodes[x].firstChild;
					active = (rtl ? x >= tx : x <= tx) && y <= ty;

					editor.dom.toggleClass(cell, 'mce-active', active);

					if (active) {
						focusCell = cell;
					}
				}
			}

			return focusCell.parentNode;
		}

		if (editor.settings.table_grid === false) {
			editor.addMenuItem('inserttable', {
				text: 'Table',
				icon: 'table',
				context: 'table',
				onclick: dialogs.table
			});
		} else {
			editor.addMenuItem('inserttable', {
				text: 'Table',
				icon: 'table',
				context: 'table',
				ariaHideMenu: true,
				onclick: function(e) {
					if (e.aria) {
						this.parent().hideAll();
						e.stopImmediatePropagation();
						dialogs.table();
					}
				},
				onshow: function() {
					selectGrid(0, 0, this.menu.items()[0]);
				},
				onhide: function() {
					var elements = this.menu.items()[0].getEl().getElementsByTagName('a');
					editor.dom.removeClass(elements, 'mce-active');
					editor.dom.addClass(elements[0], 'mce-active');
				},
				menu: [
					{
						type: 'container',
						html: generateTableGrid(),

						onPostRender: function() {
							this.lastX = this.lastY = 0;
						},

						onmousemove: function(e) {
							var target = e.target, x, y;

							if (target.tagName.toUpperCase() == 'A') {
								x = parseInt(target.getAttribute('data-mce-x'), 10);
								y = parseInt(target.getAttribute('data-mce-y'), 10);

								if (this.isRtl() || this.parent().rel == 'tl-tr') {
									x = 9 - x;
								}

								if (x !== this.lastX || y !== this.lastY) {
									selectGrid(x, y, e.control);

									this.lastX = x;
									this.lastY = y;
								}
							}
						},

						onclick: function(e) {
							var self = this;

							if (e.target.tagName.toUpperCase() == 'A') {
								e.preventDefault();
								e.stopPropagation();
								self.parent().cancel();

								editor.undoManager.transact(function() {
									insertTable(self.lastX + 1, self.lastY + 1);
								});

								editor.addVisual();
							}
						}
					}
				]
			});
		}

		editor.addMenuItem('tableprops', {
			text: 'Table properties',
			context: 'table',
			onPostRender: postRender,
			onclick: dialogs.tableProps
		});

		editor.addMenuItem('deletetable', {
			text: 'Delete table',
			context: 'table',
			onPostRender: postRender,
			cmd: 'mceTableDelete'
		});

		editor.addMenuItem('cell', {
			separator: 'before',
			text: 'Cell',
			context: 'table',
			menu: [
				{text: 'Cell properties', onclick: cmd('mceTableCellProps'), onPostRender: postRenderCell},
				{text: 'Merge cells', onclick: cmd('mceTableMergeCells'), onPostRender: postRenderMergeCell},
				{text: 'Split cell', onclick: cmd('mceTableSplitCells'), onPostRender: postRenderCell}
			]
		});

		editor.addMenuItem('row', {
			text: 'Row',
			context: 'table',
			menu: [
				{text: 'Insert row before', onclick: cmd('mceTableInsertRowBefore'), onPostRender: postRenderCell},
				{text: 'Insert row after', onclick: cmd('mceTableInsertRowAfter'), onPostRender: postRenderCell},
				{text: 'Delete row', onclick: cmd('mceTableDeleteRow'), onPostRender: postRenderCell},
				{text: 'Row properties', onclick: cmd('mceTableRowProps'), onPostRender: postRenderCell},
				{text: '-'},
				{text: 'Cut row', onclick: cmd('mceTableCutRow'), onPostRender: postRenderCell},
				{text: 'Copy row', onclick: cmd('mceTableCopyRow'), onPostRender: postRenderCell},
				{text: 'Paste row before', onclick: cmd('mceTablePasteRowBefore'), onPostRender: postRenderCell},
				{text: 'Paste row after', onclick: cmd('mceTablePasteRowAfter'), onPostRender: postRenderCell}
			]
		});

		editor.addMenuItem('column', {
			text: 'Column',
			context: 'table',
			menu: [
				{text: 'Insert column before', onclick: cmd('mceTableInsertColBefore'), onPostRender: postRenderCell},
				{text: 'Insert column after', onclick: cmd('mceTableInsertColAfter'), onPostRender: postRenderCell},
				{text: 'Delete column', onclick: cmd('mceTableDeleteCol'), onPostRender: postRenderCell}
			]
		});

		var menuItems = [];
		each("inserttable tableprops deletetable | cell row column".split(' '), function(name) {
			if (name == '|') {
				menuItems.push({text: '-'});
			} else {
				menuItems.push(editor.menuItems[name]);
			}
		});

		editor.addButton("table", {
			type: "menubutton",
			title: "Table",
			menu: menuItems
		});

		// Select whole table is a table border is clicked
		if (!Env.isIE) {
			editor.on('click', function(e) {
				e = e.target;

				if (e.nodeName === 'TABLE') {
					editor.selection.select(e);
					editor.nodeChanged();
				}
			});
		}

		self.quirks = new Quirks(editor);

		editor.on('Init', function() {
			self.cellSelection = new CellSelection(editor, function (selecting) {
				if (selecting && resizeBars) {
					resizeBars.clearBars();
				}
			});
			self.resizeBars = resizeBars;
		});

		editor.on('PreInit', function() {
			// Remove internal data attributes
			editor.serializer.addAttributeFilter(
				'data-mce-cell-padding,data-mce-border,data-mce-border-color',
				function(nodes, name) {

					var i = nodes.length;

					while (i--) {
						nodes[i].attr(name, null);
					}
				});
		});

		// Register action commands
		each({
			mceTableSplitCells: function(grid) {
				grid.split();
			},

			mceTableMergeCells: function(grid) {
				var cell;

				cell = editor.dom.getParent(editor.selection.getStart(), 'th,td');

				if (!editor.dom.select('td[data-mce-selected],th[data-mce-selected]').length) {
					dialogs.merge(grid, cell);
				} else {
					grid.merge();
				}
			},

			mceTableInsertRowBefore: function(grid) {
				grid.insertRows(true);
			},

			mceTableInsertRowAfter: function(grid) {
				grid.insertRows();
			},

			mceTableInsertColBefore: function(grid) {
				grid.insertCols(true);
			},

			mceTableInsertColAfter: function(grid) {
				grid.insertCols();
			},

			mceTableDeleteCol: function(grid) {
				grid.deleteCols();
			},

			mceTableDeleteRow: function(grid) {
				grid.deleteRows();
			},

			mceTableCutRow: function(grid) {
				clipboardRows = grid.cutRows();
			},

			mceTableCopyRow: function(grid) {
				clipboardRows = grid.copyRows();
			},

			mceTablePasteRowBefore: function(grid) {
				grid.pasteRows(clipboardRows, true);
			},

			mceTablePasteRowAfter: function(grid) {
				grid.pasteRows(clipboardRows);
			},

			mceSplitColsBefore: function(grid) {
				grid.splitCols(true);
			},

			mceSplitColsAfter: function(grid) {
				grid.splitCols(false);
			},

			mceTableDelete: function(grid) {
				if (resizeBars) {
					resizeBars.clearBars();
				}
				grid.deleteTable();
			}
		}, function(func, name) {
			editor.addCommand(name, function() {
				var grid = new TableGrid(editor);

				if (grid) {
					func(grid);
					editor.execCommand('mceRepaint');
					self.cellSelection.clear();
				}
			});
		});

		// Register dialog commands
		each({
			mceInsertTable: dialogs.table,
			mceTableProps: function() {
				dialogs.table(true);
			},
			mceTableRowProps: dialogs.row,
			mceTableCellProps: dialogs.cell
		}, function(func, name) {
			editor.addCommand(name, function(ui, val) {
				func(val);
			});
		});

		function addButtons() {
			editor.addButton('tableprops', {
				title: 'Table properties',
				onclick: dialogs.tableProps,
				icon: 'table'
			});

			editor.addButton('tabledelete', {
				title: 'Delete table',
				onclick: cmd('mceTableDelete')
			});

			editor.addButton('tablecellprops', {
				title: 'Cell properties',
				onclick: cmd('mceTableCellProps')
			});

			editor.addButton('tablemergecells', {
				title: 'Merge cells',
				onclick: cmd('mceTableMergeCells')
			});

			editor.addButton('tablesplitcells', {
				title: 'Split cell',
				onclick: cmd('mceTableSplitCells')
			});

			editor.addButton('tableinsertrowbefore', {
				title: 'Insert row before',
				onclick: cmd('mceTableInsertRowBefore')
			});

			editor.addButton('tableinsertrowafter', {
				title: 'Insert row after',
				onclick: cmd('mceTableInsertRowAfter')
			});

			editor.addButton('tabledeleterow', {
				title: 'Delete row',
				onclick: cmd('mceTableDeleteRow')
			});

			editor.addButton('tablerowprops', {
				title: 'Row properties',
				onclick: cmd('mceTableRowProps')
			});

			editor.addButton('tablecutrow', {
				title: 'Cut row',
				onclick: cmd('mceTableCutRow')
			});

			editor.addButton('tablecopyrow', {
				title: 'Copy row',
				onclick: cmd('mceTableCopyRow')
			});

			editor.addButton('tablepasterowbefore', {
				title: 'Paste row before',
				onclick: cmd('mceTablePasteRowBefore')
			});

			editor.addButton('tablepasterowafter', {
				title: 'Paste row after',
				onclick: cmd('mceTablePasteRowAfter')
			});

			editor.addButton('tableinsertcolbefore', {
				title: 'Insert column before',
				onclick: cmd('mceTableInsertColBefore')
			});

			editor.addButton('tableinsertcolafter', {
				title: 'Insert column after',
				onclick: cmd('mceTableInsertColAfter')
			});

			editor.addButton('tabledeletecol', {
				title: 'Delete column',
				onclick: cmd('mceTableDeleteCol')
			});

		}

		function isTable(table) {

			var selectorMatched = editor.dom.is(table, 'table') && editor.getBody().contains(table);

			return selectorMatched;
		}

		function addToolbars() {
			var toolbarItems = editor.settings.table_toolbar;

			if (toolbarItems === '' || toolbarItems === false) {
				return;
			}

			if (!toolbarItems) {
				toolbarItems = 'tableprops tabledelete | ' +
					'tableinsertrowbefore tableinsertrowafter tabledeleterow | ' +
					'tableinsertcolbefore tableinsertcolafter tabledeletecol';
			}

			editor.addContextToolbar(
				isTable,
				toolbarItems
			);
		}

		function getClipboardRows() {
			return clipboardRows;
		}

		function setClipboardRows(rows) {
			clipboardRows = rows;
		}

		addButtons();
		addToolbars();

		// Enable tab key cell navigation
		if (editor.settings.table_tab_navigation !== false) {
			editor.on('keydown', function(e) {
				var cellElm, grid, delta;

				if (e.keyCode == 9) {
					cellElm = editor.dom.getParent(editor.selection.getStart(), 'th,td');

					if (cellElm) {
						e.preventDefault();

						grid = new TableGrid(editor);
						delta = e.shiftKey ? -1 : 1;

						editor.undoManager.transact(function() {
							if (!grid.moveRelIdx(cellElm, delta) && delta > 0) {
								grid.insertRow();
								grid.refresh();
								grid.moveRelIdx(cellElm, delta);
							}
						});
					}
				}
			});
		}

		self.insertTable = insertTable;
		self.setClipboardRows = setClipboardRows;
		self.getClipboardRows = getClipboardRows;
	}

	PluginManager.add('table', Plugin);
});
})(window);
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('template', function(editor) {
	var each = tinymce.each;

	function createTemplateList(callback) {
		return function() {
			var templateList = editor.settings.templates;

			if (typeof templateList == "function") {
				templateList(callback);
				return;
			}

			if (typeof templateList == "string") {
				tinymce.util.XHR.send({
					url: templateList,
					success: function(text) {
						callback(tinymce.util.JSON.parse(text));
					}
				});
			} else {
				callback(templateList);
			}
		};
	}

	function showDialog(templateList) {
		var win, values = [], templateHtml;

		if (!templateList || templateList.length === 0) {
			var message = editor.translate('No templates defined.');
			editor.notificationManager.open({text: message, type: 'info'});
			return;
		}

		tinymce.each(templateList, function(template) {
			values.push({
				selected: !values.length,
				text: template.title,
				value: {
					url: template.url,
					content: template.content,
					description: template.description
				}
			});
		});

		function onSelectTemplate(e) {
			var value = e.control.value();

			function insertIframeHtml(html) {
				if (html.indexOf('<html>') == -1) {
					var contentCssLinks = '';

					tinymce.each(editor.contentCSS, function(url) {
						contentCssLinks += '<link type="text/css" rel="stylesheet" href="' + editor.documentBaseURI.toAbsolute(url) + '">';
					});

					var bodyClass = editor.settings.body_class || '';
					if (bodyClass.indexOf('=') != -1) {
						bodyClass = editor.getParam('body_class', '', 'hash');
						bodyClass = bodyClass[editor.id] || '';
					}

					html = (
						'<!DOCTYPE html>' +
						'<html>' +
							'<head>' +
								contentCssLinks +
							'</head>' +
							'<body class="' + bodyClass + '">' +
								html +
							'</body>' +
						'</html>'
					);
				}

				html = replaceTemplateValues(html, 'template_preview_replace_values');

				var doc = win.find('iframe')[0].getEl().contentWindow.document;
				doc.open();
				doc.write(html);
				doc.close();
			}

			if (value.url) {
				tinymce.util.XHR.send({
					url: value.url,
					success: function(html) {
						templateHtml = html;
						insertIframeHtml(templateHtml);
					}
				});
			} else {
				templateHtml = value.content;
				insertIframeHtml(templateHtml);
			}

			win.find('#description')[0].text(e.control.value().description);
		}

		win = editor.windowManager.open({
			title: 'Insert template',
			layout: 'flex',
			direction: 'column',
			align: 'stretch',
			padding: 15,
			spacing: 10,

			items: [
				{type: 'form', flex: 0, padding: 0, items: [
					{type: 'container', label: 'Templates', items: {
						type: 'listbox', label: 'Templates', name: 'template', values: values, onselect: onSelectTemplate
					}}
				]},
				{type: 'label', name: 'description', label: 'Description', text: '\u00a0'},
				{type: 'iframe', flex: 1, border: 1}
			],

			onsubmit: function() {
				insertTemplate(false, templateHtml);
			},

			minWidth: Math.min(tinymce.DOM.getViewPort().w, editor.getParam('template_popup_width', 600)),
			minHeight: Math.min(tinymce.DOM.getViewPort().h, editor.getParam('template_popup_height', 500))
		});

		win.find('listbox')[0].fire('select');
	}

	function getDateTime(fmt, date) {
		var daysShort = "Sun Mon Tue Wed Thu Fri Sat Sun".split(' ');
		var daysLong = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday".split(' ');
		var monthsShort = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(' ');
		var monthsLong = "January February March April May June July August September October November December".split(' ');

		function addZeros(value, len) {
			value = "" + value;

			if (value.length < len) {
				for (var i = 0; i < (len - value.length); i++) {
					value = "0" + value;
				}
			}

			return value;
		}

		date = date || new Date();

		fmt = fmt.replace("%D", "%m/%d/%Y");
		fmt = fmt.replace("%r", "%I:%M:%S %p");
		fmt = fmt.replace("%Y", "" + date.getFullYear());
		fmt = fmt.replace("%y", "" + date.getYear());
		fmt = fmt.replace("%m", addZeros(date.getMonth() + 1, 2));
		fmt = fmt.replace("%d", addZeros(date.getDate(), 2));
		fmt = fmt.replace("%H", "" + addZeros(date.getHours(), 2));
		fmt = fmt.replace("%M", "" + addZeros(date.getMinutes(), 2));
		fmt = fmt.replace("%S", "" + addZeros(date.getSeconds(), 2));
		fmt = fmt.replace("%I", "" + ((date.getHours() + 11) % 12 + 1));
		fmt = fmt.replace("%p", "" + (date.getHours() < 12 ? "AM" : "PM"));
		fmt = fmt.replace("%B", "" + editor.translate(monthsLong[date.getMonth()]));
		fmt = fmt.replace("%b", "" + editor.translate(monthsShort[date.getMonth()]));
		fmt = fmt.replace("%A", "" + editor.translate(daysLong[date.getDay()]));
		fmt = fmt.replace("%a", "" + editor.translate(daysShort[date.getDay()]));
		fmt = fmt.replace("%%", "%");

		return fmt;
	}

	function replaceVals(e) {
		var dom = editor.dom, vl = editor.getParam('template_replace_values');

		each(dom.select('*', e), function(e) {
			each(vl, function(v, k) {
				if (dom.hasClass(e, k)) {
					if (typeof vl[k] == 'function') {
						vl[k](e);
					}
				}
			});
		});
	}

	function replaceTemplateValues(html, templateValuesOptionName) {
		each(editor.getParam(templateValuesOptionName), function(v, k) {
			if (typeof v == 'function') {
				v = v(k);
			}

			html = html.replace(new RegExp('\\{\\$' + k + '\\}', 'g'), v);
		});

		return html;
	}

	function insertTemplate(ui, html) {
		var el, n, dom = editor.dom, sel = editor.selection.getContent();

		html = replaceTemplateValues(html, 'template_replace_values');
		el = dom.create('div', null, html);

		// Find template element within div
		n = dom.select('.mceTmpl', el);
		if (n && n.length > 0) {
			el = dom.create('div', null);
			el.appendChild(n[0].cloneNode(true));
		}

		function hasClass(n, c) {
			return new RegExp('\\b' + c + '\\b', 'g').test(n.className);
		}

		each(dom.select('*', el), function(n) {
			// Replace cdate
			if (hasClass(n, editor.getParam('template_cdate_classes', 'cdate').replace(/\s+/g, '|'))) {
				n.innerHTML = getDateTime(editor.getParam("template_cdate_format", editor.getLang("template.cdate_format")));
			}

			// Replace mdate
			if (hasClass(n, editor.getParam('template_mdate_classes', 'mdate').replace(/\s+/g, '|'))) {
				n.innerHTML = getDateTime(editor.getParam("template_mdate_format", editor.getLang("template.mdate_format")));
			}

			// Replace selection
			if (hasClass(n, editor.getParam('template_selected_content_classes', 'selcontent').replace(/\s+/g, '|'))) {
				n.innerHTML = sel;
			}
		});

		replaceVals(el);

		editor.execCommand('mceInsertContent', false, el.innerHTML);
		editor.addVisual();
	}

	editor.addCommand('mceInsertTemplate', insertTemplate);

	editor.addButton('template', {
		title: 'Insert template',
		onclick: createTemplateList(showDialog)
	});

	editor.addMenuItem('template', {
		text: 'Template',
		onclick: createTemplateList(showDialog),
		context: 'insert'
	});

	editor.on('PreProcess', function(o) {
		var dom = editor.dom;

		each(dom.select('div', o.node), function(e) {
			if (dom.hasClass(e, 'mceTmpl')) {
				each(dom.select('*', e), function(e) {
					if (dom.hasClass(e, editor.getParam('template_mdate_classes', 'mdate').replace(/\s+/g, '|'))) {
						e.innerHTML = getDateTime(editor.getParam("template_mdate_format", editor.getLang("template.mdate_format")));
					}
				});

				replaceVals(e);
			}
		});
	});
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */
/*eslint consistent-this:0 */

tinymce.PluginManager.add('textcolor', function(editor) {
	var cols, rows;

	rows = {
		forecolor: editor.settings.forecolor_rows || editor.settings.textcolor_rows || 5,
		backcolor: editor.settings.backcolor_rows || editor.settings.textcolor_rows || 5
	};
	cols = {
		forecolor: editor.settings.forecolor_cols || editor.settings.textcolor_cols || 8,
		backcolor: editor.settings.backcolor_cols || editor.settings.textcolor_cols || 8
	};

	function getCurrentColor(format) {
		var color;

		editor.dom.getParents(editor.selection.getStart(), function(elm) {
			var value;

			if ((value = elm.style[format == 'forecolor' ? 'color' : 'background-color'])) {
				color = value;
			}
		});

		return color;
	}

	function mapColors(type) {
		var i, colors = [], colorMap;

		colorMap = [
			"000000", "Black",
			"993300", "Burnt orange",
			"333300", "Dark olive",
			"003300", "Dark green",
			"003366", "Dark azure",
			"000080", "Navy Blue",
			"333399", "Indigo",
			"333333", "Very dark gray",
			"800000", "Maroon",
			"FF6600", "Orange",
			"808000", "Olive",
			"008000", "Green",
			"008080", "Teal",
			"0000FF", "Blue",
			"666699", "Grayish blue",
			"808080", "Gray",
			"FF0000", "Red",
			"FF9900", "Amber",
			"99CC00", "Yellow green",
			"339966", "Sea green",
			"33CCCC", "Turquoise",
			"3366FF", "Royal blue",
			"800080", "Purple",
			"999999", "Medium gray",
			"FF00FF", "Magenta",
			"FFCC00", "Gold",
			"FFFF00", "Yellow",
			"00FF00", "Lime",
			"00FFFF", "Aqua",
			"00CCFF", "Sky blue",
			"993366", "Red violet",
			"FFFFFF", "White",
			"FF99CC", "Pink",
			"FFCC99", "Peach",
			"FFFF99", "Light yellow",
			"CCFFCC", "Pale green",
			"CCFFFF", "Pale cyan",
			"99CCFF", "Light sky blue",
			"CC99FF", "Plum"
		];

		colorMap = editor.settings.textcolor_map || colorMap;
		colorMap = editor.settings[type + '_map'] || colorMap;

		for (i = 0; i < colorMap.length; i += 2) {
			colors.push({
				text: colorMap[i + 1],
				color: '#' + colorMap[i]
			});
		}

		return colors;
	}

	function renderColorPicker() {
		var ctrl = this, colors, color, html, last, x, y, i, id = ctrl._id, count = 0, type;

		type = ctrl.settings.origin;

		function getColorCellHtml(color, title) {
			var isNoColor = color == 'transparent';

			return (
				'<td class="mce-grid-cell' + (isNoColor ? ' mce-colorbtn-trans' : '') + '">' +
					'<div id="' + id + '-' + (count++) + '"' +
						' data-mce-color="' + (color ? color : '') + '"' +
						' role="option"' +
						' tabIndex="-1"' +
						' style="' + (color ? 'background-color: ' + color : '') + '"' +
						' title="' + tinymce.translate(title) + '">' +
						(isNoColor ? '&#215;' : '') +
					'</div>' +
				'</td>'
			);
		}

		colors = mapColors(type);
		colors.push({
			text: tinymce.translate("No color"),
			color: "transparent"
		});

		html = '<table class="mce-grid mce-grid-border mce-colorbutton-grid" role="list" cellspacing="0"><tbody>';
		last = colors.length - 1;

		for (y = 0; y < rows[type]; y++) {
			html += '<tr>';

			for (x = 0; x < cols[type]; x++) {
				i = y * cols[type] + x;

				if (i > last) {
					html += '<td></td>';
				} else {
					color = colors[i];
					html += getColorCellHtml(color.color, color.text);
				}
			}

			html += '</tr>';
		}

		if (editor.settings.color_picker_callback) {
			html += (
				'<tr>' +
					'<td colspan="' + cols[type] + '" class="mce-custom-color-btn">' +
						'<div id="' + id + '-c" class="mce-widget mce-btn mce-btn-small mce-btn-flat" ' +
							'role="button" tabindex="-1" aria-labelledby="' + id + '-c" style="width: 100%">' +
							'<button type="button" role="presentation" tabindex="-1">' + tinymce.translate('Custom...') + '</button>' +
						'</div>' +
					'</td>' +
				'</tr>'
			);

			html += '<tr>';

			for (x = 0; x < cols[type]; x++) {
				html += getColorCellHtml('', 'Custom color');
			}

			html += '</tr>';
		}

		html += '</tbody></table>';

		return html;
	}

	function applyFormat(format, value) {
		editor.undoManager.transact(function() {
			editor.focus();
			editor.formatter.apply(format, {value: value});
			editor.nodeChanged();
		});
	}

	function removeFormat(format) {
		editor.undoManager.transact(function() {
			editor.focus();
			editor.formatter.remove(format, {value: null}, null, true);
			editor.nodeChanged();
		});
	}

	function onPanelClick(e) {
		var buttonCtrl = this.parent(), value, type;

		type = buttonCtrl.settings.origin;

		function selectColor(value) {
			buttonCtrl.hidePanel();
			buttonCtrl.color(value);
			applyFormat(buttonCtrl.settings.format, value);
		}

		function resetColor() {
			buttonCtrl.hidePanel();
			buttonCtrl.resetColor();
			removeFormat(buttonCtrl.settings.format);
		}

		function setDivColor(div, value) {
			div.style.background = value;
			div.setAttribute('data-mce-color', value);
		}

		if (tinymce.DOM.getParent(e.target, '.mce-custom-color-btn')) {
			buttonCtrl.hidePanel();

			editor.settings.color_picker_callback.call(editor, function(value) {
				var tableElm = buttonCtrl.panel.getEl().getElementsByTagName('table')[0];
				var customColorCells, div, i;

				customColorCells = tinymce.map(tableElm.rows[tableElm.rows.length - 1].childNodes, function(elm) {
					return elm.firstChild;
				});

				for (i = 0; i < customColorCells.length; i++) {
					div = customColorCells[i];
					if (!div.getAttribute('data-mce-color')) {
						break;
					}
				}

				// Shift colors to the right
				// TODO: Might need to be the left on RTL
				if (i == cols[type]) {
					for (i = 0; i < cols[type] - 1; i++) {
						setDivColor(customColorCells[i], customColorCells[i + 1].getAttribute('data-mce-color'));
					}
				}

				setDivColor(div, value);
				selectColor(value);
			}, getCurrentColor(buttonCtrl.settings.format));
		}

		value = e.target.getAttribute('data-mce-color');
		if (value) {
			if (this.lastId) {
				document.getElementById(this.lastId).setAttribute('aria-selected', false);
			}

			e.target.setAttribute('aria-selected', true);
			this.lastId = e.target.id;

			if (value == 'transparent') {
				resetColor();
			} else {
				selectColor(value);
			}
		} else if (value !== null) {
			buttonCtrl.hidePanel();
		}
	}

	function onButtonClick() {
		var self = this;

		if (self._color) {
			applyFormat(self.settings.format, self._color);
		} else {
			removeFormat(self.settings.format);
		}
	}

	editor.addButton('forecolor', {
		type: 'colorbutton',
		tooltip: 'Text color',
		format: 'forecolor',
		panel: {
			origin: 'forecolor',
			role: 'application',
			ariaRemember: true,
			html: renderColorPicker,
			onclick: onPanelClick
		},
		onclick: onButtonClick
	});

	editor.addButton('backcolor', {
		type: 'colorbutton',
		tooltip: 'Background color',
		format: 'hilitecolor',
		panel: {
			origin: 'backcolor',
			role: 'application',
			ariaRemember: true,
			html: renderColorPicker,
			onclick: onPanelClick
		},
		onclick: onButtonClick
	});
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('textpattern', function(editor) {
	var isPatternsDirty = true, patterns;

	patterns = editor.settings.textpattern_patterns || [
		{start: '*', end: '*', format: 'italic'},
		{start: '**', end: '**', format: 'bold'},
		{start: '#', format: 'h1'},
		{start: '##', format: 'h2'},
		{start: '###', format: 'h3'},
		{start: '####', format: 'h4'},
		{start: '#####', format: 'h5'},
		{start: '######', format: 'h6'},
		{start: '1. ', cmd: 'InsertOrderedList'},
		{start: '* ', cmd: 'InsertUnorderedList'},
		{start: '- ', cmd: 'InsertUnorderedList'}
	];

	// Returns a sorted patterns list, ordered descending by start length
	function getPatterns() {
		if (isPatternsDirty) {
			patterns.sort(function(a, b) {
				if (a.start.length > b.start.length) {
					return -1;
				}

				if (a.start.length < b.start.length) {
					return 1;
				}

				return 0;
			});

			isPatternsDirty = false;
		}

		return patterns;
	}

	// Finds a matching pattern to the specified text
	function findPattern(text) {
		var patterns = getPatterns();

		for (var i = 0; i < patterns.length; i++) {
			if (text.indexOf(patterns[i].start) !== 0) {
				continue;
			}

			if (patterns[i].end && text.lastIndexOf(patterns[i].end) != text.length - patterns[i].end.length) {
				continue;
			}

			return patterns[i];
		}
	}

	// Finds the best matching end pattern
	function findEndPattern(text, offset, delta) {
		var patterns, pattern, i;

		// Find best matching end
		patterns = getPatterns();
		for (i = 0; i < patterns.length; i++) {
			pattern = patterns[i];
			if (pattern.end && text.substr(offset - pattern.end.length - delta, pattern.end.length) == pattern.end) {
				return pattern;
			}
		}
	}

	// Handles inline formats like *abc* and **abc**
	function applyInlineFormat(space) {
		var selection, dom, rng, container, offset, startOffset, text, patternRng, pattern, delta, format;

		function splitContainer() {
			// Split text node and remove start/end from text node
			container = container.splitText(startOffset);
			container.splitText(offset - startOffset - delta);
			container.deleteData(0, pattern.start.length);
			container.deleteData(container.data.length - pattern.end.length, pattern.end.length);
		}

		selection = editor.selection;
		dom = editor.dom;

		if (!selection.isCollapsed()) {
			return;
		}

		rng = selection.getRng(true);
		container = rng.startContainer;
		offset = rng.startOffset;
		text = container.data;
		delta = space ? 1 : 0;

		if (container.nodeType != 3) {
			return;
		}

		// Find best matching end
		pattern = findEndPattern(text, offset, delta);
		if (!pattern) {
			return;
		}

		// Find start of matched pattern
		// TODO: Might need to improve this if there is nested formats
		startOffset = Math.max(0, offset - delta);
		startOffset = text.lastIndexOf(pattern.start, startOffset - pattern.end.length - 1);

		if (startOffset === -1) {
			return;
		}

		// Setup a range for the matching word
		patternRng = dom.createRng();
		patternRng.setStart(container, startOffset);
		patternRng.setEnd(container, offset - delta);
		pattern = findPattern(patternRng.toString());

		if (!pattern || !pattern.end) {
			return;
		}

		// If container match doesn't have anything between start/end then do nothing
		if (container.data.length <= pattern.start.length + pattern.end.length) {
			return;
		}

		format = editor.formatter.get(pattern.format);
		if (format && format[0].inline) {
			splitContainer();
			editor.formatter.apply(pattern.format, {}, container);
			return container;
		}
	}

	// Handles block formats like ##abc or 1. abc
	function applyBlockFormat() {
		var selection, dom, container, firstTextNode, node, format, textBlockElm, pattern, walker, rng, offset;

		selection = editor.selection;
		dom = editor.dom;

		if (!selection.isCollapsed()) {
			return;
		}

		textBlockElm = dom.getParent(selection.getStart(), 'p');
		if (textBlockElm) {
			walker = new tinymce.dom.TreeWalker(textBlockElm, textBlockElm);
			while ((node = walker.next())) {
				if (node.nodeType == 3) {
					firstTextNode = node;
					break;
				}
			}

			if (firstTextNode) {
				pattern = findPattern(firstTextNode.data);
				if (!pattern) {
					return;
				}

				rng = selection.getRng(true);
				container = rng.startContainer;
				offset = rng.startOffset;

				if (firstTextNode == container) {
					offset = Math.max(0, offset - pattern.start.length);
				}

				if (tinymce.trim(firstTextNode.data).length == pattern.start.length) {
					return;
				}

				if (pattern.format) {
					format = editor.formatter.get(pattern.format);
					if (format && format[0].block) {
						firstTextNode.deleteData(0, pattern.start.length);
						editor.formatter.apply(pattern.format, {}, firstTextNode);

						rng.setStart(container, offset);
						rng.collapse(true);
						selection.setRng(rng);
					}
				}

				if (pattern.cmd) {
					editor.undoManager.transact(function() {
						firstTextNode.deleteData(0, pattern.start.length);
						editor.execCommand(pattern.cmd);
					});
				}
			}
		}
	}

	function handleEnter() {
		var rng, wrappedTextNode;

		wrappedTextNode = applyInlineFormat();
		if (wrappedTextNode) {
			rng = editor.dom.createRng();
			rng.setStart(wrappedTextNode, wrappedTextNode.data.length);
			rng.setEnd(wrappedTextNode, wrappedTextNode.data.length);
			editor.selection.setRng(rng);
		}

		applyBlockFormat();
	}

	function handleSpace() {
		var wrappedTextNode, lastChar, lastCharNode, rng, dom;

		wrappedTextNode = applyInlineFormat(true);
		if (wrappedTextNode) {
			dom = editor.dom;
			lastChar = wrappedTextNode.data.slice(-1);

			// Move space after the newly formatted node
			if (/[\u00a0 ]/.test(lastChar)) {
				wrappedTextNode.deleteData(wrappedTextNode.data.length - 1, 1);
				lastCharNode = dom.doc.createTextNode(lastChar);

				if (wrappedTextNode.nextSibling) {
					dom.insertAfter(lastCharNode, wrappedTextNode.nextSibling);
				} else {
					wrappedTextNode.parentNode.appendChild(lastCharNode);
				}

				rng = dom.createRng();
				rng.setStart(lastCharNode, 1);
				rng.setEnd(lastCharNode, 1);
				editor.selection.setRng(rng);
			}
		}
	}

	editor.on('keydown', function(e) {
		if (e.keyCode == 13 && !tinymce.util.VK.modifierPressed(e)) {
			handleEnter();
		}
	}, true);

	editor.on('keyup', function(e) {
		if (e.keyCode == 32 && !tinymce.util.VK.modifierPressed(e)) {
			handleSpace();
		}
	});

	this.getPatterns = getPatterns;
	this.setPatterns = function(newPatterns) {
		patterns = newPatterns;
		isPatternsDirty = true;
	};
});
/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('toc', function(editor) {
    var $ = editor.$;
    var opts;

    var defs = {
        depth: 3,
        headerTag: 'h2',
        className: 'mce-toc'
    };

    var guid = function(prefix) {
        var counter = 0;
        return function() {
            var guid = new Date().getTime().toString(32);
            return prefix + guid + (counter++).toString(32);
        };
    };

    var tocId = guid('mcetoc_');


    function isValidTag(tagName) {
        return editor.schema.isValidChild('div', tagName);
    }


    function isToc(elm) {
        return elm && editor.dom.is(elm, '.' + opts.className) && editor.getBody().contains(elm);
    }


    function toggleState() {
        var self = this;

        self.disabled(editor.readonly || !haveHeaders());

        editor.on('LoadContent SetContent change', function() {
            self.disabled(editor.readonly || !haveHeaders());
        });
    }


    function generateSelector(depth) {
        var i, selector = [];
        for (i = 1; i <= depth; i++) {
            selector.push('h' + i);
        }
        return selector.join(',');
    }


    function haveHeaders() {
        return !!(opts && prepareHeaders(opts).length);
    }


    function prepareHeaders(o) {
        var selector = generateSelector(o.depth);
        var headers = $(selector);

        // if headerTag is one of h1-9, we need to filter it out from the set
        if (headers.length && /^h[1-9]$/i.test(o.headerTag)) {
            headers = headers.filter(function(i, el) {
                return !editor.dom.hasClass(el.parentNode, o.className);
            });
        }

        return tinymce.map(headers, function(h) {
            if (!h.id) {
                h.id = tocId();
            }
            return {
                id: h.id,
                level: parseInt(h.nodeName.replace(/^H/i, ''), 10),
                title: $.text(h)
            };
        });
    }


    function getMinLevel(headers) {
        var i, minLevel = 9;

        for (i = 0; i < headers.length; i++) {
            if (headers[i].level < minLevel) {
                minLevel = headers[i].level;
            }

            // do not proceed if we have reached absolute minimum
            if (minLevel == 1) {
                return minLevel;
            }
        }
        return minLevel;
    }


    function generateTitle(tag, title) {
        var openTag = '<' + tag + ' contenteditable="true">';
        var closeTag = '</' + tag + '>';
        return openTag + editor.dom.encode(title) + closeTag;
    }


    function generateTocHtml(o) {
        var html = generateTocContentHtml(o);
        return '<div class="' + o.className + '" contenteditable="false">' + html + '</div>';
    }


    function generateTocContentHtml(o) {
        var html = '';
        var headers = prepareHeaders(o);
        var prevLevel = getMinLevel(headers) - 1;
        var i, ii, h, nextLevel;

        if (!headers.length) {
            return '';
        }

        html += generateTitle(o.headerTag, tinymce.translate("Table of Contents"));

        for (i = 0; i < headers.length; i++) {
            h = headers[i];
            nextLevel = headers[i + 1] && headers[i + 1].level;

            if (prevLevel === h.level) {
                html += '<li>';
            } else {
                for (ii = prevLevel; ii < h.level; ii++) {
                    html += '<ul><li>';
                }
            }

            html += '<a href="#' + h.id + '">' + h.title + '</a>';

            if (nextLevel === h.level || !nextLevel) {
                html += '</li>';

                if (!nextLevel) {
                    html += '</ul>';
                }
            } else {
                for (ii = h.level; ii > nextLevel; ii--) {
                    html += '</li></ul><li>';
                }
            }

            prevLevel = h.level;
        }

        return html;
    }


    editor.on('PreInit', function() {
        var s = editor.settings;
        var depth = parseInt(s.toc_depth, 10) || 0;

        opts = {
            depth: depth >= 1 && depth <= 9 ? depth : defs.depth,
            headerTag: isValidTag(s.toc_header) ? s.toc_header : defs.headerTag,
            className: s.toc_class ? editor.dom.encode(s.toc_class) : defs.className
        };
    });


    editor.on('PreProcess', function(e) {
        var $tocElm = $('.' + opts.className, e.node);
        if ($tocElm.length) {
            $tocElm.removeAttr('contentEditable');
            $tocElm.find('[contenteditable]').removeAttr('contentEditable');
        }
    });


    editor.on('SetContent', function() {
        var $tocElm = $('.' + opts.className);
        if ($tocElm.length) {
            $tocElm.attr('contentEditable', false);
            $tocElm.children(':first-child').attr('contentEditable', true);
        }
    });

    var isEmptyOrOffscren = function (nodes) {
        return !nodes.length || editor.dom.getParents(nodes[0], '.mce-offscreen-selection').length > 0;
    };

    editor.addCommand('mceInsertToc', function() {
        var $tocElm = $('.' + opts.className);

        if (isEmptyOrOffscren($tocElm)) {
            editor.insertContent(generateTocHtml(opts));
        } else {
            editor.execCommand('mceUpdateToc');
        }
    });


    editor.addCommand('mceUpdateToc', function() {
        var $tocElm = $('.' + opts.className);
        if ($tocElm.length) {
            editor.undoManager.transact(function () {
                $tocElm.html(generateTocContentHtml(opts));
            });
        }
    });


    editor.addButton('toc', {
        tooltip: 'Table of Contents',
        cmd: 'mceInsertToc',
        icon: 'toc',
        onPostRender: toggleState
    });

    editor.addButton('tocupdate', {
        tooltip: 'Update',
        cmd: 'mceUpdateToc',
        icon: 'reload'
    });

    editor.addContextToolbar(
        isToc,
        'tocupdate'
    );

    editor.addMenuItem('toc', {
        text: "Table of Contents",
        context: 'insert',
        cmd: 'mceInsertToc',
        onPostRender: toggleState
    });
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('visualblocks', function(editor, url) {
	var cssId, visualBlocksMenuItem, enabled;

	// We don't support older browsers like IE6/7 and they don't provide prototypes for DOM objects
	if (!window.NodeList) {
		return;
	}

	function toggleActiveState() {
		var self = this;

		self.active(enabled);

		editor.on('VisualBlocks', function() {
			self.active(editor.dom.hasClass(editor.getBody(), 'mce-visualblocks'));
		});
	}

	editor.addCommand('mceVisualBlocks', function() {
		var dom = editor.dom, linkElm;

		if (!cssId) {
			cssId = dom.uniqueId();
			linkElm = dom.create('link', {
				id: cssId,
				rel: 'stylesheet',
				href: url + '/css/visualblocks.css'
			});

			editor.getDoc().getElementsByTagName('head')[0].appendChild(linkElm);
		}

		// Toggle on/off visual blocks while computing previews
		editor.on("PreviewFormats AfterPreviewFormats", function(e) {
			if (enabled) {
				dom.toggleClass(editor.getBody(), 'mce-visualblocks', e.type == "afterpreviewformats");
			}
		});

		dom.toggleClass(editor.getBody(), 'mce-visualblocks');
		enabled = editor.dom.hasClass(editor.getBody(), 'mce-visualblocks');

		if (visualBlocksMenuItem) {
			visualBlocksMenuItem.active(dom.hasClass(editor.getBody(), 'mce-visualblocks'));
		}

		editor.fire('VisualBlocks');
	});

	editor.addButton('visualblocks', {
		title: 'Show blocks',
		cmd: 'mceVisualBlocks',
		onPostRender: toggleActiveState
	});

	editor.addMenuItem('visualblocks', {
		text: 'Show blocks',
		cmd: 'mceVisualBlocks',
		onPostRender: toggleActiveState,
		selectable: true,
		context: 'view',
		prependToContext: true
	});

	editor.on('init', function() {
		if (editor.settings.visualblocks_default_state) {
			editor.execCommand('mceVisualBlocks', false, null, {skip_focus: true});
		}
	});

	editor.on('remove', function() {
		editor.dom.removeClass(editor.getBody(), 'mce-visualblocks');
	});
});

/**
 * plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

/*global tinymce:true */

tinymce.PluginManager.add('visualchars', function(editor) {
	var self = this, state;

	function toggleVisualChars(addBookmark) {
		var node, nodeList, i, body = editor.getBody(), nodeValue, selection = editor.selection, div, bookmark;
		var charMap, visualCharsRegExp;

		charMap = {
			'\u00a0': 'nbsp',
			'\u00ad': 'shy'
		};

		function wrapCharWithSpan(value) {
			return '<span data-mce-bogus="1" class="mce-' + charMap[value] + '">' + value + '</span>';
		}

		function compileCharMapToRegExp() {
			var key, regExp = '';

			for (key in charMap) {
				regExp += key;
			}

			return new RegExp('[' + regExp + ']', 'g');
		}

		function compileCharMapToCssSelector() {
			var key, selector = '';

			for (key in charMap) {
				if (selector) {
					selector += ',';
				}

				selector += 'span.mce-' + charMap[key];
			}

			return selector;
		}

		state = !state;
		self.state = state;
		editor.fire('VisualChars', {state: state});
		visualCharsRegExp = compileCharMapToRegExp();

		if (addBookmark) {
			bookmark = selection.getBookmark();
		}

		if (state) {
			nodeList = [];
			tinymce.walk(body, function(n) {
				if (n.nodeType == 3 && n.nodeValue && visualCharsRegExp.test(n.nodeValue)) {
					nodeList.push(n);
				}
			}, 'childNodes');

			for (i = 0; i < nodeList.length; i++) {
				nodeValue = nodeList[i].nodeValue;
				nodeValue = nodeValue.replace(visualCharsRegExp, wrapCharWithSpan);

				div = editor.dom.create('div', null, nodeValue);
				while ((node = div.lastChild)) {
					editor.dom.insertAfter(node, nodeList[i]);
				}

				editor.dom.remove(nodeList[i]);
			}
		} else {
			nodeList = editor.dom.select(compileCharMapToCssSelector(), body);

			for (i = nodeList.length - 1; i >= 0; i--) {
				editor.dom.remove(nodeList[i], 1);
			}
		}

		selection.moveToBookmark(bookmark);
	}

	function toggleActiveState() {
		var self = this;

		editor.on('VisualChars', function(e) {
			self.active(e.state);
		});
	}

	editor.addCommand('mceVisualChars', toggleVisualChars);

	editor.addButton('visualchars', {
		title: 'Show invisible characters',
		cmd: 'mceVisualChars',
		onPostRender: toggleActiveState
	});

	editor.addMenuItem('visualchars', {
		text: 'Show invisible characters',
		cmd: 'mceVisualChars',
		onPostRender: toggleActiveState,
		selectable: true,
		context: 'view',
		prependToContext: true
	});
});

(function () {

var defs = {}; // id -> {dependencies, definition, instance (possibly undefined)}

// Used when there is no 'main' module.
// The name is probably (hopefully) unique so minification removes for releases.
var register_3795 = function (id) {
  var module = dem(id);
  var fragments = id.split('.');
  var target = Function('return this;')();
  for (var i = 0; i < fragments.length - 1; ++i) {
    if (target[fragments[i]] === undefined)
      target[fragments[i]] = {};
    target = target[fragments[i]];
  }
  target[fragments[fragments.length - 1]] = module;
};

var instantiate = function (id) {
  var actual = defs[id];
  var dependencies = actual.deps;
  var definition = actual.defn;
  var len = dependencies.length;
  var instances = new Array(len);
  for (var i = 0; i < len; ++i)
    instances[i] = dem(dependencies[i]);
  var defResult = definition.apply(null, instances);
  if (defResult === undefined)
     throw 'module [' + id + '] returned undefined';
  actual.instance = defResult;
};

var def = function (id, dependencies, definition) {
  if (typeof id !== 'string')
    throw 'module id must be a string';
  else if (dependencies === undefined)
    throw 'no dependencies for ' + id;
  else if (definition === undefined)
    throw 'no definition function for ' + id;
  defs[id] = {
    deps: dependencies,
    defn: definition,
    instance: undefined
  };
};

var dem = function (id) {
  var actual = defs[id];
  if (actual === undefined)
    throw 'module [' + id + '] was undefined';
  else if (actual.instance === undefined)
    instantiate(id);
  return actual.instance;
};

var req = function (ids, callback) {
  var len = ids.length;
  var instances = new Array(len);
  for (var i = 0; i < len; ++i)
    instances.push(dem(ids[i]));
  callback.apply(null, callback);
};

var ephox = {};

ephox.bolt = {
  module: {
    api: {
      define: def,
      require: req,
      demand: dem
    }
  }
};

var define = def;
var require = req;
var demand = dem;
// this helps with minificiation when using a lot of global references
var defineGlobal = function (id, ref) {
  define(id, [], function () { return ref; });
};
/*jsc
["tinymce.wordcount.Plugin","global!tinymce.PluginManager","global!tinymce.util.Delay","tinymce.wordcount.text.WordGetter","tinymce.wordcount.text.UnicodeData","tinymce.wordcount.text.StringMapper","tinymce.wordcount.text.WordBoundary","tinymce.wordcount.alien.Arr"]
jsc*/
defineGlobal("global!tinymce.PluginManager", tinymce.PluginManager);
defineGlobal("global!tinymce.util.Delay", tinymce.util.Delay);
/**
 * UnicodeData.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */
/* eslint-disable max-len */

define("tinymce.wordcount.text.UnicodeData", [], function() {
	var regExps = {
		aletter: '[A-Za-z\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F3\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u10A0-\u10C5\u10D0-\u10FA\u10FC\u1100-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1A00-\u1A16\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BC0-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2D00-\u2D25\u2D30-\u2D65\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u303B\u303C\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790\uA791\uA7A0-\uA7A9\uA7FA-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]',
		midnumlet: "['\\.\u2018\u2019\u2024\uFE52\uFF07\uFF0E]",
		midletter: '[:\u00B7\u00B7\u05F4\u2027\uFE13\uFE55\uFF1A]',
		midnum: '[,;;\u0589\u060C\u060D\u066C\u07F8\u2044\uFE10\uFE14\uFE50\uFE54\uFF0C\uFF1B]',
		numeric: '[0-9\u0660-\u0669\u066B\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9]',
		cr: '\\r',
		lf: '\\n',
		newline: '[\u000B\u000C\u0085\u2028\u2029]',
		extend: '[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0900-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C01-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C82\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D02\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B6-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAA\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2\u1DC0-\u1DE6\u1DFC-\u1DFF\u200C\u200D\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA67C\uA67D\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26\uFF9E\uFF9F]',
		format: '[\u00AD\u0600-\u0603\u06DD\u070F\u17B4\u17B5\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\uFEFF\uFFF9-\uFFFB]',
		katakana: '[\u3031-\u3035\u309B\u309C\u30A0-\u30FA\u30FC-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF9D]',
		extendnumlet: '[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]',
		punctuation: '[!-#%-*,-\\/:;?@\\[-\\]_{}\u00A1\u00AB\u00B7\u00BB\u00BF;\u00B7\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1361-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u3008\u3009\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30\u2E31\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]'
	};

	var characterIndices = {
		ALETTER: 0,
		MIDNUMLET: 1,
		MIDLETTER: 2,
		MIDNUM: 3,
		NUMERIC: 4,
		CR: 5,
		LF: 6,
		NEWLINE: 7,
		EXTEND: 8,
		FORMAT: 9,
		KATAKANA: 10,
		EXTENDNUMLET: 11,
		AT: 12,
		OTHER: 13
	};

	// RegExp objects generated from code point data. Each regex matches a single
	// character against a set of Unicode code points. The index of each item in
	// this array must match its corresponding code point constant value defined
	// above.
	var SETS = [
		new RegExp(regExps.aletter),
		new RegExp(regExps.midnumlet),
		new RegExp(regExps.midletter),
		new RegExp(regExps.midnum),
		new RegExp(regExps.numeric),
		new RegExp(regExps.cr),
		new RegExp(regExps.lf),
		new RegExp(regExps.newline),
		new RegExp(regExps.extend),
		new RegExp(regExps.format),
		new RegExp(regExps.katakana),
		new RegExp(regExps.extendnumlet),
		new RegExp('@')
	];

	var EMPTY_STRING = '';
	var PUNCTUATION = new RegExp('^' + regExps.punctuation + '$');
	var WHITESPACE = /\s/;

	return {
		characterIndices: characterIndices,
		SETS: SETS,
		EMPTY_STRING: EMPTY_STRING,
		PUNCTUATION: PUNCTUATION,
		WHITESPACE: WHITESPACE
	};
});
/**
 * Arr.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define('tinymce.wordcount.alien.Arr', [
], function () {
	var each = function (o, cb, s) {
		var n, l;

		if (!o) {
			return 0;
		}

		s = s || o;

		if (o.length !== undefined) {
			// Indexed arrays, needed for Safari
			for (n = 0, l = o.length; n < l; n++) {
				if (cb.call(s, o[n], n, o) === false) {
					return 0;
				}
			}
		} else {
			// Hashtables
			for (n in o) {
				if (o.hasOwnProperty(n)) {
					if (cb.call(s, o[n], n, o) === false) {
						return 0;
					}
				}
			}
		}

		return 1;
	};

	var map = function (array, callback) {
		var out = [];

		each(array, function(item, index) {
			out.push(callback(item, index, array));
		});

		return out;
	};

	return {
		each: each,
		map: map
	};
});

/**
 * StringMapper.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */
define('tinymce.wordcount.text.StringMapper', [
	'tinymce.wordcount.text.UnicodeData',
	'tinymce.wordcount.alien.Arr'
], function(UnicodeData, Arr) {
	var SETS = UnicodeData.SETS;
	var OTHER = UnicodeData.characterIndices.OTHER;

	var getType = function (char) {
		var j, set, type = OTHER;
		var setsLength = SETS.length;
		for (j = 0; j < setsLength; ++j) {
			set = SETS[j];

			if (set && set.test(char)) {
				type = j;
				break;
			}
		}
		return type;
	};

	var memoize = function (func) {
		var cache = {};
		return function(char) {
			if (cache[char]) {
				return cache[char];
			} else {
				var result = func(char);
				cache[char] = result;
				return result;
			}
		};
	};

	var classify = function (string) {
		var memoized = memoize(getType);
		return Arr.map(string.split(''), memoized);
	};

	return {
		classify: classify
	};
});

/**
 * IsWordBoundary.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.wordcount.text.WordBoundary", [
	"tinymce.wordcount.text.UnicodeData"
], function(UnicodeData) {
	var ci = UnicodeData.characterIndices;
	var isWordBoundary = function (map, index) {
		var prevType;
		var type = map[index];
		var nextType = map[index + 1];
		var nextNextType;

		if (index < 0 || (index > map.length - 1 && index !== 0)) {
				// console.log('isWordBoundary: index out of bounds', 'warn', 'text-wordbreak');
			return false;
		}

		// WB5. Don't break between most letters.
		if (type === ci.ALETTER && nextType === ci.ALETTER) {
			return false;
		}

		nextNextType = map[index + 2];

		// WB6. Don't break letters across certain punctuation.
		if (type === ci.ALETTER &&
						(nextType === ci.MIDLETTER || nextType === ci.MIDNUMLET || nextType === ci.AT) &&
						nextNextType === ci.ALETTER) {
			return false;
		}

		prevType = map[index - 1];

		// WB7. Don't break letters across certain punctuation.
		if ((type === ci.MIDLETTER || type === ci.MIDNUMLET || nextType === ci.AT) &&
						nextType === ci.ALETTER &&
						prevType === ci.ALETTER) {
			return false;
		}

		// WB8/WB9/WB10. Don't break inside sequences of digits or digits
		// adjacent to letters.
		if ((type === ci.NUMERIC || type === ci.ALETTER) &&
						(nextType === ci.NUMERIC || nextType === ci.ALETTER)) {
			return false;
		}

		// WB11. Don't break inside numeric sequences like "3.2" or
		// "3,456.789".
		if ((type === ci.MIDNUM || type === ci.MIDNUMLET) &&
						nextType === ci.NUMERIC &&
						prevType === ci.NUMERIC) {
			return false;
		}

		// WB12. Don't break inside numeric sequences like "3.2" or
		// "3,456.789".
		if (type === ci.NUMERIC &&
						(nextType === ci.MIDNUM || nextType === ci.MIDNUMLET) &&
						nextNextType === ci.NUMERIC) {
			return false;
		}

		// WB4. Ignore format and extend characters.
		if (type === ci.EXTEND || type === ci.FORMAT ||
						prevType === ci.EXTEND || prevType === ci.FORMAT ||
						nextType === ci.EXTEND || nextType === ci.FORMAT) {
			return false;
		}

		// WB3. Don't break inside CRLF.
		if (type === ci.CR && nextType === ci.LF) {
			return false;
		}

		// WB3a. Break before newlines (including CR and LF).
		if (type === ci.NEWLINE || type === ci.CR || type === ci.LF) {
			return true;
		}

		// WB3b. Break after newlines (including CR and LF).
		if (nextType === ci.NEWLINE || nextType === ci.CR || nextType === ci.LF) {
			return true;
		}

		// WB13. Don't break between Katakana characters.
		if (type === ci.KATAKANA && nextType === ci.KATAKANA) {
			return false;
		}

		// WB13a. Don't break from extenders.
		if (nextType === ci.EXTENDNUMLET &&
						(type === ci.ALETTER || type === ci.NUMERIC || type === ci.KATAKANA ||
						type === ci.EXTENDNUMLET)) {
			return false;
		}

		// WB13b. Don't break from extenders.
		if (type === ci.EXTENDNUMLET &&
						(nextType === ci.ALETTER || nextType === ci.NUMERIC ||
						nextType === ci.KATAKANA)) {
			return false;
		}

		if (type === ci.AT) {
			return false;
		}

		// Break after any character not covered by the rules above.
		return true;
	};

	return {
		isWordBoundary: isWordBoundary
	};
});
/**
 * WordGetter.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.wordcount.text.WordGetter", [
	"tinymce.wordcount.text.UnicodeData",
	"tinymce.wordcount.text.StringMapper",
	"tinymce.wordcount.text.WordBoundary"
], function(UnicodeData, StringMapper, WordBoundary) {
	var EMPTY_STRING = UnicodeData.EMPTY_STRING;
	var WHITESPACE = UnicodeData.WHITESPACE;
	var PUNCTUATION = UnicodeData.PUNCTUATION;

	var isProtocol = function (word) {
		return word === 'http' || word === 'https';
	};

	var findWordEnd = function (string, index) {
		var i;
		for (i = index; i < string.length; ++i) {
			var chr = string.charAt(i);

			if (WHITESPACE.test(chr)) {
				break;
			}
		}
		return i;
	};

	var extractUrl = function (word, string, index) {
		var endIndex = findWordEnd(string, index + 1);
		var peakedWord = string.substring(index + 1, endIndex);
		if (peakedWord.substr(0, 3) === '://') {
			return {
				word: word + peakedWord,
				index: endIndex
			};
		}

		return {
			word: word,
			index: index
		};
	};

	var getWords = function (string, options) {
		var i = 0;
		var map = StringMapper.classify(string);
		var len = map.length;
		var word = [];
		var words = [];
		var chr;
		var includePunctuation;
		var includeWhitespace;

		if (!options) {
			options = {};
		}

		if (options.ignoreCase) {
			string = string.toLowerCase();
		}

		includePunctuation = options.includePunctuation;
		includeWhitespace = options.includeWhitespace;

		// Loop through each character in the classification map and determine
		// whether it precedes a word boundary, building an array of distinct
		// words as we go.
		for (; i < len; ++i) {
			chr = string.charAt(i);

			// Append this character to the current word.
			word.push(chr);

			// If there's a word boundary between the current character and the
			// next character, append the current word to the words array and
			// start building a new word.
			if (WordBoundary.isWordBoundary(map, i)) {
				word = word.join(EMPTY_STRING);

				if (word &&
								(includeWhitespace || !WHITESPACE.test(word)) &&
								(includePunctuation || !PUNCTUATION.test(word))) {
					if (isProtocol(word)) {
						var obj = extractUrl(word, string, i);
						words.push(obj.word);
						i = obj.index;
					} else {
						words.push(word);
					}
				}

				word = [];
			}
		}

		return words;
	};

	return {
		getWords: getWords
	};
});
/**
 * Plugin.js
 *
 * Released under LGPL License.
 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
 *
 * License: http://www.tinymce.com/license
 * Contributing: http://www.tinymce.com/contributing
 */

define("tinymce.wordcount.Plugin", [
	"global!tinymce.PluginManager",
	"global!tinymce.util.Delay",
	"tinymce.wordcount.text.WordGetter"
], function(PluginManager, Delay, WordGetter) {
	PluginManager.add('wordcount', function(editor) {
		var getTextContent = function(editor) {
			return editor.removed ? '' : editor.getBody().innerText;
		};

		var getCount = function() {
			return WordGetter.getWords(getTextContent(editor)).length;
		};

		var update = function() {
			editor.theme.panel.find('#wordcount').text(['Words: {0}', getCount()]);
		};

		editor.on('init', function() {
			var statusbar = editor.theme.panel && editor.theme.panel.find('#statusbar')[0];
			var debouncedUpdate = Delay.debounce(update, 300);

			if (statusbar) {
				Delay.setEditorTimeout(editor, function() {
					statusbar.insert({
						type: 'label',
						name: 'wordcount',
						text: ['Words: {0}', getCount()],
						classes: 'wordcount',
						disabled: editor.settings.readonly
					}, 0);

					editor.on('setcontent beforeaddundo undo redo keyup', debouncedUpdate);
				}, 0);
			}
		});

		return {
			getCount: getCount
		};
	});

	return function () {};
});

dem('tinymce.wordcount.Plugin')();
})();

/**
 * Binds a TinyMCE widget to <textarea> elements.
 */
angular.module('ui.tinymce', [])
  .value('uiTinymceConfig', {})
  .directive('uiTinymce', ['$rootScope', '$compile', '$timeout', '$window', '$sce', 'uiTinymceConfig', function($rootScope, $compile, $timeout, $window, $sce, uiTinymceConfig) {
    uiTinymceConfig = uiTinymceConfig || {};
    var ID_ATTR = 'ui-tinymce';
    if (uiTinymceConfig.baseUrl) {
      tinymce.baseURL = uiTinymceConfig.baseUrl;
    }

    return {
      require: ['ngModel', '^?form'],
      priority: 599,
      link: function(scope, element, attrs, ctrls) {
        if (!$window.tinymce) {
          return;
        }

        var ngModel = ctrls[0],
          form = ctrls[1] || null;

        var expression, options = {
          debounce: true
        }, tinyInstance,
          updateView = function(editor) {
            var content = editor.getContent({format: options.format}).trim();
            content = $sce.trustAsHtml(content);

            ngModel.$setViewValue(content);
            if (!$rootScope.$$phase) {
              scope.$digest();
            }
          };

        function toggleDisable(disabled) {
          if (disabled) {
            ensureInstance();

            if (tinyInstance) {
              tinyInstance.getBody().setAttribute('contenteditable', false);
            }
          } else {
            ensureInstance();

            if (tinyInstance && !tinyInstance.settings.readonly) {
              tinyInstance.getBody().setAttribute('contenteditable', true);
            }
          }
        }

        // generate an ID
        attrs.$set('id', ID_ATTR + '-' + (new Date().valueOf()));

        expression = {};

        angular.extend(expression, scope.$eval(attrs.uiTinymce));

        //Debounce update and save action
        var debouncedUpdate = (function(debouncedUpdateDelay) {
          var debouncedUpdateTimer;
          return function(ed) {
	        $timeout.cancel(debouncedUpdateTimer);
	         debouncedUpdateTimer = $timeout(function() {
              return (function(ed) {
                if (ed.isDirty()) {
                  ed.save();
                  updateView(ed);
                }
              })(ed);
            }, debouncedUpdateDelay);
          };
        })(400);

        var setupOptions = {
          // Update model when calling setContent
          // (such as from the source editor popup)
          setup: function(ed) {
            ed.on('init', function() {
              ngModel.$render();
              ngModel.$setPristine();
                ngModel.$setUntouched();
              if (form) {
                form.$setPristine();
              }
            });

            // Update model when:
            // - a button has been clicked [ExecCommand]
            // - the editor content has been modified [change]
            // - the node has changed [NodeChange]
            // - an object has been resized (table, image) [ObjectResized]
            ed.on('ExecCommand change NodeChange ObjectResized', function() {
              if (!options.debounce) {
                ed.save();
                updateView(ed);
              	return;
              }
              debouncedUpdate(ed);
            });

            ed.on('blur', function() {
              element[0].blur();
              ngModel.$setTouched();
              if (!$rootScope.$$phase) {
                scope.$digest();
              }
            });

            ed.on('remove', function() {
              element.remove();
            });

            if (uiTinymceConfig.setup) {
              uiTinymceConfig.setup(ed, {
                updateView: updateView
              });
            }

            if (expression.setup) {
              expression.setup(ed, {
                updateView: updateView
              });
            }
          },
          format: expression.format || 'html',
          selector: '#' + attrs.id
        };
        // extend options with initial uiTinymceConfig and
        // options from directive attribute value
        angular.extend(options, uiTinymceConfig, expression, setupOptions);
        // Wrapped in $timeout due to $tinymce:refresh implementation, requires
        // element to be present in DOM before instantiating editor when
        // re-rendering directive
        $timeout(function() {
          if (options.baseURL){
            tinymce.baseURL = options.baseURL;
          }
          var maybeInitPromise = tinymce.init(options);
          if(maybeInitPromise && typeof maybeInitPromise.then === 'function') {
            maybeInitPromise.then(function() {
              toggleDisable(scope.$eval(attrs.ngDisabled));
            });
          } else {
            toggleDisable(scope.$eval(attrs.ngDisabled));
          }
        });

        ngModel.$formatters.unshift(function(modelValue) {
          return modelValue ? $sce.trustAsHtml(modelValue) : '';
        });

        ngModel.$parsers.unshift(function(viewValue) {
          return viewValue ? $sce.getTrustedHtml(viewValue) : '';
        });

        ngModel.$render = function() {
          ensureInstance();

          var viewValue = ngModel.$viewValue ?
            $sce.getTrustedHtml(ngModel.$viewValue) : '';

          // instance.getDoc() check is a guard against null value
          // when destruction & recreation of instances happen
          if (tinyInstance &&
            tinyInstance.getDoc()
          ) {
            tinyInstance.setContent(viewValue);
            // Triggering change event due to TinyMCE not firing event &
            // becoming out of sync for change callbacks
            tinyInstance.fire('change');
          }
        };

        attrs.$observe('disabled', toggleDisable);

        // This block is because of TinyMCE not playing well with removal and
        // recreation of instances, requiring instances to have different
        // selectors in order to render new instances properly
        scope.$on('$tinymce:refresh', function(e, id) {
          var eid = attrs.id;
          if (angular.isUndefined(id) || id === eid) {
            var parentElement = element.parent();
            var clonedElement = element.clone();
            clonedElement.removeAttr('id');
            clonedElement.removeAttr('style');
            clonedElement.removeAttr('aria-hidden');
            tinymce.execCommand('mceRemoveEditor', false, eid);
            parentElement.append($compile(clonedElement)(scope));
          }
        });

        scope.$on('$destroy', function() {
          ensureInstance();

          if (tinyInstance) {
            tinyInstance.remove();
            tinyInstance = null;
          }
        });

        function ensureInstance() {
          if (!tinyInstance) {
            tinyInstance = tinymce.get(attrs.id);
          }
        }
      }
    };
  }]);
